diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/accel/tcg/cpu-exec.c qemu-t8030-private/accel/tcg/cpu-exec.c
--- qemu-6.0.0/accel/tcg/cpu-exec.c	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/accel/tcg/cpu-exec.c	2021-05-05 10:12:52.629106200 +0800
@@ -165,7 +165,7 @@ cpu_tb_exec(CPUState *cpu, TranslationBl
 
     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb->pc,
                            "Trace %d: %p ["
-                           TARGET_FMT_lx "/" TARGET_FMT_lx "/%#x] %s\n",
+                           TARGET_FMT_lx "/" TARGET_FMT_lx "/%#lx] %s\n",
                            cpu->cpu_index, itb->tc.ptr,
                            itb->cs_base, itb->pc, itb->flags,
                            lookup_symbol(itb->pc));
@@ -247,7 +247,7 @@ void cpu_exec_step_atomic(CPUState *cpu)
     CPUArchState *env = (CPUArchState *)cpu->env_ptr;
     TranslationBlock *tb;
     target_ulong cs_base, pc;
-    uint32_t flags;
+    uint64_t flags;
     uint32_t cflags = (curr_cflags(cpu) & ~CF_PARALLEL) | 1;
     int tb_exit;
 
@@ -302,7 +302,7 @@ struct tb_desc {
     target_ulong cs_base;
     CPUArchState *env;
     tb_page_addr_t phys_page1;
-    uint32_t flags;
+    uint64_t flags;
     uint32_t cflags;
     uint32_t trace_vcpu_dstate;
 };
@@ -336,7 +336,7 @@ static bool tb_lookup_cmp(const void *p,
 }
 
 TranslationBlock *tb_htable_lookup(CPUState *cpu, target_ulong pc,
-                                   target_ulong cs_base, uint32_t flags,
+                                   target_ulong cs_base, uint64_t flags,
                                    uint32_t cflags)
 {
     tb_page_addr_t phys_pc;
@@ -419,7 +419,7 @@ static inline TranslationBlock *tb_find(
     CPUArchState *env = (CPUArchState *)cpu->env_ptr;
     TranslationBlock *tb;
     target_ulong cs_base, pc;
-    uint32_t flags;
+    uint64_t flags;
 
     cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);
 
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/accel/tcg/internal.h qemu-t8030-private/accel/tcg/internal.h
--- qemu-6.0.0/accel/tcg/internal.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/accel/tcg/internal.h	2021-05-05 10:12:52.631100900 +0800
@@ -12,7 +12,7 @@
 #include "exec/exec-all.h"
 
 TranslationBlock *tb_gen_code(CPUState *cpu, target_ulong pc,
-                              target_ulong cs_base, uint32_t flags,
+                              target_ulong cs_base, uint64_t flags,
                               int cflags);
 
 void QEMU_NORETURN cpu_io_recompile(CPUState *cpu, uintptr_t retaddr);
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/accel/tcg/tcg-runtime.c qemu-t8030-private/accel/tcg/tcg-runtime.c
--- qemu-6.0.0/accel/tcg/tcg-runtime.c	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/accel/tcg/tcg-runtime.c	2021-05-05 10:12:52.641098200 +0800
@@ -150,7 +150,7 @@ const void *HELPER(lookup_tb_ptr)(CPUArc
     CPUState *cpu = env_cpu(env);
     TranslationBlock *tb;
     target_ulong cs_base, pc;
-    uint32_t flags;
+    uint64_t flags;
 
     cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);
 
@@ -160,7 +160,7 @@ const void *HELPER(lookup_tb_ptr)(CPUArc
     }
     qemu_log_mask_and_addr(CPU_LOG_EXEC, pc,
                            "Chain %d: %p ["
-                           TARGET_FMT_lx "/" TARGET_FMT_lx "/%#x] %s\n",
+                           TARGET_FMT_lx "/" TARGET_FMT_lx "/%#lx] %s\n",
                            cpu->cpu_index, tb->tc.ptr, cs_base, pc, flags,
                            lookup_symbol(pc));
     return tb->tc.ptr;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/accel/tcg/translate-all.c qemu-t8030-private/accel/tcg/translate-all.c
--- qemu-6.0.0/accel/tcg/translate-all.c	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/accel/tcg/translate-all.c	2021-05-05 10:12:52.644440100 +0800
@@ -1843,7 +1843,7 @@ tb_link_page(TranslationBlock *tb, tb_pa
 /* Called with mmap_lock held for user mode emulation.  */
 TranslationBlock *tb_gen_code(CPUState *cpu,
                               target_ulong pc, target_ulong cs_base,
-                              uint32_t flags, int cflags)
+                              uint64_t flags, int cflags)
 {
     CPUArchState *env = cpu->env_ptr;
     TranslationBlock *tb, *existing_tb;
@@ -2130,7 +2130,7 @@ tb_invalidate_phys_page_range__locked(st
     TranslationBlock *current_tb = NULL;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
-    uint32_t current_flags = 0;
+    uint64_t current_flags = 0;
 #endif /* TARGET_HAS_PRECISE_SMC */
 
     assert_page_locked(p);
@@ -2318,7 +2318,7 @@ static bool tb_invalidate_phys_page(tb_p
     int current_tb_modified = 0;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
-    uint32_t current_flags = 0;
+    uint64_t current_flags = 0;
 #endif
 
     assert_memory_lock();
@@ -2387,7 +2387,7 @@ void tb_check_watchpoint(CPUState *cpu,
         CPUArchState *env = cpu->env_ptr;
         target_ulong pc, cs_base;
         tb_page_addr_t addr;
-        uint32_t flags;
+        uint64_t flags;
 
         cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);
         addr = get_page_addr_code(env, pc);
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/img4.asn1 qemu-t8030-private/hw/arm/img4.asn1
--- qemu-6.0.0/hw/arm/img4.asn1	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/img4.asn1	2021-05-05 10:12:53.325122400 +0800
@@ -0,0 +1,18 @@
+Img4 { }
+
+DEFINITIONS EXPLICIT TAGS ::=
+
+BEGIN
+
+Img4Payload ::= SEQUENCE {
+magic       IA5String (SIZE(1..4)),
+type        IA5String (SIZE(1..4)),
+description IA5String (SIZE(1..128)),
+data        OCTET STRING,
+
+-- This appears to be a sequence with two integers,
+-- at least for the DeviceTree file.
+extra       ANY                         OPTIONAL
+}
+
+END
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/img4.h qemu-t8030-private/hw/arm/img4.h
--- qemu-6.0.0/hw/arm/img4.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/img4.h	2021-05-05 10:12:53.325122400 +0800
@@ -0,0 +1,15 @@
+// Generated by asn1Parser -o img4.c -n img4_definitions_array img4.asn1
+
+#include <libtasn1.h>
+
+const asn1_static_node img4_definitions_array[] = {
+  { "Img4", 536872976, NULL },
+  { NULL, 1073741836, NULL },
+  { "Img4Payload", 536870917, NULL },
+  { "magic", 1075839005, NULL },
+  { "type", 1075839005, NULL },
+  { "description", 1075839005, NULL },
+  { "data", 1073741831, NULL },
+  { "extra", 16397, NULL },
+  { NULL, 0, NULL }
+};
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/meson.build qemu-t8030-private/hw/arm/meson.build
--- qemu-6.0.0/hw/arm/meson.build	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/hw/arm/meson.build	2021-05-05 10:12:53.330108900 +0800
@@ -1,5 +1,7 @@
 arm_ss = ss.source_set()
 arm_ss.add(files('boot.c'), fdt)
+arm_ss.add(when: 'TARGET_AARCH64', if_true: files('t8030.c', 'xnu_dtb.c', 'xnu_fb_cfg.c', 'xnu_file_mmio_dev.c', 'xnu_mem.c', 'xnu.c'))
+arm_ss.add(when: 'TARGET_AARCH64', if_true: tasn1)
 arm_ss.add(when: 'CONFIG_PLATFORM_BUS', if_true: files('sysbus-fdt.c'))
 arm_ss.add(when: 'CONFIG_ARM_VIRT', if_true: files('virt.c'))
 arm_ss.add(when: 'CONFIG_ACPI', if_true: files('virt-acpi-build.c'))
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/t8030.c qemu-t8030-private/hw/arm/t8030.c
--- qemu-6.0.0/hw/arm/t8030.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/t8030.c	2021-05-05 23:07:27.934732300 +0800
@@ -0,0 +1,1544 @@
+/*
+ * iPhone 11 - T8030
+ *
+ * Copyright (c) 2019 Johnathan Afek <jonyafek@me.com>
+ * Copyright (c) 2021 Nguyen Hoang Trung (TrungNguyen1909)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "exec/address-spaces.h"
+#include "hw/misc/unimp.h"
+#include "sysemu/block-backend.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/reset.h"
+#include "qemu/error-report.h"
+#include "hw/platform-bus.h"
+#include "arm-powerctl.h"
+
+#include "hw/arm/t8030.h"
+
+#include "hw/irq.h"
+#include "hw/or-irq.h"
+#include "hw/intc/apple_aic.h"
+#include "hw/block/apple_ans.h"
+#include "hw/gpio/apple_gpio.h"
+#include "hw/i2c/apple_i2c.h"
+
+#include "hw/arm/exynos4210.h"
+
+#define T8030_PHYS_BASE (0x800000000)
+#define CPU_IMPL_REG_BASE (0x210050000)
+#define CPM_IMPL_REG_BASE (0x210e40000)
+#define T8030_MAX_DEVICETREE_SIZE (0x40000)
+#define T8030_NVRAM_SIZE (0x2000)
+#define NOP_INST (0xd503201f)
+#define MOV_W0_01_INST (0x52800020)
+#define MOV_X13_0_INST (0xd280000d)
+#define RET_INST (0xd65f03c0)
+#define RETAB_INST (0xd65f0fff)
+
+#define T8030_CPREG_FUNCS(name)                                                    \
+    static uint64_t T8030_cpreg_read_##name(CPUARMState *env,                      \
+                                            const ARMCPRegInfo *ri)                \
+    {                                                                              \
+        T8030CPUState *tcpu = T8030_cs_from_env(env);                  \
+        return tcpu->T8030_CPREG_VAR_NAME(name);                                    \
+    }                                                                              \
+    static void T8030_cpreg_write_##name(CPUARMState *env, const ARMCPRegInfo *ri, \
+                                         uint64_t value)                           \
+    {                                                                              \
+        T8030CPUState *tcpu = T8030_cs_from_env(env);                  \
+        tcpu->T8030_CPREG_VAR_NAME(name) = value;                                   \
+        /* if (value != 0) fprintf(stderr, "T8030CPUState REG WRITE " #name " = 0x%llx at PC 0x%llx\n", value, env->pc); */ \
+    }
+
+#define T8030_CPREG_DEF(p_name, p_op0, p_op1, p_crn, p_crm, p_op2, p_access) \
+    {                                                                        \
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        \
+        .name = #p_name, .opc0 = p_op0, .crn = p_crn, .crm = p_crm,          \
+        .opc1 = p_op1, .opc2 = p_op2, .access = p_access, .type = ARM_CP_IO, \
+        .state = ARM_CP_STATE_AA64, .readfn = T8030_cpreg_read_##p_name,     \
+        .writefn = T8030_cpreg_write_##p_name                                \
+    }
+
+static T8030CPUState *T8030_cs_from_env(CPUARMState *env);
+
+T8030_CPREG_FUNCS(ARM64_REG_HID11)
+T8030_CPREG_FUNCS(ARM64_REG_HID13)
+T8030_CPREG_FUNCS(ARM64_REG_HID14)
+T8030_CPREG_FUNCS(ARM64_REG_HID3)
+T8030_CPREG_FUNCS(ARM64_REG_HID5)
+T8030_CPREG_FUNCS(ARM64_REG_HID4)
+T8030_CPREG_FUNCS(ARM64_REG_HID8)
+T8030_CPREG_FUNCS(ARM64_REG_HID7)
+T8030_CPREG_FUNCS(ARM64_REG_LSU_ERR_STS)
+T8030_CPREG_FUNCS(PMC0)
+T8030_CPREG_FUNCS(PMC1)
+T8030_CPREG_FUNCS(PMCR1)
+T8030_CPREG_FUNCS(PMSR)
+T8030_CPREG_FUNCS(ARM64_REG_APCTL_EL1)
+T8030_CPREG_FUNCS(ARM64_REG_KERNELKEYLO_EL1)
+T8030_CPREG_FUNCS(ARM64_REG_KERNELKEYHI_EL1)
+T8030_CPREG_FUNCS(ARM64_REG_EHID4)
+T8030_CPREG_FUNCS(S3_4_c15_c0_5)
+T8030_CPREG_FUNCS(S3_4_c15_c1_3)
+T8030_CPREG_FUNCS(S3_4_c15_c1_4)
+T8030_CPREG_FUNCS(ARM64_REG_CYC_OVRD)
+T8030_CPREG_FUNCS(ARM64_REG_ACC_CFG)
+T8030_CPREG_FUNCS(S3_6_c15_c1_0)
+T8030_CPREG_FUNCS(S3_6_c15_c1_1)
+T8030_CPREG_FUNCS(S3_6_c15_c1_2)
+T8030_CPREG_FUNCS(S3_6_c15_c1_5)
+T8030_CPREG_FUNCS(S3_6_c15_c1_6)
+T8030_CPREG_FUNCS(S3_6_c15_c1_7)
+T8030_CPREG_FUNCS(APRR_EL1)
+T8030_CPREG_FUNCS(S3_6_c15_c3_1)
+T8030_CPREG_FUNCS(S3_6_c15_c8_0)
+T8030_CPREG_FUNCS(S3_6_c15_c8_2)
+T8030_CPREG_FUNCS(S3_6_c15_c8_3)
+T8030_CPREG_FUNCS(UPMPCM)
+T8030_CPREG_FUNCS(UPMCR0)
+T8030_CPREG_FUNCS(UPMSR)
+T8030_CPREG_FUNCS(ARM64_REG_CTRR_A_LWR_EL1)
+T8030_CPREG_FUNCS(ARM64_REG_CTRR_A_UPR_EL1)
+T8030_CPREG_FUNCS(ARM64_REG_CTRR_CTL_EL1)
+T8030_CPREG_FUNCS(ARM64_REG_CTRR_LOCK_EL1)
+
+static void T8030_set_cs(CPUState *cpu, T8030CPUState *s)
+{
+    ARMCPU *arm_cpu = ARM_CPU(cpu);
+    CPUARMState *env = &arm_cpu->env;
+
+    env->t8030state = (void *)s;
+};
+
+static T8030CPUState *T8030_cs_from_env(CPUARMState *env)
+{
+    return env->t8030state;
+}
+
+static inline bool T8030CPU_is_sleep(T8030CPUState* tcpu)
+{
+    return CPU(tcpu->cpu)->halted;
+}
+
+// Wake up cpus, call with machine mutex unlocked
+static void T8030_wake_up_cpus(MachineState* machine, uint32_t cpu_mask)
+{
+    T8030MachineState* tms = T8030_MACHINE(machine);
+
+    WITH_QEMU_LOCK_GUARD(&tms->mutex) {
+        int i;
+
+        for(i = 0; i < machine->smp.cpus; i++) {
+            if (test_bit(i, (unsigned long*)&cpu_mask) && T8030CPU_is_sleep(tms->cpus[i])) {
+                int ret = QEMU_ARM_POWERCTL_RET_SUCCESS;
+
+                if (tms->cpus[i]->cpu->power_state != PSCI_ON) {
+                    ret = arm_set_cpu_on_and_reset(tms->cpus[i]->mpidr);
+                }
+
+                if (ret != QEMU_ARM_POWERCTL_RET_SUCCESS) {
+                    error_report("%s: failed to bring up CPU %d: err %d",
+                            __func__, i, ret);
+                }
+            }
+        }
+    }
+}
+
+static void T8030_wake_up_cpu(MachineState* machine, uint32_t cpu_id)
+{
+    T8030_wake_up_cpus(machine, 1 << cpu_id);
+}
+
+//Deliver IPI, call with cluster mutex locked
+static void T8030_cluster_deliver_ipi(cluster* c, uint64_t cpu_id, uint64_t src_cpu, uint64_t flag)
+{
+    T8030MachineState *tms;
+
+    T8030_wake_up_cpu(c->machine, cpu_id);
+
+    tms = T8030_MACHINE(c->machine);
+    if (tms->cpus[cpu_id]->ipi_sr)
+        return;
+
+    // fprintf(stderr, "Cluster %u delivering Fast IPI from CPU %x to CPU %x\n", c->id, src_cpu, cpu_id);
+    tms->cpus[cpu_id]->ipi_sr = 1LL | (src_cpu << IPI_SR_SRC_CPU_SHIFT) | flag;
+    qemu_irq_raise(tms->cpus[cpu_id]->fast_ipi);
+}
+
+//Deliver intercluster IPI
+static void T8030_ipi_rr_local(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    T8030CPUState *tcpu = T8030_cs_from_env(env);
+    T8030MachineState *tms = T8030_MACHINE(tcpu->machine);
+
+    WITH_QEMU_LOCK_GUARD(&tms->clusters[tcpu->cluster_id]->mutex) {
+        uint32_t phys_id = MPIDR_CPU_ID(value) | (tcpu->cluster_id << 8);
+        cluster *c = tms->clusters[tcpu->cluster_id];
+        uint32_t cpu_id = -1;
+        int i;
+
+        for(i = 0; i < MAX_CPU; i++) {
+            if (c->cpus[i]!=NULL) {
+                if (c->cpus[i]->phys_id==phys_id) {
+                    cpu_id = i;
+                    break;
+                }
+            }
+        }
+
+        // fprintf(stderr, "CPU %x sending fast IPI to local CPU %x: value: 0x%llx\n", tcpu->phys_id, phys_id, value);
+        if (cpu_id == -1 || c->cpus[cpu_id] == NULL) {
+            qemu_log_mask(LOG_GUEST_ERROR, "CPU %x failed to send fast IPI to local CPU %x: value: 0x" TARGET_FMT_lx "\n", tcpu->phys_id, phys_id, value);
+            return;
+        }
+
+        if ((value & ARM64_REG_IPI_RR_TYPE_NOWAKE) == ARM64_REG_IPI_RR_TYPE_NOWAKE) {
+            // fprintf(stderr, "...nowake ipi\n");
+            if (T8030CPU_is_sleep(c->cpus[cpu_id])) {
+                c->noWakeIPI[tcpu->cpu_id][cpu_id] = 1;
+            } else {
+                T8030_cluster_deliver_ipi(c, cpu_id, tcpu->cpu_id, ARM64_REG_IPI_RR_TYPE_IMMEDIATE);
+            }
+        } else if ((value & ARM64_REG_IPI_RR_TYPE_DEFERRED) == ARM64_REG_IPI_RR_TYPE_DEFERRED) {
+            // fprintf(stderr, "...deferred ipi\n");
+            c->deferredIPI[tcpu->cpu_id][cpu_id] = 1;
+        } else if ((value & ARM64_REG_IPI_RR_TYPE_RETRACT) == ARM64_REG_IPI_RR_TYPE_RETRACT) {
+            // fprintf(stderr, "...retract ipi\n");
+            c->deferredIPI[tcpu->cpu_id][cpu_id] = 0;
+            c->noWakeIPI[tcpu->cpu_id][cpu_id] = 0;
+        } else if ((value & ARM64_REG_IPI_RR_TYPE_IMMEDIATE) == ARM64_REG_IPI_RR_TYPE_IMMEDIATE) {
+            // fprintf(stderr, "...immediate ipi\n");
+            T8030_cluster_deliver_ipi(c, cpu_id, tcpu->cpu_id, ARM64_REG_IPI_RR_TYPE_IMMEDIATE);
+        }
+    }
+}
+
+// Deliver intracluster IPI
+static void T8030_ipi_rr_global(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    T8030CPUState *tcpu = T8030_cs_from_env(env);
+    T8030MachineState *tms = T8030_MACHINE(tcpu->machine);
+    uint32_t cluster_id = MPIDR_CLUSTER_ID(value >> IPI_RR_TARGET_CLUSTER_SHIFT);
+
+    if (cluster_id >= MAX_CLUSTER || tms->clusters[cluster_id] == 0)
+        return;
+
+    WITH_QEMU_LOCK_GUARD(&tms->clusters[cluster_id]->mutex) {
+        uint32_t phys_id = MPIDR_CPU_ID(value) | cluster_id << 8;
+        cluster *c = tms->clusters[cluster_id];
+        uint32_t cpu_id = -1;
+        int i;
+
+        for(i = 0; i < MAX_CPU; i++) {
+            if (c->cpus[i] != NULL) {
+                if (c->cpus[i]->phys_id == phys_id) {
+                    cpu_id = i;
+                    break;
+                }
+            }
+        }
+
+        // fprintf(stderr, "CPU %x sending fast IPI to global CPU %x: value: 0x%llx\n", tcpu->phys_id, phys_id, value);
+        if (cpu_id == -1 || c->cpus[cpu_id] == NULL) {
+            fprintf(stderr, "CPU %x failed to send fast IPI to global CPU %x: value: 0x" TARGET_FMT_lx "\n", tcpu->phys_id, phys_id, value);
+            return;
+        }
+
+        if ((value & ARM64_REG_IPI_RR_TYPE_NOWAKE) == ARM64_REG_IPI_RR_TYPE_NOWAKE) {
+            if (T8030CPU_is_sleep(c->cpus[cpu_id])) {
+                c->noWakeIPI[tcpu->cpu_id][cpu_id] = 1;
+            } else {
+                T8030_cluster_deliver_ipi(c, cpu_id, tcpu->cpu_id, ARM64_REG_IPI_RR_TYPE_IMMEDIATE);
+            }
+        } else if ((value & ARM64_REG_IPI_RR_TYPE_DEFERRED) == ARM64_REG_IPI_RR_TYPE_DEFERRED) {
+            c->deferredIPI[tcpu->cpu_id][cpu_id] = 1;
+        } else if ((value & ARM64_REG_IPI_RR_TYPE_RETRACT) == ARM64_REG_IPI_RR_TYPE_RETRACT) {
+            c->deferredIPI[tcpu->cpu_id][cpu_id] = 0;
+            c->noWakeIPI[tcpu->cpu_id][cpu_id] = 0;
+        } else if ((value & ARM64_REG_IPI_RR_TYPE_IMMEDIATE) == ARM64_REG_IPI_RR_TYPE_IMMEDIATE) {
+            T8030_cluster_deliver_ipi(c, cpu_id, tcpu->cpu_id, ARM64_REG_IPI_RR_TYPE_IMMEDIATE);
+        } 
+    }
+}
+
+//Receiving IPI
+static uint64_t T8030_ipi_read_sr(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    T8030CPUState *tcpu = T8030_cs_from_env(env);
+
+    assert(env_archcpu(env)->mp_affinity == tcpu->mpidr);
+    return tcpu->ipi_sr;
+}
+
+// Acknowledge received IPI
+static void T8030_ipi_write_sr(CPUARMState *env, const ARMCPRegInfo *ri,
+                               uint64_t value)
+{
+    T8030CPUState *tcpu = T8030_cs_from_env(env);
+    T8030MachineState *tms = T8030_MACHINE(tcpu->machine);
+    cluster *c = tms->clusters[tcpu->cluster_id];
+    uint64_t src_cpu = IPI_SR_SRC_CPU(value);
+
+    tcpu->ipi_sr = 0;
+    qemu_irq_lower(tcpu->fast_ipi);
+
+    WITH_QEMU_LOCK_GUARD(&c->mutex) {
+        if ((value & ARM64_REG_IPI_RR_TYPE_NOWAKE) == ARM64_REG_IPI_RR_TYPE_NOWAKE) {
+            c->noWakeIPI[src_cpu][tcpu->cpu_id] = 0;
+        } else if ((value & ARM64_REG_IPI_RR_TYPE_DEFERRED) == ARM64_REG_IPI_RR_TYPE_DEFERRED) {
+            c->deferredIPI[src_cpu][tcpu->cpu_id] = 0;
+        }
+    }
+    // fprintf(stderr, "CPU %x ack fast IPI from CPU %llu: 0x%llx\n", tcpu->cpu_id, src_cpu, value);
+}
+
+// Read deferred interrupt timeout (global)
+static uint64_t T8030_ipi_read_cr(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    T8030CPUState *tcpu = T8030_cs_from_env(env);
+    T8030MachineState *tms = T8030_MACHINE(tcpu->machine);
+    uint64_t abstime;
+
+    nanoseconds_to_absolutetime(tms->ipi_cr, &abstime);
+    return abstime;
+}
+
+//Set deferred interrupt timeout (global)
+static void T8030_ipi_write_cr(CPUARMState *env, const ARMCPRegInfo *ri,
+                               uint64_t value)
+{
+    uint64_t nanosec = 0;
+    T8030CPUState *tcpu = T8030_cs_from_env(env);
+    T8030MachineState *tms = T8030_MACHINE(tcpu->machine);
+
+    absolutetime_to_nanoseconds(value, &nanosec);
+    // fprintf(stderr, "T8030 adjusting deferred IPI timeout to " TARGET_FMT_lu "ns\n", nanosec);
+
+    WITH_QEMU_LOCK_GUARD(&tms->mutex) {
+        uint64_t ct;
+
+        if (value == 0)
+            value = kDeferredIPITimerDefault;
+
+        ct = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
+        timer_mod_ns(tms->ipicr_timer, (ct / tms->ipi_cr) * tms->ipi_cr + nanosec);
+        tms->ipi_cr = nanosec;
+    }
+}
+
+// This is the same as the array for kvm, but without
+// the L2ACTLR_EL1, which is already defined in TCG.
+// Duplicating this list isn't a perfect solution,
+// but it's quick and reliable.
+static const ARMCPRegInfo T8030_cp_reginfo_tcg[] = {
+    // Apple-specific registers
+    T8030_CPREG_DEF(ARM64_REG_HID11, 3, 0, 15, 13, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_HID13, 3, 0, 15, 14, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_HID14, 3, 0, 15, 15, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_HID3, 3, 0, 15, 3, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_HID5, 3, 0, 15, 5, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_HID4, 3, 0, 15, 4, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_EHID4, 3, 0, 15, 4, 1, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_HID8, 3, 0, 15, 8, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_HID7, 3, 0, 15, 7, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_LSU_ERR_STS, 3, 3, 15, 0, 0, PL1_RW),
+    T8030_CPREG_DEF(PMC0, 3, 2, 15, 0, 0, PL1_RW),
+    T8030_CPREG_DEF(PMC1, 3, 2, 15, 1, 0, PL1_RW),
+    T8030_CPREG_DEF(PMCR1, 3, 1, 15, 1, 0, PL1_RW),
+    T8030_CPREG_DEF(PMSR, 3, 1, 15, 13, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_APCTL_EL1, 3, 4, 15, 0, 4, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_KERNELKEYLO_EL1, 3, 4, 15, 1, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_KERNELKEYHI_EL1, 3, 4, 15, 1, 1, PL1_RW),
+    T8030_CPREG_DEF(S3_4_c15_c0_5, 3, 4, 15, 0, 5, PL1_RW),
+    T8030_CPREG_DEF(S3_4_c15_c1_3, 3, 4, 15, 1, 3, PL1_RW),
+    T8030_CPREG_DEF(S3_4_c15_c1_4, 3, 4, 15, 1, 4, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_CYC_OVRD, 3, 5, 15, 5, 0, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_ACC_CFG, 3, 5, 15, 4, 0, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c1_0, 3, 6, 15, 1, 0, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c1_1, 3, 6, 15, 1, 1, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c1_2, 3, 6, 15, 1, 2, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c1_5, 3, 6, 15, 1, 5, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c1_6, 3, 6, 15, 1, 6, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c1_7, 3, 6, 15, 1, 7, PL1_RW),
+    T8030_CPREG_DEF(APRR_EL1, 3, 6, 15, 3, 0, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c3_1, 3, 6, 15, 3, 1, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c8_0, 3, 6, 15, 8, 0, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c8_2, 3, 6, 15, 8, 2, PL1_RW),
+    T8030_CPREG_DEF(S3_6_c15_c8_3, 3, 6, 15, 8, 3, PL1_RW),
+    T8030_CPREG_DEF(UPMPCM, 3, 7, 15, 5, 4, PL1_RW),
+    T8030_CPREG_DEF(UPMCR0, 3, 7, 15, 0, 4, PL1_RW),
+    T8030_CPREG_DEF(UPMSR, 3, 7, 15, 6, 4, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_CTRR_A_LWR_EL1, 3, 4, 15, 2, 3, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_CTRR_A_UPR_EL1, 3, 4, 15, 2, 4, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_CTRR_CTL_EL1, 3, 4, 15, 2, 5, PL1_RW),
+    T8030_CPREG_DEF(ARM64_REG_CTRR_LOCK_EL1, 3, 4, 15, 2, 2, PL1_RW),
+    
+    //Cluster
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "ARM64_REG_IPI_RR_LOCAL",
+        .opc0 = 3, .opc1 = 5, .crn = 15, .crm = 0, .opc2 = 0,
+        .access = PL1_W, .type = ARM_CP_IO | ARM_CP_NO_RAW,
+        .state = ARM_CP_STATE_AA64,
+        .readfn = arm_cp_read_zero,
+        .writefn = T8030_ipi_rr_local
+    },
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "ARM64_REG_IPI_RR_GLOBAL",
+        .opc0 = 3, .opc1 = 5, .crn = 15, .crm = 0, .opc2 = 1,
+        .access = PL1_W, .type = ARM_CP_IO | ARM_CP_NO_RAW,
+        .state = ARM_CP_STATE_AA64,
+        .readfn = arm_cp_read_zero,
+        .writefn = T8030_ipi_rr_global
+    },
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "ARM64_REG_IPI_SR",
+        .opc0 = 3, .opc1 = 5, .crn = 15, .crm = 1, .opc2 = 1,
+        .access = PL1_RW, .type = ARM_CP_IO | ARM_CP_NO_RAW,
+        .state = ARM_CP_STATE_AA64,
+        .readfn = T8030_ipi_read_sr,
+        .writefn = T8030_ipi_write_sr
+    },
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "ARM64_REG_IPI_CR",
+        .opc0 = 3, .opc1 = 5, .crn = 15, .crm = 3, .opc2 = 1,
+        .access = PL1_RW, .type = ARM_CP_IO,
+        .state = ARM_CP_STATE_AA64,
+        .readfn = T8030_ipi_read_cr,
+        .writefn = T8030_ipi_write_cr
+    },
+    //GXF
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "GXF_ENTRY_EL1",
+        .opc0 = 3, .opc1 = 6, .crn = 15, .crm = 8, .opc2 = 1,
+        .access = PL1_RW, .resetvalue = 0,
+        .state = ARM_CP_STATE_AA64,
+        .fieldoffset = offsetof(CPUARMState, gxf.gxf_entry_el[1])
+    },  
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "TPIDR_GL11",
+        .opc0 = 3, .opc1 = 6, .crn = 15, .crm = 9, .opc2 = 1,
+        .access = PL1_RW, .resetvalue = 0,
+        .state = ARM_CP_STATE_AA64,
+        .fieldoffset = offsetof(CPUARMState, cp15.tpidr_el[1])
+    },
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "ESR_GL11",
+        .opc0 = 3, .opc1 = 6, .crn = 15, .crm = 9, .opc2 = 5,
+        .access = PL1_RW, .resetvalue = 0,
+        .state = ARM_CP_STATE_AA64,
+        .fieldoffset = offsetof(CPUARMState, cp15.esr_el[1])
+    },
+    {                                                                        
+        .cp = CP_REG_ARM64_SYSREG_CP,                                        
+        .name = "FAR_GL11",
+        .opc0 = 3, .opc1 = 6, .crn = 15, .crm = 9, .opc2 = 7,
+        .access = PL1_RW, .resetvalue = 0,
+        .state = ARM_CP_STATE_AA64,
+        .fieldoffset = offsetof(CPUARMState, cp15.far_el[1])
+    },
+    REGINFO_SENTINEL,
+};
+
+static void T8030_add_cpregs(T8030CPUState* tcpu)
+{
+    ARMCPU *cpu = tcpu->cpu;
+
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_HID11) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_HID3) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_HID5) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_HID8) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_HID7) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_LSU_ERR_STS) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(PMC0) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(PMC1) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(PMCR1) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(PMSR) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_APCTL_EL1) = 2;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_KERNELKEYLO_EL1) = 0;
+    tcpu->T8030_CPREG_VAR_NAME(ARM64_REG_KERNELKEYHI_EL1) = 0;
+
+    /* Note that we can't just use the T8030CPUState as an opaque pointer
+     * in define_arm_cp_regs_with_opaque(), because when we're called back
+     * it might be with code translated by CPU 0 but run by CPU 1, in
+     * which case we'd get the wrong value.
+     * So instead we define the regs with no ri->opaque info, and
+     * get back to the T8030CPUState from the CPUARMState.
+     */
+    T8030_set_cs(CPU(cpu), tcpu);
+    define_arm_cp_regs(cpu, T8030_cp_reginfo_tcg);
+}
+
+static void T8030_create_s3c_uart(const T8030MachineState *tms, Chardev *chr)
+{
+    DeviceState *dev;
+    hwaddr base;
+    //first fetch the uart mmio address
+    int vector;
+    DTBProp *prop;
+    hwaddr *uart_offset;
+    DTBNode *child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+
+    assert(child != NULL);
+
+    child = get_dtb_child_node_by_name(child, "uart0");
+    assert(child != NULL);
+
+    //make sure this node has the boot-console prop
+    prop = get_dtb_prop(child, "boot-console");
+    assert(prop != NULL);
+
+    prop = get_dtb_prop(child, "reg");
+    assert(prop != NULL);
+
+    uart_offset = (hwaddr *)prop->value;
+    base = tms->soc_base_pa + uart_offset[0];
+
+    prop = get_dtb_prop(child, "interrupts");
+    assert(prop);
+
+    vector = *(uint32_t*)prop->value;
+    dev = exynos4210_uart_create(base, 256, 0, chr, qdev_get_gpio_in(DEVICE(tms->aic), vector));
+    assert(dev);
+}
+
+static void T8030_patch_kernel(AddressSpace *nsas)
+{
+    // uint32_t value = 0;
+    // //disable_kprintf_output = 0
+    // address_space_rw(nsas, vtop_static(0xFFFFFFF0077142C8),
+    //                  MEMTXATTRS_UNSPECIFIED, (uint8_t *)&value,
+    //                  sizeof(value), 1);
+    //TODO: PMGR
+    // value = RET_INST;
+    // //AppleT8030PMGR::panicHW
+    // address_space_rw(nsas, vtop_static(0xFFFFFFF008B2DBE4),
+    //                  MEMTXATTRS_UNSPECIFIED, (uint8_t *)&value,
+    //                  sizeof(value), 1);
+    // //AppleImage4 _xnu_log 
+    // value = NOP_INST;
+    // address_space_rw(nsas, vtop_static(0xFFFFFFF008387A28),
+    //                  MEMTXATTRS_UNSPECIFIED, (uint8_t *)&value,
+    //                  sizeof(value), 1);
+}
+
+static void T8030_memory_setup(MachineState *machine)
+{
+    uint64_t used_ram_for_blobs = 0;
+    hwaddr kernel_low;
+    hwaddr kernel_high;
+    hwaddr virt_base;
+    hwaddr dtb_pa;
+    hwaddr dtb_va;
+    uint64_t dtb_size;
+    hwaddr kbootargs_pa;
+    hwaddr top_of_kernel_data_pa;
+    hwaddr mem_size;
+    hwaddr remaining_mem_size;
+    hwaddr allocated_ram_pa;
+    hwaddr phys_ptr;
+    hwaddr phys_pc;
+    video_boot_args v_bootargs = {0};
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    MemoryRegion* sysmem = tms->sysmem;
+    AddressSpace* nsas = tms->cpus[0]->nsas;
+    uint64_t trustcache_size = 0;
+    hwaddr trustcache_pa;
+    void *nvram_data = NULL;
+    NvmeNamespace* nvram;
+    hwaddr ramdisk_size = 0;
+
+    //setup the memory layout:
+
+    //At the beginning of the non-secure ram we have the raw kernel file.
+    //After that we have the static trust cache.
+    //After that we have all the kernel sections.
+    //After that we have ramdosk
+    //After that we have the device tree
+    //After that we have the kernel boot args
+    //After that we have the rest of the RAM
+
+    macho_file_highest_lowest(tms->kernel_filename, &kernel_low, &kernel_high);
+
+    g_virt_base = virt_base = align_64k_low(kernel_low);
+    g_phys_base = T8030_PHYS_BASE;
+    phys_ptr = T8030_PHYS_BASE;
+    fprintf(stderr, "g_virt_base: 0x" TARGET_FMT_lx "\ng_phys_base: 0x" TARGET_FMT_lx "\n", g_virt_base, g_phys_base);
+    fprintf(stderr, "kernel_low: 0x" TARGET_FMT_lx "\nkernel_high: 0x" TARGET_FMT_lx "\n", kernel_low, kernel_high);
+
+    // //now account for the trustcache
+    phys_ptr += align_64k_high(0x2000000);
+    trustcache_pa = phys_ptr;
+    macho_load_trustcache(tms->trustcache_filename, nsas, sysmem, trustcache_pa, &trustcache_size);
+    phys_ptr += align_64k_high(trustcache_size);
+
+    used_ram_for_blobs += align_64k_high(trustcache_size);
+    //now account for the loaded kernel
+    arm_load_macho(tms->kernel_filename, nsas, sysmem, "Kernel",
+                   T8030_PHYS_BASE, virt_base, &phys_pc);
+    tms->kpc_pa = phys_pc;
+    used_ram_for_blobs += (align_64k_high(kernel_high) - kernel_low);
+
+    T8030_patch_kernel(nsas);
+
+    phys_ptr = align_64k_high(vtop_static(kernel_high));
+
+    //now account for device tree
+    dtb_pa = phys_ptr;
+
+    dtb_va = ptov_static(phys_ptr);
+    phys_ptr += align_64k_high(T8030_MAX_DEVICETREE_SIZE);
+    used_ram_for_blobs += align_64k_high(T8030_MAX_DEVICETREE_SIZE);
+    //now account for the ramdisk
+    tms->ramdisk_file_dev.pa = 0;
+
+    if (tms->ramdisk_filename[0]) {
+        tms->ramdisk_file_dev.pa = phys_ptr;
+        macho_load_ramdisk(tms->ramdisk_filename, nsas, sysmem, phys_ptr, &tms->ramdisk_file_dev.size);
+        tms->ramdisk_file_dev.size = align_64k_high(tms->ramdisk_file_dev.size);
+        ramdisk_size = tms->ramdisk_file_dev.size;
+        phys_ptr += tms->ramdisk_file_dev.size;
+        used_ram_for_blobs += tms->ramdisk_file_dev.size;
+    }
+    
+    //now account for kernel boot args
+    used_ram_for_blobs += align_64k_high(sizeof(struct xnu_arm64_boot_args));
+    kbootargs_pa = phys_ptr;
+    tms->kbootargs_pa = kbootargs_pa;
+    phys_ptr += align_64k_high(sizeof(struct xnu_arm64_boot_args));
+    tms->extra_data_pa = phys_ptr;
+
+    top_of_kernel_data_pa = phys_ptr;
+    allocated_ram_pa = phys_ptr;
+    
+    remaining_mem_size = T8030_PHYS_BASE + machine->ram_size - allocated_ram_pa;
+    mem_size = machine->ram_size;
+    tms->dram_base = T8030_PHYS_BASE;
+    tms->dram_size = machine->ram_size;
+
+    nvram = NVME_NS(qdev_find_recursive(sysbus_get_default(), "nvram"));
+    assert(nvram);
+
+    nvram_data = g_malloc0(T8030_NVRAM_SIZE);
+    blk_pread(nvram->blkconf.blk, 0, nvram_data, T8030_NVRAM_SIZE);
+    
+    macho_load_dtb(tms->device_tree, nsas, sysmem, "DeviceTree",
+                   dtb_pa, &dtb_size,
+                   tms->ramdisk_file_dev.pa, ramdisk_size,
+                   trustcache_pa, trustcache_size,
+                   kbootargs_pa,
+                   tms->dram_base, tms->dram_size,
+                   nvram_data, T8030_NVRAM_SIZE);
+    g_free(nvram_data);
+    assert(dtb_size <= T8030_MAX_DEVICETREE_SIZE);
+
+    macho_setup_bootargs("BootArgs", nsas, sysmem, kbootargs_pa,
+                         virt_base, T8030_PHYS_BASE, mem_size,
+                         top_of_kernel_data_pa, dtb_va, dtb_size,
+                         v_bootargs, tms->kern_args);
+
+    allocate_ram(sysmem, "RAM", allocated_ram_pa, remaining_mem_size);
+}
+
+static void cpu_impl_reg_write(void *opaque, hwaddr addr, uint64_t data, unsigned size)
+{
+    T8030CPUState *cpu = (T8030CPUState*)opaque;
+    fprintf(stderr, "CPU %x cpu-impl-reg WRITE @ 0x" TARGET_FMT_lx " value: 0x" TARGET_FMT_lx "\n", cpu->cpu_id, addr, data);
+}
+
+static uint64_t cpu_impl_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    T8030CPUState *cpu = (T8030CPUState*) opaque;
+    fprintf(stderr, "CPU %x cpu-impl-reg READ @ 0x" TARGET_FMT_lx "\n", cpu->cpu_id, addr);
+    return 0;
+}
+
+static const MemoryRegionOps cpu_impl_reg_ops = {
+    .write = cpu_impl_reg_write,
+    .read = cpu_impl_reg_read,
+};
+
+static void cpu_coresight_reg_write(void *opaque, hwaddr addr, uint64_t data, unsigned size)
+{
+}
+
+static uint64_t cpu_coresight_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    return 0;
+}
+
+static const MemoryRegionOps cpu_coresight_reg_ops = {
+    .write = cpu_coresight_reg_write,
+    .read = cpu_coresight_reg_read,
+};
+
+static void cpm_impl_reg_write(void *opaque, hwaddr addr, uint64_t data, unsigned size)
+{
+    cluster* cpm = (cluster*) opaque;
+    fprintf(stderr, "Cluster %u cpm-impl-reg WRITE @ 0x" TARGET_FMT_lx " value: 0x" TARGET_FMT_lx "\n", cpm->id, addr, data);
+}
+
+static uint64_t cpm_impl_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    cluster* cpm = (cluster*) opaque;
+
+    fprintf(stderr, "Cluster %u cpm-impl-reg READ @ 0x" TARGET_FMT_lx "\n", cpm->id, addr);
+
+    return 0;
+}
+
+static const MemoryRegionOps cpm_impl_reg_ops = {
+    .write = cpm_impl_reg_write,
+    .read = cpm_impl_reg_read,
+};
+
+static void pmgr_unk_reg_write(void *opaque, hwaddr addr, uint64_t data, unsigned size)
+{
+    //hwaddr* base = (hwaddr*) opaque;
+    //fprintf(stderr, "PMGR reg WRITE unk @ 0x" TARGET_FMT_lx " base: 0x" TARGET_FMT_lx " value: 0x" TARGET_FMT_lx "\n", base + addr, base, data);
+}
+
+static uint64_t pmgr_unk_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    hwaddr* base = (hwaddr*) opaque;
+
+    //fprintf(stderr, "PMGR reg READ unk @ 0x" TARGET_FMT_lx " base: 0x" TARGET_FMT_lx "\n", base + addr, base);
+    if (((uint64_t)(base + addr) & 0x10e70000) == 0x10e70000) {
+        return (108<<4) | 0x200000;
+    }
+
+    return 0;
+}
+
+static const MemoryRegionOps pmgr_unk_reg_ops = {
+    .write = pmgr_unk_reg_write,
+    .read = pmgr_unk_reg_read,
+};
+
+static void pmgr_reg_write(void *opaque, hwaddr addr, uint64_t data, unsigned size)
+{
+    MachineState *machine = MACHINE(opaque);
+
+    // fprintf(stderr, "PMGR reg WRITE @ 0x" TARGET_FMT_lx " value: 0x" TARGET_FMT_lx "\n", addr, data);
+    switch (addr) {
+        case 0xd4004:
+            T8030_wake_up_cpus(machine, data);
+            return;
+    }
+}
+
+static uint64_t pmgr_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    // fprintf(stderr, "PMGR reg READ @ 0x" TARGET_FMT_lx "\n", addr);
+    switch(addr) {
+        case 0xf0010: /* AppleT8030PMGR::commonSramCheck */
+            return 0x5000;
+        case 0x802d8:
+        case 0x80308:
+        case 0x80310:
+        case 0x80318:
+        case 0x80320:
+        case 0x80328:
+        case 0x80330:
+            return 0xf0;
+    }
+    return 0;
+}
+
+static const MemoryRegionOps pmgr_reg_ops = {
+    .write = pmgr_reg_write,
+    .read = pmgr_reg_read,
+};
+
+static void sart_reg_write(void *opaque, hwaddr addr, uint64_t data, unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "SART reg WRITE @ 0x" TARGET_FMT_lx " value: 0x" TARGET_FMT_lx "\n", addr, data);
+}
+
+static uint64_t sart_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "SART reg READ @ 0x" TARGET_FMT_lx "\n", addr);
+
+    return 0;
+}
+
+static const MemoryRegionOps sart_reg_ops = {
+    .write = sart_reg_write,
+    .read = sart_reg_read,
+};
+
+static void T8030_cluster_setup(MachineState *machine)
+{
+    T8030MachineState *tms = T8030_MACHINE(machine);
+
+    tms->clusters[0] = g_new0(cluster, 1);
+    //TODO: find base through device tree
+    tms->clusters[0]->base = CPM_IMPL_REG_BASE;
+    tms->clusters[0]->type = '0'; // E-CORE
+    tms->clusters[0]->id = 0;
+    tms->clusters[0]->mr = g_new(MemoryRegion, 1);
+    tms->clusters[0]->machine = machine;
+    qemu_mutex_init(&tms->clusters[0]->mutex);
+    memory_region_init_io(tms->clusters[0]->mr, OBJECT(machine), &cpm_impl_reg_ops, tms->clusters[0], "cpm-impl-reg", 0x10000);
+    memory_region_add_subregion(tms->sysmem, tms->clusters[0]->base, tms->clusters[0]->mr);
+    tms->clusters[1] = g_new0(cluster, 1);
+    //TODO: find base through device tree
+    tms->clusters[1]->base = CPM_IMPL_REG_BASE + 0x10000;
+    tms->clusters[1]->type = '1'; // P-CORE
+    tms->clusters[1]->id = 1;
+    tms->clusters[1]->mr = g_new(MemoryRegion, 1);
+    tms->clusters[1]->machine = machine;
+
+    qemu_mutex_init(&tms->clusters[1]->mutex);
+    memory_region_init_io(tms->clusters[1]->mr, OBJECT(machine), &cpm_impl_reg_ops, tms->clusters[1], "cpm-impl-reg", 0x10000);
+    memory_region_add_subregion(tms->sysmem, tms->clusters[1]->base,tms->clusters[1]->mr);
+}
+
+static void T8030_cpu_setup(MachineState *machine)
+{
+    unsigned int i;
+    DTBNode *root;
+    T8030MachineState *tms = T8030_MACHINE(machine);
+
+    T8030_cluster_setup(machine);
+
+    root = get_dtb_child_node_by_name(tms->device_tree, "cpus");
+
+    for(i = 0; i<MAX_CPU; i++) {
+        char cpu_name[8];
+        unsigned int cpu_id, phys_id, cluster_id, mpidr;
+        uint64_t freq;
+        uint64_t *reg;
+        DeviceState *fiq_or;
+        DTBNode *node;
+        DTBProp* prop = NULL;
+        Object *cpuobj;
+        CPUState *cs;
+
+        snprintf(cpu_name, 8, "cpu%u", i);
+        node = get_dtb_child_node_by_name(root, cpu_name);
+        assert(node);
+
+        if (i >= machine->smp.cpus) {
+            remove_dtb_node(root, node);
+            continue;
+        }
+
+        cpuobj = object_new(machine->cpu_type);
+        tms->cpus[i] = g_new(T8030CPUState, 1);
+        tms->cpus[i]->cpu = ARM_CPU(cpuobj);
+        tms->cpus[i]->machine = machine;
+        cs = CPU(tms->cpus[i]->cpu);
+
+        //MPIDR_EL1
+        prop = get_dtb_prop(node, "cpu-id");
+        assert(prop->length == 4);
+        cpu_id = *(unsigned int*)prop->value;
+
+        prop = get_dtb_prop(node, "reg");
+        assert(prop->length == 4);
+        phys_id = *(unsigned int*)prop->value;
+
+        prop = get_dtb_prop(node, "cluster-id");
+        assert(prop->length == 4);
+        cluster_id = *(unsigned int*)prop->value;
+
+        mpidr = 0LL | phys_id | (tms->clusters[cluster_id]->type << MPIDR_AFF2_SHIFT) | (1LL << 31);
+        object_property_set_uint(cpuobj, "mp-affinity", mpidr, &error_fatal);
+        object_property_set_uint(cpuobj, "cntfrq", 24000000, &error_fatal);
+        tms->cpus[i]->mpidr = mpidr;
+        tms->cpus[i]->cpu_id = cpu_id;
+        tms->cpus[i]->phys_id = phys_id;
+        tms->cpus[i]->cluster_id = cluster_id;
+        tms->clusters[cluster_id]->cpus[cpu_id] = tms->cpus[i];
+
+        //remove debug regs from device tree
+        prop = get_dtb_prop(node, "reg-private");
+        if (prop != NULL) {
+            remove_dtb_prop(node, prop);
+        }
+
+        prop = get_dtb_prop(node, "cpu-uttdbg-reg");
+        if (prop != NULL) {
+            remove_dtb_prop(node, prop);
+        }
+
+        //need to set the cpu freqs instead of iboot
+        freq = 24000000;
+
+        if (i == 0) {
+            prop = get_dtb_prop(node, "state");
+            if (prop != NULL) {
+                remove_dtb_prop(node, prop);
+            }
+            add_dtb_prop(node, "state", 8, (uint8_t*)"running");
+        }
+
+        prop = get_dtb_prop(node, "timebase-frequency");
+        if (prop != NULL) {
+            remove_dtb_prop(node, prop);
+        }
+        add_dtb_prop(node, "timebase-frequency", sizeof(uint64_t), (uint8_t *)&freq);
+
+        prop = get_dtb_prop(node, "fixed-frequency");
+        if (prop != NULL) {
+            remove_dtb_prop(node, prop);
+        }
+        add_dtb_prop(node, "fixed-frequency", sizeof(uint64_t), (uint8_t *)&freq);
+
+        //per cpu memory region
+        tms->cpus[i]->memory = g_new(MemoryRegion, 1);
+        memory_region_init(tms->cpus[i]->memory, OBJECT(machine), "cpu-memory", UINT64_MAX);
+        tms->cpus[i]->sysmem = g_new(MemoryRegion, 1);
+        memory_region_init_alias(tms->cpus[i]->sysmem, OBJECT(tms->cpus[i]->memory), "sysmem", tms->sysmem, 0, UINT64_MAX);
+        memory_region_add_subregion_overlap(tms->cpus[i]->memory, 0, tms->cpus[i]->sysmem, -2);
+        object_property_set_link(cpuobj, "memory", OBJECT(tms->cpus[i]->memory), &error_abort);
+        //set secure monitor to false
+        object_property_set_bool(cpuobj, "has_el3", false, NULL);
+
+        object_property_set_bool(cpuobj, "has_el2", false, NULL);
+
+        if (i > 0) {
+            object_property_set_bool(cpuobj, "start-powered-off", true, NULL);
+        }
+
+        qdev_realize(DEVICE(cpuobj), NULL, &error_fatal);
+        
+        tms->cpus[i]->nsas = cpu_get_address_space(cs, ARMASIdx_NS);
+
+        prop = get_dtb_prop(node, "cpu-impl-reg");
+        assert(prop);
+        assert(prop->length == 16);
+
+        reg = (uint64_t*)prop->value;
+        tms->cpus[i]->impl_reg = g_new(MemoryRegion, 1);
+        memory_region_init_io(tms->cpus[i]->impl_reg, cpuobj, &cpu_impl_reg_ops, tms->cpus[i], "cpu-impl-reg", reg[1]);
+
+        hwaddr cpu_impl_reg_addr = reg[0];
+
+        memory_region_add_subregion(tms->sysmem, cpu_impl_reg_addr, tms->cpus[i]->impl_reg);
+
+        prop = get_dtb_prop(node, "coresight-reg");
+        assert(prop);
+        assert(prop->length == 16);
+
+        reg = (uint64_t*)prop->value;
+        tms->cpus[i]->coresight_reg = g_new(MemoryRegion, 1);
+        memory_region_init_io(tms->cpus[i]->coresight_reg, cpuobj, &cpu_coresight_reg_ops, tms->cpus[i], "coresight-reg", reg[1]);
+
+        hwaddr cpu_coresight_reg_addr = reg[0];
+
+        memory_region_add_subregion(tms->sysmem, cpu_coresight_reg_addr, tms->cpus[i]->coresight_reg);
+
+        fiq_or = qdev_new(TYPE_OR_IRQ);
+        object_property_add_child(cpuobj, "fiq-or", OBJECT(fiq_or));
+        qdev_prop_set_uint16(fiq_or, "num-lines", 16);
+        qdev_realize_and_unref(fiq_or, NULL, &error_fatal);
+
+        qdev_connect_gpio_out(fiq_or, 0, qdev_get_gpio_in(DEVICE(cpuobj), ARM_CPU_FIQ));
+
+        qdev_connect_gpio_out(DEVICE(cpuobj), GTIMER_VIRT, qdev_get_gpio_in(fiq_or, 0));
+        tms->cpus[i]->fast_ipi = qdev_get_gpio_in(fiq_or, 1);
+
+        T8030_add_cpregs(tms->cpus[i]);
+    }
+}
+
+static void T8030_bootargs_setup(MachineState *machine)
+{
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    tms->bootinfo.firmware_loaded = true;
+}
+
+static void T8030_create_aic(MachineState *machine)
+{
+    unsigned int i;
+    hwaddr *reg;
+    DTBProp *prop;
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    DTBNode *child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+
+    assert(child != NULL);
+    child = get_dtb_child_node_by_name(child, "aic");
+    assert(child != NULL);
+
+    tms->aic = apple_aic_create(machine->smp.cpus, child);
+    object_property_add_child(OBJECT(machine), "aic", OBJECT(tms->aic));
+    assert(tms->aic);
+
+    prop = get_dtb_prop(child, "reg");
+    assert(prop != NULL);
+
+    reg = (hwaddr*)prop->value;
+
+    for(i = 0; i < machine->smp.cpus; i++) {
+        memory_region_add_subregion_overlap(tms->cpus[i]->memory, tms->soc_base_pa + reg[0], sysbus_mmio_get_region(SYS_BUS_DEVICE(tms->aic), i), 0);
+        sysbus_connect_irq(SYS_BUS_DEVICE(tms->aic), i, qdev_get_gpio_in(DEVICE(tms->cpus[i]->cpu), ARM_CPU_IRQ));
+    }
+
+    sysbus_realize(SYS_BUS_DEVICE(tms->aic), &error_fatal);
+}
+
+static void T8030_pmgr_setup(MachineState* machine)
+{
+    uint64_t *reg;
+    int i;
+    char name[32];
+    DTBProp *prop;
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    DTBNode *child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+
+    assert(child != NULL);
+    child = get_dtb_child_node_by_name(child, "pmgr");
+    assert(child != NULL);
+
+    prop = get_dtb_prop(child, "reg");
+    assert(prop);
+
+    reg = (uint64_t*)prop->value;
+
+    for(i = 0; i < prop->length / 8; i+=2) {
+        MemoryRegion* mem = g_new(MemoryRegion, 1);
+        if (i > 0) {
+            snprintf(name, 32, "pmgr-unk-reg-%d", i);
+            memory_region_init_io(mem, OBJECT(machine), &pmgr_unk_reg_ops, (void*)reg[i], name, reg[i+1]);
+        } else {
+            memory_region_init_io(mem, OBJECT(machine), &pmgr_reg_ops, tms, "pmgr-reg", reg[i+1]);
+        }
+        memory_region_add_subregion(tms->sysmem, reg[i] + reg[i+1] < tms->soc_size ? tms->soc_base_pa + reg[i] : reg[i], mem);
+    }
+
+    {
+        MemoryRegion *mem = g_new(MemoryRegion, 1);
+
+        snprintf(name, 32, "pmp-reg");
+        memory_region_init_io(mem, OBJECT(machine), &pmgr_unk_reg_ops, (void*)0x3BC00000, name, 0x60000);
+        memory_region_add_subregion(tms->sysmem, tms->soc_base_pa + 0x3BC00000, mem);
+    }
+
+    add_dtb_prop(child, "voltage-states0", 24, (uint8_t*)"\x01\x00\x00\x00\x71\x02\x00\x00\x01\x00\x00\x00\xa9\x02\x00\x00\x01\x00\x00\x00\xe4\x02\x00\x00");
+    add_dtb_prop(child, "voltage-states1", 40, (uint8_t*)"\x71\xbc\x01\x00\x38\x02\x00\x00\x4b\x28\x01\x00\x83\x02\x00\x00\x38\xde\x00\x00\xde\x02\x00\x00\xc7\xb1\x00\x00\x42\x03\x00\x00\x25\x94\x00\x00\xaf\x03\x00\x00");
+    add_dtb_prop(child, "voltage-states2", 24, (uint8_t*)"\x01\x00\x00\x00\x74\x02\x00\x00\x01\x00\x00\x00\xb8\x02\x00\x00\x01\x00\x00\x00\x42\x03\x00\x00");
+    add_dtb_prop(child, "voltage-states5", 64, (uint8_t*)"\x12\xda\x01\x00\x38\x02\x00\x00\xb3\x18\x01\x00\x71\x02\x00\x00\x87\xc5\x00\x00\xb8\x02\x00\x00\xa2\x89\x00\x00\x20\x03\x00\x00\x37\x75\x00\x00\x87\x03\x00\x00\xaa\x6a\x00\x00\xe8\x03\x00\x00\xc3\x62\x00\x00\x48\x04\x00\x00\x18\x60\x00\x00\x65\x04\x00\x00");
+    add_dtb_prop(child, "voltage-states8", 96, (uint8_t*)"\x00\xf4\x06\x14\xff\xff\xff\xff\x00\x2a\x75\x15\xff\xff\xff\xff\x00\x6e\x0a\x1e\xff\xff\xff\xff\x00\xbf\x2f\x20\xff\xff\xff\xff\x00\x1e\x7c\x29\xff\xff\xff\xff\x00\xa5\x0f\x2d\xff\xff\xff\xff\x00\x55\x81\x38\xff\xff\xff\xff\x00\x7e\x5f\x40\xff\xff\xff\xff\x00\xb4\xcd\x41\xff\xff\xff\xff\x00\x8c\x86\x47\xff\xff\xff\xff\x00\x64\x3f\x4d\xff\xff\xff\xff\x80\xc9\x53\x53\xff\xff\xff\xff");
+    add_dtb_prop(child, "voltage-states9", 56, (uint8_t*)"\x00\x00\x00\x00\x90\x01\x00\x00\x00\x2a\x75\x15\x3f\x02\x00\x00\xc0\x4f\xef\x1e\x7a\x02\x00\x00\x00\xcd\x56\x27\x90\x02\x00\x00\x00\x11\xec\x2f\xc8\x02\x00\x00\x00\x55\x81\x38\x16\x03\x00\x00\x80\xfe\x2a\x47\x96\x03\x00\x00");
+    add_dtb_prop(child, "voltage-states10", 24, (uint8_t*)"\x01\x00\x00\x00\x67\x02\x00\x00\x01\x00\x00\x00\x90\x02\x00\x00\x01\x00\x00\x00\xc2\x02\x00\x00");
+    add_dtb_prop(child, "voltage-states11", 24, (uint8_t*)"\x01\x00\x00\x00\x29\x02\x00\x00\x01\x00\x00\x00\x71\x02\x00\x00\x01\x00\x00\x00\xf4\x02\x00\x00");
+    add_dtb_prop(child, "bridge-settings-12", 192, (uint8_t*)"\x00\x00\x00\x00\x11\x00\x00\x00\x0c\x00\x00\x00\xe8\x7c\x18\x03\x54\x00\x00\x00\x12\x00\x00\x00\x00\x09\x00\x00\x01\x00\x01\x40\x24\x09\x00\x00\x18\x08\x08\x00\x28\x09\x00\x00\x01\x00\x00\x00\x48\x09\x00\x00\x01\x00\x00\x00\x64\x09\x00\x00\x18\x08\x08\x00\x88\x09\x00\x00\x01\x00\x00\x00\x00\x0a\x00\x00\x7f\x00\x00\x00\x00\x10\x00\x00\x01\x01\x00\x00\x00\x40\x00\x00\x03\x00\x00\x00\x04\x40\x00\x00\x03\x00\x00\x00\x08\x40\x00\x00\x03\x00\x00\x00\x0c\x40\x00\x00\x03\x00\x00\x00\x04\x41\x00\x00\x01\x00\x00\x00\x00\x43\x00\x00\x01\x00\x01\xc0\x38\x43\x00\x00\x01\x00\x00\x00\x48\x43\x00\x00\x01\x00\x00\x00\x00\x80\x00\x00\x0f\x00\x00\x00\x00\x82\x00\x00\x01\x00\x01\xc0\x28\x82\x00\x00\x01\x00\x00\x00\x38\x82\x00\x00\x01\x00\x00\x00\x48\x82\x00\x00\x01\x00\x00\x00");
+    add_dtb_prop(child, "bridge-settings-13", 64, (uint8_t*)"\x00\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00\x08\x00\x00\x00\x03\x00\x00\x00\x0c\x00\x00\x00\x03\x00\x00\x00\x04\x01\x00\x00\x01\x00\x00\x00\x00\x03\x00\x00\x01\x00\x01\xc0\x38\x03\x00\x00\x01\x00\x00\x00\x48\x03\x00\x00\x01\x00\x00\x00");
+    add_dtb_prop(child, "bridge-settings-14", 40, (uint8_t*)"\x00\x00\x00\x00\x0f\x00\x00\x00\x00\x02\x00\x00\x01\x00\x01\xc0\x28\x02\x00\x00\x01\x00\x00\x00\x38\x02\x00\x00\x01\x00\x00\x00\x48\x02\x00\x00\x01\x00\x00\x00");
+    add_dtb_prop(child, "bridge-settings-15", 144, (uint8_t*)"\x00\x00\x00\x00\x01\x00\x00\x00\x0c\x00\x00\x00\x98\x7e\x68\x01\x00\x0a\x00\x00\x01\x00\x01\x40\x24\x0a\x00\x00\x18\x08\x08\x00\x44\x0a\x00\x00\x18\x08\x08\x00\x64\x0a\x00\x00\x18\x08\x08\x00\x84\x0a\x00\x00\x18\x08\x08\x00\x00\x0b\x00\x00\x7f\x00\x00\x00\x00\x11\x00\x00\x01\x01\x00\x00\x00\x40\x00\x00\x03\x00\x00\x00\x04\x40\x00\x00\x03\x00\x00\x00\x08\x40\x00\x00\x03\x00\x00\x00\x0c\x40\x00\x00\x03\x00\x00\x00\x10\x40\x00\x00\x03\x00\x00\x00\x04\x41\x00\x00\x01\x00\x00\x00\x00\x43\x00\x00\x01\x00\x01\xc0\x00\x80\x00\x00\x0f\x00\x00\x00\x00\x82\x00\x00\x01\x00\x01\xc0");
+    add_dtb_prop(child, "bridge-settings-16", 56, (uint8_t*)"\x00\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00\x08\x00\x00\x00\x03\x00\x00\x00\x0c\x00\x00\x00\x03\x00\x00\x00\x10\x00\x00\x00\x03\x00\x00\x00\x04\x01\x00\x00\x01\x00\x00\x00\x00\x03\x00\x00\x01\x00\x01\xc0");
+    add_dtb_prop(child, "bridge-settings-17", 16, (uint8_t*)"\x00\x00\x00\x00\x0f\x00\x00\x00\x00\x02\x00\x00\x01\x00\x01\xc0");
+    add_dtb_prop(child, "bridge-settings-6", 128, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x01\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x80\x00\x40\x00\x10\x07\x00\x00\x80\x00\x40\x00\x14\x07\x00\x00\x80\x00\x40\x00\x18\x07\x00\x00\x80\x00\x40\x00\x1c\x07\x00\x00\x10\x00\x10\x00\x44\x07\x00\x00\x12\x00\x29\x00\x48\x07\x00\x00\x0a\x00\x40\x00\x4c\x07\x00\x00\x0a\x00\x40\x00\x50\x07\x00\x00\x0a\x00\x40\x00\x54\x07\x00\x00\x0a\x00\x40\x00\x58\x07\x00\x00\x10\x00\x40\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-1", 128, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x01\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x80\x00\x40\x00\x10\x07\x00\x00\x80\x00\x40\x00\x14\x07\x00\x00\x80\x00\x40\x00\x18\x07\x00\x00\x80\x00\x40\x00\x1c\x07\x00\x00\x10\x00\x40\x00\x44\x07\x00\x00\x00\x00\x00\x02\x48\x07\x00\x00\x80\x00\x40\x00\x4c\x07\x00\x00\x80\x00\x40\x00\x50\x07\x00\x00\x80\x00\x40\x00\x54\x07\x00\x00\x80\x00\x40\x00\x58\x07\x00\x00\x10\x00\x40\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-0", 128, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x01\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x80\x00\x40\x00\x10\x07\x00\x00\x80\x00\x40\x00\x14\x07\x00\x00\x80\x00\x40\x00\x18\x07\x00\x00\x80\x00\x40\x00\x1c\x07\x00\x00\x10\x00\x20\x00\x44\x07\x00\x00\x00\x00\x00\x02\x48\x07\x00\x00\x80\x00\x40\x00\x4c\x07\x00\x00\x80\x00\x40\x00\x50\x07\x00\x00\x80\x00\x40\x00\x54\x07\x00\x00\x80\x00\x40\x00\x58\x07\x00\x00\x10\x00\x40\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-8", 128, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x01\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x80\x00\x40\x00\x10\x07\x00\x00\x80\x00\x40\x00\x14\x07\x00\x00\x80\x00\x40\x00\x18\x07\x00\x00\x80\x00\x40\x00\x1c\x07\x00\x00\x20\x00\x20\x00\x44\x07\x00\x00\x00\x00\x00\x02\x48\x07\x00\x00\x80\x00\x40\x00\x4c\x07\x00\x00\x80\x00\x40\x00\x50\x07\x00\x00\x80\x00\x40\x00\x54\x07\x00\x00\x80\x00\x40\x00\x58\x07\x00\x00\x10\x00\x80\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-7", 80, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x01\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x80\x00\x40\x00\x10\x07\x00\x00\x80\x00\x40\x00\x14\x07\x00\x00\x80\x00\x40\x00\x18\x07\x00\x00\x80\x00\x40\x00\x1c\x07\x00\x00\x10\x00\x10\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-5", 176, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x00\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x13\x00\xc7\x00\x10\x07\x00\x00\x13\x00\xc7\x00\x14\x07\x00\x00\x13\x00\xc7\x00\x18\x07\x00\x00\x13\x00\xc7\x00\x1c\x07\x00\x00\x10\x00\x20\x00\x44\x07\x00\x00\x00\x00\x00\x02\x48\x07\x00\x00\x80\x00\x40\x00\x4c\x07\x00\x00\x80\x00\x40\x00\x50\x07\x00\x00\x80\x00\x40\x00\x54\x07\x00\x00\x80\x00\x40\x00\x58\x07\x00\x00\x10\x00\x40\x00\x80\x07\x00\x00\x12\x00\x29\x00\x84\x07\x00\x00\x0a\x00\x40\x00\x88\x07\x00\x00\x0a\x00\x40\x00\x8c\x07\x00\x00\x0a\x00\x40\x00\x90\x07\x00\x00\x0a\x00\x40\x00\x94\x07\x00\x00\x10\x00\x30\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-2", 128, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x01\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x80\x00\x40\x00\x10\x07\x00\x00\x80\x00\x40\x00\x14\x07\x00\x00\x80\x00\x40\x00\x18\x07\x00\x00\x80\x00\x40\x00\x1c\x07\x00\x00\x10\x00\x10\x00\x44\x07\x00\x00\x00\x00\x00\x02\x48\x07\x00\x00\x80\x00\x40\x00\x4c\x07\x00\x00\x80\x00\x40\x00\x50\x07\x00\x00\x80\x00\x40\x00\x54\x07\x00\x00\x80\x00\x40\x00\x58\x07\x00\x00\x10\x00\x39\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-3", 128, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x01\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x80\x00\x40\x00\x10\x07\x00\x00\x80\x00\x40\x00\x14\x07\x00\x00\x80\x00\x40\x00\x18\x07\x00\x00\x80\x00\x40\x00\x1c\x07\x00\x00\x10\x00\x30\x00\x44\x07\x00\x00\x00\x00\x00\x02\x48\x07\x00\x00\x80\x00\x40\x00\x4c\x07\x00\x00\x80\x00\x40\x00\x50\x07\x00\x00\x80\x00\x40\x00\x54\x07\x00\x00\x80\x00\x40\x00\x58\x07\x00\x00\x10\x00\x37\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "bridge-settings-4", 128, (uint8_t*)"\x00\x00\x00\x00\x10\x04\x00\x00\x00\x04\x00\x00\x01\x00\x00\x40\x00\x06\x00\x00\xff\xff\xff\x01\x08\x07\x00\x00\x00\x00\x00\x02\x0c\x07\x00\x00\x10\x00\xa6\x00\x10\x07\x00\x00\x10\x00\xa6\x00\x14\x07\x00\x00\x10\x00\xa6\x00\x18\x07\x00\x00\x10\x00\xa6\x00\x1c\x07\x00\x00\x10\x00\x10\x00\x44\x07\x00\x00\x00\x00\x00\x02\x48\x07\x00\x00\x80\x00\x40\x00\x4c\x07\x00\x00\x80\x00\x40\x00\x50\x07\x00\x00\x80\x00\x40\x00\x54\x07\x00\x00\x80\x00\x40\x00\x58\x07\x00\x00\x10\x00\x80\x00\x00\x08\x00\x00\x01\x01\x00\x00");
+    add_dtb_prop(child, "voltage-states5-sram", 64, (uint8_t*)"\x00\xbf\x2f\x20\xf1\x02\x00\x00\x00\x04\x5c\x36\xf1\x02\x00\x00\x00\x64\x3f\x4d\xf1\x02\x00\x00\x00\x59\xdd\x6e\x20\x03\x00\x00\x00\x32\x2d\x82\x87\x03\x00\x00\x00\x18\x0d\x8f\xe8\x03\x00\x00\x00\xc8\x7e\x9a\x48\x04\x00\x00\x00\x6a\xc9\x9e\x65\x04\x00\x00");
+    add_dtb_prop(child, "voltage-states1-sram", 40, (uint8_t*)"\x00\x10\x55\x22\xf1\x02\x00\x00\x00\x98\x7f\x33\xf1\x02\x00\x00\x00\x20\xaa\x44\xf1\x02\x00\x00\x00\xa8\xd4\x55\x42\x03\x00\x00\x00\x30\xff\x66\xaf\x03\x00\x00");
+    add_dtb_prop(child, "voltage-states9-sram", 56, (uint8_t*)"\x00\x00\x00\x00\xf1\x02\x00\x00\x00\x2a\x75\x15\xf1\x02\x00\x00\xc0\x4f\xef\x1e\xf1\x02\x00\x00\x00\xcd\x56\x27\xf1\x02\x00\x00\x00\x11\xec\x2f\xf1\x02\x00\x00\x00\x55\x81\x38\x16\x03\x00\x00\x80\xfe\x2a\x47\x96\x03\x00\x00");
+}
+
+static void T8030_sart_setup(MachineState* machine)
+{
+    uint64_t *reg;
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    DTBNode *child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+    DTBProp *prop;
+    MemoryRegion *sart;
+
+    assert(child != NULL);
+    child = get_dtb_child_node_by_name(child, "sart-ans");
+    assert(child != NULL);
+
+    prop = get_dtb_prop(child, "reg");
+    assert(prop);
+    reg = (uint64_t*)prop->value;
+
+    sart = g_new(MemoryRegion, 1);
+    memory_region_init_io(sart, OBJECT(machine), &sart_reg_ops, tms, "sart-reg", reg[1]);
+    memory_region_add_subregion(tms->sysmem, tms->soc_base_pa + reg[0], sart);
+}
+
+static void T8030_create_ans(MachineState* machine)
+{
+    int i;
+    uint32_t *ints;
+    DTBProp *prop;
+    uint64_t *reg;
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    DTBNode *child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+
+    assert(child != NULL);
+    child = get_dtb_child_node_by_name(child, "ans");
+    assert(child != NULL);
+
+    tms->ans = apple_ans_create(child);
+    assert(tms->ans);
+
+    object_property_add_child(OBJECT(machine), "ans", OBJECT(tms->ans));
+    prop = get_dtb_prop(child, "reg");
+    assert(prop);
+    reg = (uint64_t*)prop->value;
+
+    /*
+    0: AppleA7IOP akfRegMap
+    1: AppleASCWrapV2 coreRegisterMap
+    2: AppleA7IOP autoBootRegMap
+    3: NVMe BAR
+    */
+    sysbus_mmio_map(tms->ans, 0, tms->soc_base_pa + reg[0]);
+    sysbus_mmio_map(tms->ans, 1, tms->soc_base_pa + reg[2]);
+    sysbus_mmio_map(tms->ans, 2, tms->soc_base_pa + reg[4]);
+    sysbus_mmio_map(tms->ans, 3, tms->soc_base_pa + reg[6]);
+
+    prop = get_dtb_prop(child, "interrupts");
+    assert(prop);
+    assert(prop->length == 20);
+    ints = (uint32_t*)prop->value;
+
+    for(i = 0; i < prop->length / sizeof(uint32_t); i++) {
+        sysbus_connect_irq(tms->ans, i, qdev_get_gpio_in(DEVICE(tms->aic), ints[i]));
+    }
+
+    sysbus_realize(tms->ans, &error_fatal);
+}
+
+static void T8030_create_gpio(MachineState *machine, const char *name)
+{
+    DeviceState *gpio = NULL;
+    DTBProp *prop;
+    uint64_t *reg;
+    uint32_t *ints;
+    int i;
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    DTBNode *child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+
+    child = get_dtb_child_node_by_name(child, name);
+    assert(child);
+    gpio = apple_gpio_create(child);
+    assert(gpio);
+    object_property_add_child(OBJECT(machine), name, OBJECT(gpio));
+
+    prop = get_dtb_prop(child, "reg");
+    assert(prop);
+    reg = (uint64_t*)prop->value;
+    sysbus_mmio_map(SYS_BUS_DEVICE(gpio), 0, tms->soc_base_pa + reg[0]);
+    prop = get_dtb_prop(child, "interrupts");
+    assert(prop);
+
+    ints = (uint32_t*)prop->value;
+
+    for(i = 0; i < prop->length / sizeof(uint32_t); i++) {
+        sysbus_connect_irq(SYS_BUS_DEVICE(gpio), i, qdev_get_gpio_in(DEVICE(tms->aic), ints[i]));
+    }
+
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(gpio), &error_fatal);
+}
+
+static DeviceState *T8030_get_gpio_with_role(MachineState *machine, uint32_t role)
+{
+    switch (role) {
+        case 0x00005041: /* AP */
+            return DEVICE(object_property_get_link(OBJECT(machine), "gpio", &error_fatal));
+            break;
+        case 0x00434d53: /* SMC */
+            return DEVICE(object_property_get_link(OBJECT(machine), "smc-gpio", &error_fatal));
+            break;
+        case 0x0042554e: /* NUB */
+            return DEVICE(object_property_get_link(OBJECT(machine), "nub-gpio", &error_fatal));
+            break;
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR, "%s: invalid gpio role %s\n", __func__, (const char*)&role);
+    }
+    return NULL;
+}
+
+static void T8030_create_i2c(MachineState *machine, const char *name)
+{
+    uint32_t line = 0;
+    uint32_t opts = 0;
+    uint32_t role = 0;
+    DeviceState *gpio;
+    DeviceState *i2c = NULL;
+    DTBProp *prop;
+    uint64_t *reg;
+    uint32_t* ints;
+    int i;
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    DTBNode *child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+
+    child = get_dtb_child_node_by_name(child, name);
+    assert(child);
+
+    i2c = apple_i2c_create(child);
+    assert(i2c);
+    object_property_add_child(OBJECT(machine), name, OBJECT(i2c));
+
+    prop = get_dtb_prop(child, "reg");
+    assert(prop);
+
+    reg = (uint64_t*)prop->value;
+    sysbus_mmio_map(SYS_BUS_DEVICE(i2c), 0, tms->soc_base_pa + reg[0]);
+
+    prop = get_dtb_prop(child, "interrupts");
+    assert(prop);
+    ints = (uint32_t*)prop->value;
+    for(i = 0; i < prop->length / sizeof(uint32_t); i++) {
+        sysbus_connect_irq(SYS_BUS_DEVICE(i2c), i, qdev_get_gpio_in(DEVICE(tms->aic), ints[i]));
+    }
+
+    prop = get_dtb_prop(child, "gpio-iic_scl");
+    assert(prop);
+    line = ((uint32_t*)prop->value)[0];
+    opts = ((uint32_t*)prop->value)[1];
+    role = ((uint32_t*)prop->value)[2];
+
+    gpio = T8030_get_gpio_with_role(machine, role);
+    if (gpio) {
+        if (!get_dtb_prop(child, "function-iic_scl")) {
+            uint32_t func[] = {
+                APPLE_GPIO(gpio)->phandle,
+                0x4750494F, /* GPIO */
+                line,
+                opts
+            };
+            prop = add_dtb_prop(child, "function-iic_scl", sizeof(func), (uint8_t*)func);
+        }
+        qdev_connect_gpio_out(gpio, line, qdev_get_gpio_in(i2c, BITBANG_I2C_SCL));
+    }
+
+    prop = get_dtb_prop(child, "gpio-iic_sda");
+    assert(prop);
+    line = ((uint32_t*)prop->value)[0];
+    opts = ((uint32_t*)prop->value)[1];
+    role = ((uint32_t*)prop->value)[2];
+
+    gpio = T8030_get_gpio_with_role(machine, role);
+    if (gpio) {
+        if (!get_dtb_prop(child, "function-iic_sda")) {
+            uint32_t func[] = {
+                APPLE_GPIO(gpio)->phandle,
+                0x4750494F, /* GPIO */
+                line,
+                opts
+            };
+            prop = add_dtb_prop(child, "function-iic_sda", sizeof(func), (uint8_t*)func);
+        }
+        qdev_connect_gpio_out(gpio, line, qdev_get_gpio_in(i2c, BITBANG_I2C_SDA));
+        qdev_connect_gpio_out(i2c, BITBANG_I2C_SDA, qdev_get_gpio_in(gpio, line));
+    }
+
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(i2c), &error_fatal);
+}
+
+static void T8030_cpu_reset(void *opaque)
+{
+    MachineState *machine = MACHINE(opaque);
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    CPUState *cpu;
+    CPUState *cs;
+    CPUARMState *env;
+
+    CPU_FOREACH(cpu) {
+        ARM_CPU(cpu)->rvbar = tms->kpc_pa & ~0xfff;
+    }
+    
+    cs = CPU(first_cpu);
+    env = &ARM_CPU(cs)->env;
+    cpu_reset(cs);
+    env->xregs[0] = tms->kbootargs_pa;
+    env->pc = tms->kpc_pa;
+}
+
+static void T8030_cluster_tick(cluster* c)
+{
+    WITH_QEMU_LOCK_GUARD(&c->mutex) {
+        int i, j;
+
+        for(i = 0; i < MAX_CPU; i++) { /* source */
+            for(j = 0; j < MAX_CPU; j++) { /* target */
+                if (c->cpus[j] != NULL && c->deferredIPI[i][j]) {
+                    T8030_cluster_deliver_ipi(c, j, i, ARM64_REG_IPI_RR_TYPE_DEFERRED);
+                    break;
+                }
+            }
+        }
+
+        for(i = 0; i < MAX_CPU; i++) { /* source */
+            for(j = 0; j < MAX_CPU; j++) { /* target */
+                if (c->cpus[j] != NULL && c->noWakeIPI[i][j] && !T8030CPU_is_sleep(c->cpus[j])) {
+                    T8030_cluster_deliver_ipi(c, j, i, ARM64_REG_IPI_RR_TYPE_NOWAKE);
+                    break;
+                }
+            }
+        }
+    }
+}
+
+static void T8030_machine_ipicr_tick(void* opaque)
+{
+    int i;
+    T8030MachineState *tms = T8030_MACHINE((MachineState *)opaque);
+
+    for(i = 0; i < MAX_CLUSTER; i++) {
+        T8030_cluster_tick(tms->clusters[i]);
+    }
+
+    timer_mod_ns(tms->ipicr_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + tms->ipi_cr);
+}
+
+static void T8030_machine_reset(void* opaque)
+{
+    MachineState *machine = MACHINE(opaque);
+    T8030MachineState *tms = T8030_MACHINE(opaque);
+
+    tms->ipicr_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, T8030_machine_ipicr_tick, machine);
+    timer_mod_ns(tms->ipicr_timer, kDeferredIPITimerDefault);
+    T8030_memory_setup(machine);
+    T8030_cpu_reset(tms);
+}
+
+static void T8030_machine_init(MachineState *machine)
+{
+    T8030MachineState *tms = T8030_MACHINE(machine);
+    DTBNode *child;
+    DTBProp *prop;
+    hwaddr *ranges;
+
+    qemu_mutex_init(&tms->mutex);
+    tms->sysmem = get_system_memory();
+    
+    tms->device_tree = load_dtb_from_file(tms->dtb_filename);
+    child = get_dtb_child_node_by_name(tms->device_tree, "arm-io");
+    assert(child != NULL);
+
+    prop = get_dtb_prop(child, "ranges");
+    assert(prop != NULL);
+
+    ranges = (hwaddr *)prop->value;
+    tms->soc_base_pa = ranges[1];
+    tms->soc_size = ranges[2];
+
+    T8030_cpu_setup(machine);
+
+    tms->ipi_cr = kDeferredIPITimerDefault;
+
+    T8030_create_aic(machine);
+    
+    T8030_create_s3c_uart(tms, serial_hd(0));
+
+    T8030_pmgr_setup(machine);
+
+    T8030_sart_setup(machine);
+
+    T8030_create_ans(machine);
+
+    T8030_create_gpio(machine, "gpio");
+    T8030_create_gpio(machine, "smc-gpio");
+    T8030_create_gpio(machine, "nub-gpio");
+    
+    T8030_create_i2c(machine, "i2c0");
+    T8030_create_i2c(machine, "i2c1");
+    T8030_create_i2c(machine, "i2c2");
+    T8030_create_i2c(machine, "i2c3");
+    T8030_create_i2c(machine, "smc-i2c0");
+    T8030_create_i2c(machine, "smc-i2c1");
+
+    T8030_bootargs_setup(machine);
+
+    qemu_register_reset(T8030_machine_reset, tms);
+}
+
+static void T8030_set_ramdisk_filename(Object *obj, const char *value, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    g_strlcpy(tms->ramdisk_filename, value, sizeof(tms->ramdisk_filename));
+}
+
+static char *T8030_get_ramdisk_filename(Object *obj, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+    return g_strdup(tms->ramdisk_filename);
+}
+
+static void T8030_set_kernel_filename(Object *obj, const char *value, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    g_strlcpy(tms->kernel_filename, value, sizeof(tms->kernel_filename));
+}
+
+static char *T8030_get_kernel_filename(Object *obj, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+    return g_strdup(tms->kernel_filename);
+}
+
+static void T8030_set_dtb_filename(Object *obj, const char *value, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    g_strlcpy(tms->dtb_filename, value, sizeof(tms->dtb_filename));
+}
+
+static char *T8030_get_dtb_filename(Object *obj, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+    return g_strdup(tms->dtb_filename);
+}
+
+static void T8030_set_trustcache_filename(Object *obj, const char *value, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    g_strlcpy(tms->trustcache_filename, value, sizeof(tms->trustcache_filename));
+}
+
+static char *T8030_get_trustcache_filename(Object *obj, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    return g_strdup(tms->trustcache_filename);
+}
+
+static void T8030_set_kern_args(Object *obj, const char *value, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    g_strlcpy(tms->kern_args, value, sizeof(tms->kern_args));
+}
+
+static char *T8030_get_kern_args(Object *obj, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    return g_strdup(tms->kern_args);
+}
+
+static void T8030_set_xnu_ramfb(Object *obj, const char *value, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    if (strcmp(value, "on") == 0)
+        tms->use_ramfb = true;
+    else {
+        if (strcmp(value, "off") != 0)
+            fprintf(stderr, "NOTE: the value of xnu-ramfb is not valid,\
+                            the framebuffer will be disabled.\n");
+        tms->use_ramfb = false;
+    }
+}
+
+static char *T8030_get_xnu_ramfb(Object *obj, Error **errp)
+{
+    T8030MachineState *tms = T8030_MACHINE(obj);
+
+    if (tms->use_ramfb)
+        return g_strdup("on");
+    else
+        return g_strdup("off");
+}
+
+static void T8030_instance_init(Object *obj)
+{
+    object_property_add_str(obj, "ramdisk-filename", T8030_get_ramdisk_filename,
+                            T8030_set_ramdisk_filename);
+    object_property_set_description(obj, "ramdisk-filename",
+                                    "Set the ramdisk filename to be loaded");
+
+    object_property_add_str(obj, "kernel-filename", T8030_get_kernel_filename,
+                            T8030_set_kernel_filename);
+    object_property_set_description(obj, "kernel-filename",
+                                    "Set the kernel filename to be loaded");
+
+    object_property_add_str(obj, "dtb-filename", T8030_get_dtb_filename, T8030_set_dtb_filename);
+    object_property_set_description(obj, "dtb-filename",
+                                    "Set the dev tree filename to be loaded");
+
+    object_property_add_str(obj, "trustcache-filename", T8030_get_trustcache_filename, T8030_set_trustcache_filename);
+    object_property_set_description(obj, "trustcache-filename",
+                                    "Set the trustcache filename to be loaded");
+
+    object_property_add_str(obj, "kern-cmd-args", T8030_get_kern_args,
+                            T8030_set_kern_args);
+    object_property_set_description(obj, "kern-cmd-args",
+                                    "Set the XNU kernel cmd args");
+
+    object_property_add_str(obj, "xnu-ramfb",
+                            T8030_get_xnu_ramfb,
+                            T8030_set_xnu_ramfb);
+
+    object_property_set_description(obj, "xnu-ramfb",
+                                    "Turn on the display framebuffer");
+}
+
+static void T8030_machine_class_init(ObjectClass *klass, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(klass);
+
+    mc->desc = "T8030";
+    mc->init = T8030_machine_init;
+    mc->max_cpus = MAX_CPU;
+    // this disables the error message "Failed to query for block devices!"
+    // when starting qemu - must keep at least one device
+    mc->no_sdcard = 1;
+    mc->no_floppy = 1;
+    mc->no_cdrom = 1;
+    mc->no_parallel = 1;
+    mc->default_cpu_type = ARM_CPU_TYPE_NAME("cortex-a72");
+    mc->minimum_page_bits = 12;
+}
+
+static const TypeInfo T8030_machine_info = {
+    .name = TYPE_T8030_MACHINE,
+    .parent = TYPE_MACHINE,
+    .instance_size = sizeof(T8030MachineState),
+    .class_size = sizeof(T8030MachineClass),
+    .class_init = T8030_machine_class_init,
+    .instance_init = T8030_instance_init,
+};
+
+static void T8030_machine_types(void)
+{
+    type_register_static(&T8030_machine_info);
+}
+
+type_init(T8030_machine_types)
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/xnu.c qemu-t8030-private/hw/arm/xnu.c
--- qemu-6.0.0/hw/arm/xnu.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/xnu.c	2021-05-05 23:07:27.950351300 +0800
@@ -0,0 +1,751 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ * Copyright (c) 2021 Nguyen Hoang Trung (TrungNguyen1909)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "sysemu/sysemu.h"
+#include "qemu/error-report.h"
+#include "hw/arm/xnu.h"
+#include "hw/loader.h"
+#include "img4.h"
+#include "lzfse.h"
+
+const char *KEEP_COMP[] = {"uart-1,samsung\0$",
+                           "N104AP\0iPhone12,1\0AppleARM\0$", "arm-io,t8030\0$",
+                           "apple,thunder\0ARM,v8\0$", "aic,1\0$", "pmgr1,t8030\0$",
+                           "sart,t8030\0$", "iop,ascwrap-v2\0$", "iop-nub,rtbuddy-v2\0$",
+                           "aes,s8000\0$",
+                           "gpio,t8030\0gpio,s5l8960x\0$",
+                           "gpio,t8015\0gpio,s5l8960x\0$",
+                           "iic,soft\0$",
+                           "dock,9pin\0$",
+                           "otgphyctrl,s8000\0otgphyctrl,s5l8960x\0$",
+                           "usb-complex,s8000\0usb-complex,s5l8960x\0$",
+                           "usb-device,s8000\0usb-device,t7000\0usb-device,s5l8900x\0$"};
+
+const char *REM_NAMES[] = {"backlight\0$",
+                            "dockchannel-uart\0$",
+                            "sep\0$", "pmp\0$",
+                            "aop-gpio\0$",
+                            "atc-phy\0$", "usb-drd\0$"};
+
+const char *REM_DEV_TYPES[] = {"backlight\0$", "pmp\0$"};
+
+const char *REM_PROPS[] = {"function-error_handler", "nvme-coastguard", "nand-debug",
+                            "function-spi0_sclk_config", "function-spi0_mosi_config",
+                            "function-pmp_control"};
+//TODO: error_handler probably needs arm-io to initialize properly
+
+static void allocate_and_copy(MemoryRegion *mem, AddressSpace *as,
+                              const char *name, hwaddr pa, hwaddr size,
+                              void *buf)
+{
+    uint64_t memsize = size;
+    if (size > 0 && size < 0x4000) {
+        memsize = 0x4000;
+    }
+    if (mem) {
+        allocate_ram(mem, name, pa, memsize);
+    }
+    address_space_rw(as, pa, MEMTXATTRS_UNSPECIFIED, (uint8_t *)buf, size, 1);
+}
+
+static void *srawmemchr(void *str, int chr)
+{
+    uint8_t *ptr = (uint8_t *)str;
+    while (*ptr != chr) {
+        ptr++;
+    }
+    return ptr;
+}
+
+static uint64_t sstrlen(const char *str)
+{
+    const int chr = *(uint8_t *)"$";
+    char *end = srawmemchr((void *)str, chr);
+    return (end - str);
+}
+
+static void macho_dtb_node_process(DTBNode *node, DTBNode *parent)
+{
+    GList *iter = NULL;
+    DTBNode *child = NULL;
+    DTBProp *prop = NULL;
+    uint64_t i = 0;
+
+    // prop = get_dtb_prop(node, "interrupt-parent");
+    // if(prop != NULL){
+    //     if(*(uint32_t*)prop->value == 0x1a){ /* aic */
+    //         prop = get_dtb_prop(node, "name");
+    //         fprintf(stderr, "Found device: %s with AIC as interrupt-parent\n", prop->value);
+    //         fprintf(stderr, "\tinterrupts: ");
+    //         prop = get_dtb_prop(node, "interrupts");
+    //         uint32_t* interrupts = prop->value;
+    //         for(int i=0;i<prop->length / sizeof(uint32_t);i++){
+    //             fprintf(stderr, "0x%x ", interrupts[i]);
+    //         }
+    //         fprintf(stderr, "\n");
+    //     }
+    // }
+
+    //remove by compatible property
+    prop = get_dtb_prop(node, "compatible");
+    if (NULL != prop) {
+        uint64_t count = sizeof(KEEP_COMP) / sizeof(KEEP_COMP[0]);
+        bool found = false;
+        for (i = 0; i < count; i++) {
+            uint64_t size = MIN(prop->length, sstrlen(KEEP_COMP[i]));
+            if (0 == memcmp(prop->value, KEEP_COMP[i], size)) {
+                found = true;
+                break;
+            }
+        }
+        if (!found) {
+            if (parent) {
+                remove_dtb_node(parent, node);
+                return;
+            }
+        }
+    }
+
+    //remove by name property
+    prop = get_dtb_prop(node, "name");
+    if (NULL != prop) {
+        uint64_t count = sizeof(REM_NAMES) / sizeof(REM_NAMES[0]);
+        for (i = 0; i < count; i++) {
+            uint64_t size = MIN(prop->length, sstrlen(REM_NAMES[i]));
+            if (0 == memcmp(prop->value, REM_NAMES[i], size)) {
+                if (parent) {
+                    remove_dtb_node(parent, node);
+                    return;
+                }
+                break;
+            }
+        }
+    }
+
+    //remove dev type properties
+    prop = get_dtb_prop(node, "device_type");
+    if (NULL != prop) {
+        uint64_t count = sizeof(REM_DEV_TYPES) / sizeof(REM_DEV_TYPES[0]);
+        for (i = 0; i < count; i++) {
+            uint64_t size = MIN(prop->length, sstrlen(REM_DEV_TYPES[i]));
+            if (0 == memcmp(prop->value, REM_DEV_TYPES[i], size)) {
+                //TODO: maybe remove the whole node and sub nodes?
+                overwrite_dtb_prop_val(prop, *(uint8_t *)"~");
+                break;
+            }
+        }
+    }
+    {
+        uint64_t count = sizeof(REM_PROPS) / sizeof(REM_PROPS[0]);
+        for (i = 0; i < count; i++) {
+            prop = get_dtb_prop(node, REM_PROPS[i]);
+            if(prop!=NULL){
+                remove_dtb_prop(node, prop);
+            }
+        }
+    }
+    int cnt = node->child_node_count;
+    for (iter = node->child_nodes; iter != NULL;) {
+        child = (DTBNode *)iter->data;
+        //iter might be invalidated by macho_dtb_node_process
+        iter = iter->next;
+        macho_dtb_node_process(child, node);
+        cnt--;
+    }
+    assert(cnt == 0);
+}
+
+// Extracts the payload from an im4p file. If the file is not an im4p file,
+// the raw file contents are returned. Exits if an error occurs.
+// See https://www.theiphonewiki.com/wiki/IMG4_File_Format for an overview
+// of the file format.
+static void extract_im4p_payload(const char* filename, char* payload_type /* must be at least 4 bytes long */, uint8_t **data, uint32_t* length) {
+    uint8_t *file_data = NULL;
+    unsigned long fsize;
+
+    char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];
+    asn1_node img4_definitions = ASN1_TYPE_EMPTY;
+    asn1_node img4;
+    int ret;
+
+    if (!g_file_get_contents(filename, (char **)&file_data, &fsize, NULL)) {
+        error_report("Could not load data from file '%s'", filename);
+        exit(EXIT_FAILURE);
+    }
+
+    if (asn1_array2tree(img4_definitions_array, &img4_definitions, errorDescription)) {
+        error_report("Could not initialize the ASN.1 parser: %s.", errorDescription);
+        exit(EXIT_FAILURE);
+    }
+
+    if ((ret = asn1_create_element(img4_definitions, "Img4.Img4Payload", &img4) != ASN1_SUCCESS)) {
+        error_report("Could not create an Img4Payload element: %d", ret);
+        exit(EXIT_FAILURE);
+    }
+
+    if ((ret = asn1_der_decoding(&img4, (const uint8_t*)file_data, (uint32_t)fsize, errorDescription)) == ASN1_SUCCESS) {
+        char magic[4];
+        char description[128];
+        int len;
+
+        len = 4;
+        if ((ret = asn1_read_value(img4, "magic", magic, &len)) != ASN1_SUCCESS) {
+            error_report("Failed to read the im4p magic in file '%s': %d.", filename, ret);
+            exit(EXIT_FAILURE);
+        }
+
+        if (strncmp(magic, "IM4P", 4) != 0) {
+            error_report("Couldn't parse ASN.1 data in file '%s' because it does not start with the IM4P header.", filename);
+            exit(EXIT_FAILURE);
+        }
+
+        len = 4;
+        if ((ret = asn1_read_value(img4, "type", payload_type, &len)) != ASN1_SUCCESS) {
+            error_report("Failed to read the im4p type in file '%s': %d.", filename, ret);
+            exit(EXIT_FAILURE);
+        }
+
+        len = 128;
+        if ((ret = asn1_read_value(img4, "description", description, &len)) != ASN1_SUCCESS) {
+            error_report("Failed to read the im4p description in file '%s': %d.", filename, ret);
+            exit(EXIT_FAILURE);
+        }
+
+        uint8_t *payload_data = NULL;
+        len = 0;
+
+        if ((ret = asn1_read_value(img4, "data", payload_data, &len) != ASN1_MEM_ERROR)) {
+            error_report("Failed to read the im4p payload in file '%s': %d.", filename, ret);
+            exit(EXIT_FAILURE);
+        }
+
+        payload_data = g_malloc0(len);
+
+        if ((ret = asn1_read_value(img4, "data", payload_data, &len) != ASN1_SUCCESS)) {
+            error_report("Failed to read the im4p payload in file '%s': %d.", filename, ret);
+            exit(EXIT_FAILURE);
+        }
+
+        // Determine whether the payload is LZFSE-compressed: LZFSE-compressed files contains various buffer blocks,
+        // and each buffer block starts with bvx? magic, where ? is -, 1, 2 or n.
+        // See https://github.com/lzfse/lzfse/blob/e634ca58b4821d9f3d560cdc6df5dec02ffc93fd/src/lzfse_internal.h
+        // for the details
+        if (payload_data[0] == (uint8_t)'b' && payload_data[1] == (uint8_t)'v' && payload_data[2] == (uint8_t)'x') {
+            size_t decode_buffer_size = len * 8;
+            uint8_t* decode_buffer = g_malloc0(decode_buffer_size);
+
+            int decoded_length = lzfse_decode_buffer(decode_buffer, decode_buffer_size, payload_data, len, NULL /* scratch_buffer */);
+            
+            if (decoded_length == 0 || decoded_length == decode_buffer_size) {
+                error_report("Could not decompress LZFSE-compressed data in file '%s' because the decode buffer was too small.", filename);
+                exit(EXIT_FAILURE);
+            }
+
+            *data = decode_buffer;
+            *length = decoded_length;
+
+            g_free(payload_data);
+            g_free(file_data);
+        } else {
+            *data = payload_data;
+            *length = len;
+
+            g_free(file_data);
+        }
+    }
+    else
+    {
+        *data = file_data;
+        *length = (uint32_t)fsize;
+        strncpy(payload_type, "raw", 4);
+    }
+}
+
+DTBNode* load_dtb_from_file(char *filename) {
+    DTBNode *root = NULL;
+    uint8_t *file_data = NULL;
+    uint32_t fsize;
+    char payload_type[4];
+
+    extract_im4p_payload(filename, payload_type, &file_data, &fsize);
+
+    if (strncmp(payload_type, "dtre", 4) != 0
+        && strncmp(payload_type, "raw", 4) != 0) {
+        error_report("Couldn't parse ASN.1 data in file '%s' because it is not a 'dtre' object, found '%.4s' object.", filename, payload_type);
+        exit(EXIT_FAILURE);
+    }
+
+    root = load_dtb(file_data);
+    g_free(file_data);
+
+    return root;
+}
+
+void macho_load_dtb(DTBNode* root, AddressSpace *as, MemoryRegion *mem,
+                    const char *name, hwaddr dtb_pa, uint64_t *size,
+                    hwaddr ramdisk_addr, hwaddr ramdisk_size,
+                    hwaddr trustcache_addr, hwaddr trustcache_size,
+                    hwaddr bootargs_addr,
+                    hwaddr dram_base, unsigned long dram_size,
+                    void* nvram_data, unsigned long nvram_size)
+{
+    DTBNode* child = NULL;
+    DTBProp* prop = NULL;
+
+    //remove this prop as it is responsible for the waited for event
+    //in PE that never happens
+    prop = get_dtb_prop(root, "secure-root-prefix");
+    if (NULL == prop) {
+        abort();
+    }
+    remove_dtb_prop(root, prop);
+
+    //need to set the random seed insread of iboot
+    uint64_t seed[8] = {0xdead000d, 0xdead000d, 0xdead000d, 0xdead000d,
+                        0xdead000d, 0xdead000d, 0xdead000d, 0xdead000d};
+    child = get_dtb_child_node_by_name(root, "chosen");
+    assert(child != NULL);
+    prop = get_dtb_prop(child, "random-seed");
+    assert(prop != NULL);
+    remove_dtb_prop(child, prop);
+    add_dtb_prop(child, "random-seed", sizeof(seed), (uint8_t *)&seed[0]);
+
+    add_dtb_prop(child, "dram-base", sizeof(dram_base), (uint8_t*)&dram_base);
+    add_dtb_prop(child, "dram-size", sizeof(dram_base), (uint8_t*)&dram_size);
+    // prop = get_dtb_prop(child, "debug-enabled");
+    // *(uint32_t*)prop->value = 1;
+    prop = get_dtb_prop(child, "firmware-version");
+    remove_dtb_prop(child, prop);
+    add_dtb_prop(child, "firmware-version", 11, (uint8_t*)"qemu-t8030");
+    prop = get_dtb_prop(child, "nvram-total-size");
+    remove_dtb_prop(child, prop);
+    if(nvram_size > 0xFFFF * 0x10){
+        nvram_size = 0xFFFF * 0x10;
+    }
+    uint32_t nvram_total_size = nvram_size;
+    add_dtb_prop(child, "nvram-total-size", 4, (uint8_t*)&nvram_total_size);
+    prop = get_dtb_prop(child, "nvram-proxy-data");
+    remove_dtb_prop(child, prop);
+    add_dtb_prop(child, "nvram-proxy-data", nvram_size, (uint8_t*)nvram_data);
+
+    uint32_t data = 1;
+    add_dtb_prop(child, "research-enabled", sizeof(data), (uint8_t *)&data);
+    prop = get_dtb_prop(child, "effective-production-status-ap");
+    if(prop != NULL){
+        //disable coresight
+        *(uint32_t*)prop->value = 1;
+    }
+    //update the display parameters
+    uint32_t display_rotation = 0;
+    prop = get_dtb_prop(child, "display-rotation");
+    assert(prop != NULL);
+    remove_dtb_prop(child, prop);
+    add_dtb_prop(child, "display-rotation", sizeof(display_rotation),
+                    (uint8_t *)&display_rotation);
+    uint32_t display_scale = 1;
+    prop = get_dtb_prop(child, "display-scale");
+    assert(prop != NULL);
+    remove_dtb_prop(child, prop);
+    add_dtb_prop(child, "display-scale", sizeof(display_scale),
+                    (uint8_t *)&display_scale);
+
+    //these are needed by the image4 parser module$
+    add_dtb_prop(child, "security-domain", sizeof(data), (uint8_t *)&data);
+    add_dtb_prop(child, "chip-epoch", sizeof(data), (uint8_t *)&data);
+    data = 0xffffffff;
+    add_dtb_prop(child, "debug-enabled", sizeof(data), (uint8_t *)&data);
+    prop = get_dtb_prop(child, "amfi-allows-trust-cache-load");
+    assert(prop->length == 4);
+    *(uint32_t*)prop->value = 1;
+    child = get_dtb_child_node_by_name(child, "memory-map");
+    assert(child != NULL);
+
+    uint64_t memmap[2] = {0};
+
+    if ((0 != ramdisk_addr) && (0 != ramdisk_size)) {
+        memmap[0] = ramdisk_addr;
+        memmap[1] = ramdisk_size;
+        add_dtb_prop(child, "RAMDisk", sizeof(memmap),
+                        (uint8_t *)&memmap[0]);
+    }
+    if ((0 != trustcache_addr) && (0 != trustcache_size)) {
+        memmap[0] = trustcache_addr;
+        memmap[1] = trustcache_size;
+        add_dtb_prop(child, "TrustCache", sizeof(memmap),
+                        (uint8_t *)&memmap[0]);
+    }
+    memmap[0] = bootargs_addr;
+    memmap[1] = sizeof(struct xnu_arm64_boot_args);
+    add_dtb_prop(child, "BootArgs", sizeof(memmap), (uint8_t *)&memmap[0]);
+    add_dtb_prop(child, "DeviceTree", sizeof(memmap), (uint8_t *)&memmap[0]);
+    
+    child = get_dtb_child_node_by_name(root, "chosen");
+    assert(child);
+    child = get_dtb_child_node_by_name(child, "lock-regs");
+    assert(child);
+    child = get_dtb_child_node_by_name(child, "amcc");
+    assert(child);
+    data = 0;
+    add_dtb_prop(child, "aperture-count", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "aperture-size", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "plane-count", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "aperture-phys-addr", 0, (uint8_t*)&data);
+    add_dtb_prop(child, "cache-status-reg-offset", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "cache-status-reg-mask", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "cache-status-reg-value", 4, (uint8_t*)&data);
+    add_dtb_node(child, "amcc-ctrr-a");
+    child = get_dtb_child_node_by_name(child, "amcc-ctrr-a");
+    data = 14;
+    add_dtb_prop(child, "page-size-shift", 4, (uint8_t*)&data);
+    data = 0;
+    add_dtb_prop(child, "lower-limit-reg-offset", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "lower-limit-reg-mask", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "upper-limit-reg-offset", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "upper-limit-reg-mask", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "lock-reg-offset", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "lock-reg-mask", 4, (uint8_t*)&data);
+    add_dtb_prop(child, "lock-reg-value", 4, (uint8_t*)&data);
+    
+    child = get_dtb_child_node_by_name(root, "defaults");
+    assert(child);
+    prop = get_dtb_prop(child, "aes-service-publish-timeout");
+    assert(prop);
+    *(uint32_t*)prop->value = 0xffffffff;
+    child = get_dtb_child_node_by_name(root, "product");
+    assert(child);
+    data = 1;
+    // TODO: Workaround: AppleKeyStore SEP(?)
+    add_dtb_prop(child, "boot-ios-diagnostics", sizeof(data), (uint8_t*)&data);
+    macho_dtb_node_process(root, NULL);
+
+    uint64_t size_n = get_dtb_node_buffer_size(root);
+    child = get_dtb_child_node_by_name(root, "chosen");
+    child = get_dtb_child_node_by_name(child, "memory-map");
+    prop = get_dtb_prop(child, "DeviceTree");
+    ((uint64_t*)prop->value)[0] = dtb_pa;
+    ((uint64_t*)prop->value)[1] = size_n;
+
+    uint8_t *buf = g_malloc0(size_n);
+    save_dtb(buf, root);
+    allocate_and_copy(mem, as, name, dtb_pa, size_n, buf);
+    g_free(buf);
+    *size = size_n;
+}
+
+void macho_load_trustcache(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                            hwaddr pa, uint64_t *size) {
+    uint32_t* trustcache_data = NULL;
+    uint64_t trustcache_size = 0;
+    uint8_t* file_data = NULL;
+    unsigned long file_size = 0;
+    uint32_t length = 0;
+    char payload_type[4];
+
+    extract_im4p_payload(filename, payload_type, &file_data, &length);
+
+    if (strncmp(payload_type, "trst", 4) != 0
+        && strncmp(payload_type, "rtsc", 4) != 0 
+        && strncmp(payload_type, "raw", 4) != 0) {
+        error_report("Couldn't parse ASN.1 data in file '%s' because it is not a 'trst' or 'rtsc' object, found '%.4s' object.", filename, payload_type);
+        exit(EXIT_FAILURE);
+    }
+
+    file_size = (unsigned long)length;
+
+    trustcache_size = file_size + 8;
+    trustcache_data = (uint32_t*)g_malloc(trustcache_size);
+    trustcache_data[0] = 1; //#trustcaches
+    trustcache_data[1] = 8; //offset
+    memcpy(&trustcache_data[2], file_data, file_size);
+
+    // Validate the trustcache v1 header. The layout is:
+    // uint32_t version
+    // uuid (16 bytes)
+    // uint32_t entry_count
+    //
+    // The cache is then followed by entry_count entries, each of which
+    // contains a 20 byte hash and 2 additional bytes (hence is 22 bytes long)
+    uint32_t trustcache_version = trustcache_data[2];
+    uint32_t trustcache_entry_count = trustcache_data[7];
+    uint32_t expected_file_size = 24 /* header size */ + trustcache_entry_count * 22 /* entry size */;
+
+    if (trustcache_version != 1) {
+        error_report("The trust cache '%s' does not have a v1 header", filename);
+        exit(EXIT_FAILURE);
+    }
+
+    if (file_size != expected_file_size) {
+        error_report("The expected size %d of trust cache '%s' does not match the actual size %ld", expected_file_size, filename, file_size);
+        exit(EXIT_FAILURE);
+    }
+
+    allocate_and_copy(mem, as, "TrustCache", pa, trustcache_size, trustcache_data);
+    *size = trustcache_size;
+    g_free(file_data);
+    g_free(trustcache_data);
+}
+
+void macho_load_ramdisk(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                            hwaddr pa, uint64_t *size) {
+    uint8_t* file_data = NULL;
+    unsigned long file_size = 0;
+    uint32_t length = 0;
+    char payload_type[4];
+
+    extract_im4p_payload(filename, payload_type, &file_data, &length);
+    if (strncmp(payload_type, "rdsk", 4) != 0
+        && strncmp(payload_type, "raw", 4) != 0) {
+        error_report("Couldn't parse ASN.1 data in file '%s' because it is not a 'rdsk' object, found '%.4s' object.", filename, payload_type);
+        exit(EXIT_FAILURE);
+    }
+    file_size = align_64k_high(length);
+    file_data = g_realloc(file_data, file_size);
+
+    allocate_and_copy(mem, as, "RamDisk", pa, file_size, file_data);
+    *size = file_size;
+    g_free(file_data);
+}
+
+void macho_map_raw_file(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                        const char *name, hwaddr file_pa, uint64_t *size)
+{
+    Error *err = NULL;
+    MemoryRegion *mr = NULL;
+    struct stat file_info;
+
+    if (stat(filename, &file_info)) {
+        fprintf(stderr, "Couldn't get file size for mmapping. Loading into RAM.\n");
+        goto load_fallback;
+    }
+
+    mr = g_new(MemoryRegion, 1);
+    *size = file_info.st_size;
+
+    memory_region_init_ram_from_file(mr, NULL, name, *size & (~0xffffUL), 0, 0, filename, false, &err);
+    if (err) {
+        error_report_err(err);
+        fprintf(stderr, "Couldn't mmap file. Loading into RAM.\n");
+        goto load_fallback;
+    }
+    memory_region_add_subregion(mem, file_pa, mr);
+    return;
+
+load_fallback:
+    if (mr) {
+        g_free(mr);
+    }
+    macho_load_raw_file(filename, as, mem, name, file_pa, size);
+}
+
+void macho_load_raw_file(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                         const char *name, hwaddr file_pa, uint64_t *size)
+{
+    uint8_t* file_data = NULL;
+    unsigned long sizef;
+    if (g_file_get_contents(filename, (char **)&file_data, &sizef, NULL)) {
+        *size = sizef;
+        allocate_and_copy(mem, as, name, file_pa, *size, file_data);
+        g_free(file_data);
+    } else {
+        abort();
+    }
+}
+
+void macho_tz_setup_bootargs(const char *name, AddressSpace *as,
+                             MemoryRegion *mem, hwaddr bootargs_addr,
+                             hwaddr virt_base, hwaddr phys_base,
+                             hwaddr mem_size, hwaddr kern_args,
+                             hwaddr kern_entry, hwaddr kern_phys_base)
+{
+    struct xnu_arm64_monitor_boot_args boot_args;
+    memset(&boot_args, 0, sizeof(boot_args));
+    boot_args.version = xnu_arm64_kBootArgsVersion2;
+    boot_args.virtBase = virt_base;
+    boot_args.physBase = phys_base;
+    boot_args.memSize = mem_size;
+    boot_args.kernArgs = kern_args;
+    boot_args.kernEntry = kern_entry;
+    boot_args.kernPhysBase = kern_phys_base;
+
+    boot_args.kernPhysSlide = 0;
+    boot_args.kernVirtSlide = 0;
+
+    allocate_and_copy(mem, as, name, bootargs_addr, sizeof(boot_args),
+                      &boot_args);
+}
+
+void macho_setup_bootargs(const char *name, AddressSpace *as,
+                          MemoryRegion *mem, hwaddr bootargs_pa,
+                          hwaddr virt_base, hwaddr phys_base, hwaddr mem_size,
+                          hwaddr top_of_kernel_data_pa, hwaddr dtb_va,
+                          hwaddr dtb_size, video_boot_args v_bootargs,
+                          char *kern_args)
+{
+    struct xnu_arm64_boot_args boot_args;
+    memset(&boot_args, 0, sizeof(boot_args));
+    boot_args.Revision = xnu_arm64_kBootArgsRevision2;
+    boot_args.Version = xnu_arm64_kBootArgsVersion2;
+    boot_args.virtBase = virt_base;
+    boot_args.physBase = phys_base;
+    boot_args.memSize = mem_size;
+
+    boot_args.Video.v_baseAddr = v_bootargs.v_baseAddr;
+    boot_args.Video.v_depth = v_bootargs.v_depth;
+    boot_args.Video.v_display = v_bootargs.v_display;
+    boot_args.Video.v_height = v_bootargs.v_height;
+    boot_args.Video.v_rowBytes = v_bootargs.v_rowBytes;
+    boot_args.Video.v_width = v_bootargs.v_width;
+
+    boot_args.topOfKernelData = top_of_kernel_data_pa;
+    boot_args.deviceTreeP = dtb_va;
+    boot_args.deviceTreeLength = dtb_size;
+    boot_args.memSizeActual = 0;
+    boot_args.bootFlags = 1;
+    if (kern_args) {
+        g_strlcpy(boot_args.CommandLine, kern_args,
+                  sizeof(boot_args.CommandLine));
+    }
+
+    allocate_and_copy(mem, as, name, bootargs_pa, sizeof(boot_args),
+                      &boot_args);
+}
+
+static void macho_highest_lowest(struct mach_header_64* mh, uint64_t *lowaddr,
+                                 uint64_t *highaddr)
+{
+    struct load_command* cmd = (struct load_command*)((uint8_t*)mh +
+                                                sizeof(struct mach_header_64));
+    // iterate all the segments once to find highest and lowest addresses
+    uint64_t low_addr_temp = ~0;
+    uint64_t high_addr_temp = 0;
+    for (unsigned int index = 0; index < mh->ncmds; index++) {
+        switch (cmd->cmd) {
+            case LC_SEGMENT_64: {
+                struct segment_command_64 *segCmd =
+                                        (struct segment_command_64 *)cmd;
+                if (segCmd->vmaddr < low_addr_temp) {
+                    low_addr_temp = segCmd->vmaddr;
+                }
+                if (segCmd->vmaddr + segCmd->vmsize > high_addr_temp) {
+                    high_addr_temp = segCmd->vmaddr + segCmd->vmsize;
+                }
+                break;
+            }
+        }
+        cmd = (struct load_command*)((char*)cmd + cmd->cmdsize);
+    }
+    *lowaddr = low_addr_temp;
+    *highaddr = high_addr_temp;
+}
+
+void macho_file_highest_lowest(const char *filename, hwaddr *lowest,
+                                      hwaddr *highest)
+{
+    uint32_t len;
+    uint8_t *data = NULL;
+    char payload_type[4];
+
+    extract_im4p_payload(filename, payload_type, &data, &len);
+
+    if (strncmp(payload_type, "krnl", 4) != 0
+        && strncmp(payload_type, "raw", 4) != 0) {
+        error_report("Couldn't parse ASN.1 data in file '%s' because it is not a 'krnl' object, found '%.4s' object.", filename, payload_type);
+        exit(EXIT_FAILURE);
+    }
+
+    struct mach_header_64* mh = (struct mach_header_64*)data;
+
+    if (mh->magic != MACH_MAGIC_64)
+    {
+        error_report("The file '%s' is not a valid MACH object.", filename);
+        exit(EXIT_FAILURE);
+    }
+
+    macho_highest_lowest(mh, lowest, highest);
+    g_free(data);
+}
+
+void arm_load_macho(char *filename, AddressSpace *as, MemoryRegion *mem,
+                    const char *name, hwaddr phys_base, hwaddr virt_base, hwaddr *pc)
+{
+    uint8_t *data = NULL;
+    uint32_t len;
+    uint8_t* rom_buf = NULL;
+    char payload_type[4];
+
+    extract_im4p_payload(filename, payload_type, &data, &len);
+
+    if (strncmp(payload_type, "krnl", 4) != 0
+        && strncmp(payload_type, "raw", 4) != 0) {
+        error_report("Couldn't parse ASN.1 data in file '%s' because it is not a 'krnl' object, found '%.4s' object.", filename, payload_type);
+        exit(EXIT_FAILURE);
+    }
+    
+    struct mach_header_64* mh = (struct mach_header_64*)data;
+
+    if (mh->magic != MACH_MAGIC_64)
+    {
+        error_report("The file '%s' is not a valid MACH object.", filename);
+        exit(EXIT_FAILURE);
+    }
+
+    struct load_command* cmd = (struct load_command*)(data +
+                                                sizeof(struct mach_header_64));
+
+    for (unsigned int index = 0; index < mh->ncmds; index++) {
+        switch (cmd->cmd) {
+            case LC_SEGMENT_64: {
+                struct segment_command_64 *segCmd =
+                                            (struct segment_command_64 *)cmd;
+                char region_name[32] = {0};
+                snprintf(region_name, sizeof(region_name), "%s-%s", name, segCmd->segname);
+                if(segCmd->vmsize == 0){
+                    break;
+                }
+                rom_buf = g_malloc0(segCmd->vmsize);
+                memcpy(rom_buf, data + segCmd->fileoff, segCmd->filesize);
+                allocate_and_copy(mem, as, region_name, phys_base + segCmd->vmaddr - virt_base, segCmd->vmsize, rom_buf);
+                g_free(rom_buf);
+                rom_buf = NULL;
+                break;
+            }
+            case LC_UNIXTHREAD: {
+                // grab just the entry point PC
+                uint64_t* ptrPc = (uint64_t*)((char*)cmd + 0x110);
+                // 0x110 for arm64 only.
+                *pc = vtop_bases(*ptrPc, phys_base, virt_base);
+                break;
+            }
+        }
+        cmd = (struct load_command*)((char*)cmd + cmd->cmdsize);
+    }
+
+    if (data) {
+        g_free(data);
+    }
+}
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/xnu_dtb.c qemu-t8030-private/hw/arm/xnu_dtb.c
--- qemu-6.0.0/hw/arm/xnu_dtb.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/xnu_dtb.c	2021-05-05 10:12:53.371011300 +0800
@@ -0,0 +1,329 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "sysemu/sysemu.h"
+#include "qemu/error-report.h"
+#include "hw/arm/xnu.h"
+#include "hw/loader.h"
+#include "hw/arm/xnu_dtb.h"
+
+static uint64_t align_4_high_num(uint64_t num)
+{
+    return (num + (4 - 1)) & ~(4 - 1);
+}
+
+static void *align_4_high_ptr(void *ptr)
+{
+    uint64_t num = align_4_high_num((uint64_t)ptr);
+    return (void *)num;
+}
+
+
+static DTBProp *read_dtb_prop(uint8_t **dtb_blob)
+{
+    assert(dtb_blob && *dtb_blob);
+    *dtb_blob = align_4_high_ptr(*dtb_blob);
+    DTBProp *prop = g_new0(DTBProp, 1);
+    memcpy(&prop->name[0], *dtb_blob, DTB_PROP_NAME_LEN);
+    *dtb_blob += DTB_PROP_NAME_LEN;
+    //zero out this flag which sometimes appears in the DT
+    //normally done by iboot
+    prop->length = *(uint32_t *)*dtb_blob & ~DT_PROP_FLAG_PLACEHOLDER;
+    *dtb_blob += sizeof(uint32_t);
+    if (0 != prop->length) {
+        prop->value = g_malloc0(prop->length);
+        assert(prop->value);
+        memcpy(&prop->value[0], *dtb_blob, prop->length);
+        *dtb_blob += prop->length;
+    }
+
+    return prop;
+}
+
+static void delete_prop(DTBProp *prop)
+{
+    if (NULL == prop) {
+        return;
+    }
+
+    if (NULL != prop->value) {
+        g_free(prop->value);
+    }
+
+    g_free(prop);
+}
+
+static DTBNode *read_dtb_node(uint8_t **dtb_blob)
+{
+    assert(dtb_blob && *dtb_blob);
+
+    uint32_t i = 0;
+
+    *dtb_blob = align_4_high_ptr(*dtb_blob);
+    DTBNode *node = g_new0(DTBNode, 1);
+    node->prop_count = *(uint32_t *)*dtb_blob;
+    *dtb_blob += sizeof(uint32_t);
+    node->child_node_count = *(uint32_t *)*dtb_blob;
+    *dtb_blob += sizeof(uint32_t);
+
+    assert(node->prop_count > 0);
+    for (i = 0; i < node->prop_count; i++) {
+        DTBProp *prop = read_dtb_prop(dtb_blob);
+        node->props = g_list_append(node->props, prop);
+    }
+    for (i = 0; i < node->child_node_count; i++) {
+        DTBNode *child = read_dtb_node(dtb_blob);
+        node->child_nodes = g_list_append(node->child_nodes, child);
+    }
+    return node;
+}
+
+void delete_dtb_node(DTBNode *node)
+{
+    if (NULL == node) {
+        return;
+    }
+    if (NULL != node->props) {
+        g_list_free_full(node->props, (GDestroyNotify)delete_prop);
+    }
+    if (NULL != node->child_nodes) {
+        g_list_free_full(node->child_nodes, (GDestroyNotify)delete_dtb_node);
+    }
+    g_free(node);
+}
+
+DTBNode *load_dtb(uint8_t *dtb_blob)
+{
+    DTBNode *root = read_dtb_node(&dtb_blob);
+    return root;
+}
+
+static void save_prop(DTBProp *prop, uint8_t **buf)
+{
+    assert(prop && buf && *buf);
+
+    *buf = align_4_high_ptr(*buf);
+    memcpy(*buf, &prop->name[0], DTB_PROP_NAME_LEN);
+    *buf += DTB_PROP_NAME_LEN;
+    memcpy(*buf, &prop->length, sizeof(uint32_t));
+    *buf += sizeof(uint32_t);
+    memcpy(*buf, prop->value, prop->length);
+    *buf += prop->length;
+}
+
+static void save_node(DTBNode *node, uint8_t **buf)
+{
+    assert(node && buf && *buf);
+
+    *buf = align_4_high_ptr(*buf);
+
+    memcpy(*buf, &node->prop_count, sizeof(uint32_t));
+    *buf += sizeof(uint32_t);
+    memcpy(*buf, &node->child_node_count, sizeof(uint32_t));
+    *buf += sizeof(uint32_t);
+    g_list_foreach(node->props, (GFunc)save_prop, buf);
+    g_list_foreach(node->child_nodes, (GFunc)save_node, buf);
+}
+
+void remove_dtb_node(DTBNode *parent, DTBNode *node)
+{
+    assert(parent && node);
+    GList *iter;
+    bool found = false;
+    for (iter = parent->child_nodes; iter != NULL; iter = iter->next) {
+        if (node == iter->data) {
+            found = true;
+            break;
+        }
+    }
+    assert(found);
+    delete_dtb_node(node);
+    parent->child_nodes = g_list_delete_link(parent->child_nodes, iter);
+
+    //sanity
+    assert(parent->child_node_count > 0);
+
+    parent->child_node_count--;
+}
+void remove_dtb_prop(DTBNode *node, DTBProp *prop)
+{
+    assert(node && prop);
+    GList *iter;
+    bool found = false;
+    for (iter = node->props; iter != NULL; iter = iter->next) {
+        if (prop == iter->data) {
+            found = true;
+            break;
+        }
+    }
+    assert(found);
+    delete_prop(prop);
+    node->props = g_list_delete_link(node->props, iter);
+
+    //sanity
+    assert(node->prop_count > 0);
+
+    node->prop_count--;
+}
+
+DTBProp *add_dtb_prop(DTBNode *n, const char *name, uint32_t size, uint8_t *val)
+{
+    assert(n && name && val);
+    DTBProp *prop = g_new0(DTBProp, 1);
+    memcpy(&prop->name[0], name, DTB_PROP_NAME_LEN);
+    prop->length = size;
+    prop->value = g_malloc0(size);
+    memcpy(&prop->value[0], val, size);
+    n->props = g_list_append(n->props, prop);
+    n->prop_count++;
+    return prop;
+}
+DTBNode *add_dtb_node(DTBNode *n, const char *name)
+{
+    assert(n && name);
+    DTBNode *node = g_new0(DTBNode, 1);
+    add_dtb_prop(node, "name", strlen(name) + 1, (uint8_t*)name);
+    n->child_nodes = g_list_append(n->child_nodes, node);
+    n->child_node_count ++;
+    return node;
+}
+
+void save_dtb(uint8_t *buf, DTBNode *root)
+{
+    assert(buf && root);
+
+    //TODO: handle cases where the buffer is not 4 bytes aligned
+    //though this is never expected to happen and the code is simpler this
+    //way
+    assert(align_4_high_ptr(buf) == buf);
+
+    save_node(root, &buf);
+}
+
+static uint64_t get_dtb_prop_size(DTBProp *prop)
+{
+    uint64_t size = 0;
+
+    assert(prop);
+
+    size = align_4_high_num(sizeof(prop->name) + sizeof(prop->length) +
+                            prop->length);
+    return size;
+}
+
+uint64_t get_dtb_node_buffer_size(DTBNode *node)
+{
+    uint64_t size = 0;
+    DTBProp *prop = NULL;
+    DTBNode *child = NULL;
+    GList *iter = NULL;
+
+    assert(node);
+
+    size += sizeof(node->prop_count) + sizeof(node->child_node_count);
+
+    for (iter = node->props; iter != NULL; iter = iter->next) {
+        prop = (DTBProp *)iter->data;
+        assert(prop);
+        size += get_dtb_prop_size(prop);
+    }
+    for (iter = node->child_nodes; iter != NULL; iter = iter->next) {
+        child = (DTBNode *)iter->data;
+        assert(child);
+        size += get_dtb_node_buffer_size(child);
+    }
+    return size;
+}
+
+DTBProp *get_dtb_prop(DTBNode *node, const char *name)
+{
+    assert(node && name);
+    GList *iter = NULL;
+    DTBProp *prop = NULL;
+
+    for (iter = node->props; iter != NULL; iter = iter->next) {
+        prop = (DTBProp *)iter->data;
+
+        assert(prop);
+
+        if (0 == strncmp((const char *)&prop->name[0], name,
+                         DTB_PROP_NAME_LEN)) {
+            return prop;
+        }
+    }
+    return NULL;
+}
+
+DTBNode *get_dtb_child_node_by_name(DTBNode *node, const char *name)
+{
+    assert(node && name);
+
+    GList *iter = NULL;
+    DTBProp *prop = NULL;
+    DTBNode *child = NULL;
+
+    for (iter = node->child_nodes; iter != NULL; iter = iter->next) {
+        child = (DTBNode *)iter->data;
+
+        assert(child);
+
+        prop = get_dtb_prop(child, "name");
+
+        assert(prop);
+
+        if (0 == strncmp((const char *)prop->value, name, prop->length)) {
+            return child;
+        }
+    }
+    return NULL;
+}
+
+void overwrite_dtb_prop_val(DTBProp *prop, uint8_t chr)
+{
+    uint64_t i = 0;
+    uint8_t *ptr = prop->value;
+    for (i = 0; i < prop->length; i++) {
+        ptr[i] = chr;
+    }
+}
+
+void overwrite_dtb_prop_name(DTBProp *prop, uint8_t chr)
+{
+    uint64_t i = 0;
+    uint8_t *ptr = &prop->name[0];
+    for (i = 0; i < DTB_PROP_NAME_LEN; i++) {
+        ptr[i] = chr;
+    }
+}
+
+void overwrite_dtb_prop(DTBNode *n, const char *name, uint32_t size, uint8_t *val){
+    DTBProp* prop = get_dtb_prop(n, name);
+    if (prop!=NULL){
+        remove_dtb_prop(n, prop);
+    }
+    add_dtb_prop(n, name, size, val);
+}
\ No newline at end of file
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/xnu_fb_cfg.c qemu-t8030-private/hw/arm/xnu_fb_cfg.c
--- qemu-6.0.0/hw/arm/xnu_fb_cfg.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/xnu_fb_cfg.c	2021-05-05 10:12:53.372008600 +0800
@@ -0,0 +1,61 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "sysemu/sysemu.h"
+#include "qemu/error-report.h"
+#include "hw/arm/xnu.h"
+#include "hw/loader.h"
+#include "hw/arm/xnu_file_mmio_dev.h"
+#include "hw/display/xnu_ramfb.h"
+#include "include/hw/qdev-properties.h"
+
+void xnu_define_ramfb_device(AddressSpace* as, hwaddr ramfb_pa)
+{
+
+    DeviceState *fb_dev;
+    fb_dev = qdev_new(TYPE_XNU_RAMFB_DEVICE);
+    qdev_prop_set_uint64(fb_dev, "as", (hwaddr)as);
+    qdev_prop_set_uint64(fb_dev, "fb_pa", ramfb_pa);
+    qdev_prop_set_uint32(fb_dev, "fb_size", RAMFB_SIZE);
+    qdev_prop_set_uint32(fb_dev, "display_cfg.height", V_HEIGHT);
+    qdev_prop_set_uint32(fb_dev, "display_cfg.width", V_WIDTH);
+    qdev_prop_set_uint32(fb_dev, "display_cfg.linesize", V_LINESIZE);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(fb_dev), &error_fatal);
+}
+
+void  xnu_get_video_bootargs(void *opaque, hwaddr ramfb_pa)
+{
+
+    video_boot_args* v_bootargs = (video_boot_args*)opaque;
+    v_bootargs->v_baseAddr = ramfb_pa | 1;
+    v_bootargs->v_depth = V_DEPTH;
+    v_bootargs->v_display = V_DISPLAY;
+    v_bootargs->v_height = V_HEIGHT;
+    v_bootargs->v_width = V_WIDTH;
+    v_bootargs->v_rowBytes = V_LINESIZE;
+
+}
\ No newline at end of file
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/xnu_file_mmio_dev.c qemu-t8030-private/hw/arm/xnu_file_mmio_dev.c
--- qemu-6.0.0/hw/arm/xnu_file_mmio_dev.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/xnu_file_mmio_dev.c	2021-05-05 10:12:53.372008600 +0800
@@ -0,0 +1,106 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "sysemu/sysemu.h"
+#include "qemu/error-report.h"
+#include "hw/arm/xnu.h"
+#include "hw/loader.h"
+#include "hw/arm/xnu_file_mmio_dev.h"
+
+static uint64_t xnu_file_mmio_dev_read(void *opaque,
+                                       hwaddr addr, unsigned size)
+{
+    FileMmioDev *file_dev = opaque;
+    uint64_t ret = 0;
+
+    if (addr + size > file_dev->size) {
+        abort();
+    }
+
+    if (size > sizeof(ret)) {
+        abort();
+    }
+
+    if (addr != lseek(file_dev->fd, addr, SEEK_SET)) {
+        abort();
+    }
+
+    if (size != read(file_dev->fd, &ret, size)) {
+        abort();
+    }
+
+    return ret;
+}
+
+static void xnu_file_mmio_dev_write(void *opaque, hwaddr addr,
+                                    uint64_t val, unsigned size)
+{
+    FileMmioDev *file_dev = opaque;
+
+    if (addr + size > file_dev->size) {
+        abort();
+    }
+
+    if (addr != lseek(file_dev->fd, addr, SEEK_SET)) {
+        abort();
+    }
+
+    if (size != write(file_dev->fd, &val, size)) {
+        abort();
+    }
+
+}
+
+const MemoryRegionOps xnu_file_mmio_dev_ops = {
+    .read = xnu_file_mmio_dev_read,
+    .write = xnu_file_mmio_dev_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+void xnu_file_mmio_dev_create(MemoryRegion *sysmem, FileMmioDev *file_dev,
+                              const char *name, const char *filename)
+{
+    MemoryRegion *iomem = g_new(MemoryRegion, 1);
+    struct stat st;
+
+    if (-1 == lstat(filename, &st)) {
+        abort();
+    }
+
+    file_dev->size = st.st_size;
+
+    memory_region_init_io(iomem, NULL, &xnu_file_mmio_dev_ops, file_dev,
+                          name, file_dev->size);
+    memory_region_add_subregion(sysmem, file_dev->pa, iomem);
+
+    //TODO; think about using O_SYNC
+    //or maybe use fsync() from time to time
+    file_dev->fd = open(filename, O_RDWR);
+    if (-1 == file_dev->fd) {
+        abort();
+    }
+}
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/arm/xnu_mem.c qemu-t8030-private/hw/arm/xnu_mem.c
--- qemu-6.0.0/hw/arm/xnu_mem.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/arm/xnu_mem.c	2021-05-05 10:12:53.372970600 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "exec/address-spaces.h"
+#include "hw/misc/unimp.h"
+#include "sysemu/sysemu.h"
+#include "qemu/error-report.h"
+#include "hw/platform-bus.h"
+#include "exec/memory.h"
+#include "qemu-common.h"
+#include "exec/hwaddr.h"
+#include "hw/boards.h"
+#include "hw/arm/boot.h"
+#include "cpu.h"
+#include "hw/arm/xnu_mem.h"
+
+hwaddr g_virt_base = 0;
+hwaddr g_phys_base = 0;
+
+hwaddr vtop_bases(hwaddr va, hwaddr phys_base, hwaddr virt_base)
+{
+    if ((0 == virt_base) || (0 == phys_base)) {
+        abort();
+    }
+    return va - virt_base + phys_base;
+}
+
+hwaddr ptov_bases(hwaddr pa, hwaddr phys_base, hwaddr virt_base)
+{
+    if ((0 == virt_base) || (0 == phys_base)) {
+        abort();
+    }
+    return pa - phys_base + virt_base;
+}
+
+hwaddr vtop_static(hwaddr va)
+{
+    return vtop_bases(va, g_phys_base, g_virt_base);
+}
+
+hwaddr ptov_static(hwaddr pa)
+{
+    return ptov_bases(pa, g_phys_base, g_virt_base);
+}
+
+hwaddr vtop_mmu(hwaddr va, CPUState *cs)
+{
+    hwaddr phys_addr;
+    MemTxAttrs attrs = {};
+
+    phys_addr = arm_cpu_get_phys_page_attrs_debug(cs, va, &attrs);
+    if (-1 == phys_addr) {
+        abort();
+    }
+
+    return phys_addr;
+}
+
+uint8_t get_highest_different_bit_index(hwaddr addr1, hwaddr addr2)
+{
+    if ((addr1 == addr2) || (0 == addr1) || (0 == addr2)) {
+        abort();
+    }
+    return (64 - __builtin_clzll(addr1 ^ addr2));
+}
+
+hwaddr align_64k_low(hwaddr addr)
+{
+    return addr & ~0xffffull;
+}
+
+hwaddr align_64k_high(hwaddr addr)
+{
+    return (addr + 0xffffull) & ~0xffffull;
+}
+
+uint8_t get_lowest_non_zero_bit_index(hwaddr addr)
+{
+    if (0 == addr) {
+        abort();
+    }
+    return __builtin_ctzll(addr);
+}
+
+hwaddr get_low_bits_mask_for_bit_index(uint8_t bit_index)
+{
+    if (bit_index >= 64) {
+        abort();
+    }
+    return (1 << bit_index) - 1;
+}
+
+void allocate_ram(MemoryRegion *top, const char *name, hwaddr addr,
+                  hwaddr size)
+{
+    MemoryRegion *sec = g_new(MemoryRegion, 1);
+    memory_region_init_ram(sec, NULL, name, size, &error_fatal);
+    memory_region_add_subregion(top, addr, sec);
+}
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/block/apple_ans.c qemu-t8030-private/hw/block/apple_ans.c
--- qemu-6.0.0/hw/block/apple_ans.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/block/apple_ans.c	2021-05-05 23:20:50.699102200 +0800
@@ -0,0 +1,547 @@
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "hw/block/apple_ans.h"
+#include "hw/irq.h"
+#include "migration/vmstate.h"
+#include "qemu/bitops.h"
+#include "qemu/lockable.h"
+#include "qemu/log.h"
+#include "qemu/main-loop.h"
+#include "qemu/module.h"
+#include "qemu/timer.h"
+#include "hw/arm/xnu_dtb.h"
+
+#define ANS_LOG_MSG(s, msg) \
+do { qemu_log_mask(LOG_GUEST_ERROR, "ANS2: message:" \
+                   " type=0x%x ep=%u QWORD0=0x" TARGET_FMT_plx \
+                   " QWORD1=0x" TARGET_FMT_plx " ep0_state=0x%x\n", \
+                   msg->type, msg->endpoint, msg->data[0], msg->data[1], \
+                   s->ep0_status); } while (0)
+
+
+/*
+ * Push a message from AP to IOP,
+ * called with iothread locked,
+ * take ownership of msg
+ */
+static inline void iop_inbox_push(AppleANSState *s, iop_message_t msg)
+{
+    QTAILQ_INSERT_TAIL(&s->inbox, msg, entry);
+    qemu_irq_lower(s->irqs[IRQ_IOP_INBOX]);
+    qemu_cond_broadcast(&s->iop_halt);
+}
+
+static inline iop_message_t iop_inbox_get(AppleANSState *s)
+{
+    iop_message_t msg = QTAILQ_FIRST(&s->inbox);
+    QTAILQ_REMOVE(&s->inbox, msg, entry);
+    return msg;
+}
+
+static inline bool iop_inbox_empty(AppleANSState *s)
+{
+    return QTAILQ_EMPTY(&s->inbox);
+}
+
+/*
+ * Push a message from IOP to AP,
+ * called with iothread locked,
+ * take ownership of msg
+ */
+static inline void iop_outbox_push_nolock(AppleANSState *s, iop_message_t msg)
+{
+    if (!s->outboxEnable) {
+        return;
+    }
+    QTAILQ_INSERT_TAIL(&s->outbox, msg, entry);
+    qemu_irq_raise(s->irqs[IRQ_IOP_OUTBOX]);
+}
+
+/*
+ * Push a message from IOP to AP,
+ * called with iothread unlocked,
+ * take ownership of msg
+ */
+static inline void iop_outbox_push(AppleANSState *s, iop_message_t msg)
+{
+    qemu_mutex_unlock(&s->mutex);
+    qemu_mutex_lock_iothread();
+    iop_outbox_push_nolock(s, msg);
+    qemu_mutex_unlock_iothread();
+    qemu_mutex_lock(&s->mutex);
+}
+
+static inline bool iop_outbox_empty(AppleANSState *s)
+{
+    return QTAILQ_EMPTY(&s->outbox);
+}
+
+static inline uint32_t iop_outbox_flags(AppleANSState *s)
+{
+    uint32_t flags = 0;
+
+    if (iop_outbox_empty(s)) {
+        flags = A7V4_MSG_FLAG_LAST;
+    } else {
+        flags = A7V4_MSG_FLAG_NOTLAST;
+    }
+
+    return flags;
+}
+
+static void iop_handle_mgmt_msg(AppleANSState *s, iop_message_t msg)
+{
+    switch (s->ep0_status) {
+    case EP0_WAIT_HELLO:
+        if (msg->type == MSG_RECV_HELLO) {
+            iop_message_t m = g_new0(struct iop_message, 1);
+            m->type = MSG_TYPE_ROLLCALL;
+            m->rollcall.epMask = (1 << 0); /* Register ANS2Endpoint1 */
+            m->rollcall.epBlock = 1;
+            m->rollcall.epEnded = true;
+            iop_outbox_push(s, m);
+            s->ep0_status = EP0_WAIT_ROLLCALL;
+        } else
+            ANS_LOG_MSG(s, msg);
+        break;
+
+    case EP0_WAIT_ROLLCALL:
+        if (msg->type == MSG_TYPE_ROLLCALL) {
+            iop_message_t m = g_new0(struct iop_message, 1);
+            m->type = MSG_TYPE_POWER;
+            m->power.state = 32;
+            s->ep0_status = EP0_WAIT_POWERACK;
+            iop_outbox_push(s, m);
+        } else
+            ANS_LOG_MSG(s, msg);
+        break;
+
+    case EP0_WAIT_POWERACK:
+        if (msg->type == MSG_TYPE_POWERACK) {
+            iop_message_t m = g_new0(struct iop_message, 1);
+            m->type = MSG_TYPE_POWERACK;
+            m->power.state = msg->power.state;
+            s->ep0_status = EP0_DONE;
+            iop_outbox_push(s, m);
+        } else
+            ANS_LOG_MSG(s, msg);
+        break;
+
+    default:
+        ANS_LOG_MSG(s, msg);
+        break;
+    }
+
+    g_free(msg);
+}
+
+static void *iop_thread_fn(void *opaque)
+{
+    AppleANSState *s = APPLE_ANS(opaque);
+
+    while (true) {
+        bool has_work, stopped;
+
+        WITH_QEMU_LOCK_GUARD(&s->mutex) {
+            stopped = s->stopping;
+            has_work = !iop_inbox_empty(s);
+
+            if (stopped) {
+                break;
+            }
+
+            if (has_work) {
+                iop_message_t msg = iop_inbox_get(s);
+                switch (msg->endpoint) {
+                case 0:
+                    iop_handle_mgmt_msg(s, msg);
+                    break;
+                default:
+                    qemu_log_mask(LOG_GUEST_ERROR,
+                                    "ANS2: Skipping message to unknown endpoint: %d\n",
+                                    msg->endpoint);
+                    g_free(msg);
+                }
+
+                if (iop_inbox_empty(s)) {
+                    qemu_mutex_unlock(&s->mutex);
+                    qemu_mutex_lock_iothread();
+                    qemu_irq_raise(s->irqs[IRQ_IOP_INBOX]);
+                    qemu_mutex_unlock_iothread();
+                    qemu_mutex_lock(&s->mutex);
+                }
+            } else {
+                qemu_cond_wait(&s->iop_halt, &s->mutex);
+            }
+        }
+    }
+
+    return NULL;
+}
+
+static void iop_akf_reg_write(void *opaque, hwaddr addr,
+                              uint64_t data, unsigned size)
+{
+    AppleANSState *s = APPLE_ANS(opaque);
+
+    WITH_QEMU_LOCK_GUARD(&s->mutex) {
+        switch (addr) {
+        case REG_AKF_CONFIG:
+            s->config = data;
+            return;
+
+        case REG_A7V4_CPU_CTRL:
+            if (data & REG_A7V4_CPU_CTRL_RUN) {
+                uint32_t config;
+                iop_message_t msg;
+
+                s->cpu_ctrl = data;
+                msg = g_new0(struct iop_message, 1);
+                msg->type = MSG_SEND_HELLO;
+                msg->hello.major = 11;
+                msg->hello.minor = 11;
+                msg->endpoint = 0;
+                s->ep0_status = EP0_WAIT_HELLO;
+
+                config = pci_default_read_config(PCI_DEVICE(&s->nvme),
+                                                 PCI_COMMAND, 4);
+                config |= 0x0002 | 0x0004; /* memory | bus */
+                pci_default_write_config(PCI_DEVICE(&s->nvme),
+                                            PCI_COMMAND, config, 4);
+                assert(PCI_DEVICE(&s->nvme)->bus_master_enable_region.enabled);
+
+                iop_outbox_push_nolock(s, msg);
+            }
+            return;
+
+        case REG_A7V4_A2I_MSG0:
+            s->inboxBuffer[0] = data;
+            return;
+
+        case REG_A7V4_A2I_MSG1:
+            {
+                iop_message_t msg;
+
+                s->inboxBuffer[1] = data;
+                msg = g_new0(struct iop_message, 1);
+                memcpy(msg->data, s->inboxBuffer, sizeof(s->inboxBuffer));
+                iop_inbox_push(s, msg);
+                return;
+            }
+
+        case REG_A7V4_OUTBOX_CTRL:
+            if (data & REG_A7V4_OUTBOX_CTRL_ENABLE) {
+                s->outboxEnable = true;
+            } else {
+                s->outboxEnable = false;
+            }
+            return;
+
+        default:
+            break;
+        }
+
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "ANS2: AppleA7IOP AKF unknown reg WRITE @ 0x"
+                      TARGET_FMT_plx " value: 0x" TARGET_FMT_plx "\n",
+                      addr, data);
+    }
+}
+
+static uint64_t iop_akf_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    AppleANSState *s = APPLE_ANS(opaque);
+    WITH_QEMU_LOCK_GUARD(&s->mutex) {
+        iop_message_t m;
+        uint64_t ret = 0;
+
+        switch (addr) {
+        case REG_AKF_CONFIG:
+            return s->config;
+
+        case REG_A7V4_CPU_CTRL:
+            return s->cpu_ctrl;
+
+        case REG_A7V4_I2A_MSG0:
+            m = QTAILQ_FIRST(&s->outbox);
+            assert(m);
+            return m->data[0];
+
+        case REG_A7V4_I2A_MSG1:
+            m = QTAILQ_FIRST(&s->outbox);
+            assert(m);
+
+            QTAILQ_REMOVE(&s->outbox, m, entry);
+            m->flags = iop_outbox_flags(s);
+            ret = m->data[1];
+
+            if (iop_outbox_empty(s)) {
+                qemu_irq_lower(s->irqs[IRQ_IOP_OUTBOX]);
+            }
+
+            g_free(m);
+            return ret;
+
+        case REG_A7V4_INBOX_CTRL:
+            if (iop_inbox_empty(s)) {
+                ret |= REG_A7V4_INBOX_CTRL_EMPTY;
+            }
+            return ret;
+
+        case REG_A7V4_OUTBOX_CTRL:
+            if (iop_outbox_empty(s)) {
+                ret |= REG_A7V4_OUTBOX_CTRL_EMPTY;
+            } else {
+                ret |= REG_A7V4_OUTBOX_CTRL_HAS_MSG;
+            }
+
+            if (s->outboxEnable) {
+                ret |= REG_A7V4_OUTBOX_CTRL_ENABLE;
+            }
+            return ret;
+
+        default:
+            break;
+        }
+
+        qemu_log_mask(LOG_UNIMP, "ANS2: AppleA7IOP AKF unknown reg READ @ 0x"
+                      TARGET_FMT_plx "\n", addr);
+    }
+
+    return 0;
+}
+
+static const MemoryRegionOps iop_akf_reg_ops = {
+    .write = iop_akf_reg_write,
+    .read = iop_akf_reg_read,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .valid.min_access_size = 4,
+    .valid.max_access_size = 8,
+    .impl.min_access_size = 4,
+    .impl.max_access_size = 8,
+    .valid.unaligned = false,
+};
+
+static void ascv2_core_reg_write(void *opaque, hwaddr addr,
+                  uint64_t data,
+                  unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "ANS2: AppleASCWrapV2 core reg WRITE @ 0x"
+                  TARGET_FMT_plx " value: 0x" TARGET_FMT_plx "\n", addr, data);
+}
+
+static uint64_t ascv2_core_reg_read(void *opaque,
+                     hwaddr addr,
+                     unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "ANS2: AppleASCWrapV2 core reg READ @ 0x"
+                  TARGET_FMT_plx "\n", addr);
+    return 0;
+}
+
+static const MemoryRegionOps ascv2_core_reg_ops = {
+    .write = ascv2_core_reg_write,
+    .read = ascv2_core_reg_read,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl.min_access_size = 8,
+    .impl.max_access_size = 8,
+    .valid.min_access_size = 8,
+    .valid.max_access_size = 8,
+    .valid.unaligned = false,
+};
+
+static void iop_autoboot_reg_write(void *opaque,
+                  hwaddr addr,
+                  uint64_t data,
+                  unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "ANS2: AppleA7IOP autoboot reg WRITE @ 0x"
+                  TARGET_FMT_plx " value: 0x" TARGET_FMT_plx "\n", addr, data);
+}
+
+static uint64_t iop_autoboot_reg_read(void *opaque, hwaddr addr, unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "ANS2: AppleA7IOP autoboot reg READ @ 0x"
+                  TARGET_FMT_plx "\n", addr);
+    return 0;
+}
+
+static const MemoryRegionOps iop_autoboot_reg_ops = {
+    .write = iop_autoboot_reg_write,
+    .read = iop_autoboot_reg_read,
+};
+
+static void apple_ans_set_irq(void *opaque, int irq_num, int level)
+{
+    AppleANSState *s = APPLE_ANS(opaque);
+    qemu_set_irq(s->irqs[s->nvme_interrupt_idx], level);
+}
+
+SysBusDevice *apple_ans_create(DTBNode *node)
+{
+    DeviceState  *dev;
+    AppleANSState *s;
+    PCIHostState *pci;
+    SysBusDevice *sbd;
+    PCIExpressHost *pex;
+    DTBNode *child;
+    DTBProp *prop;
+    uint64_t *reg;
+    int i;
+    uint32_t data;
+    struct segment_range {
+        uint64_t phys;
+        uint64_t virt;
+        uint64_t remap;
+        uint32_t size;
+        uint32_t flag;
+    };
+    struct segment_range segrange[2] = { 0 };
+
+    dev = qdev_new(TYPE_APPLE_ANS);
+    s = APPLE_ANS(dev);
+    pci = PCI_HOST_BRIDGE(dev);
+    sbd = SYS_BUS_DEVICE(dev);
+    pex = PCIE_HOST_BRIDGE(dev);
+
+    qemu_mutex_init(&s->mutex);
+    prop = get_dtb_prop(node, "reg");
+    assert(prop);
+
+    reg = (uint64_t *)prop->value;
+
+    /*
+     * 0: AppleA7IOP akfRegMap
+     * 1: AppleASCWrapV2 coreRegisterMap
+     * 2: AppleA7IOP autoBootRegMap
+     */
+    s->iomems[0] = g_new(MemoryRegion, 1);
+    memory_region_init_io(s->iomems[0], OBJECT(dev), &iop_akf_reg_ops, s,
+                          TYPE_APPLE_ANS ".akf-reg", reg[1]);
+    sysbus_init_mmio(sbd, s->iomems[0]);
+
+    s->iomems[1] = g_new(MemoryRegion, 1);
+    memory_region_init_io(s->iomems[1], OBJECT(dev), &ascv2_core_reg_ops, s,
+                          TYPE_APPLE_ANS ".ascv2-core-reg", reg[3]);
+    sysbus_init_mmio(sbd, s->iomems[1]);
+
+    s->iomems[2] = g_new(MemoryRegion, 1);
+    memory_region_init_io(s->iomems[2], OBJECT(dev), &iop_autoboot_reg_ops, s,
+                          TYPE_APPLE_ANS ".iop-autoboot-reg", reg[5]);
+    sysbus_init_mmio(sbd, s->iomems[2]);
+
+    for (i = 0; i < 5; i++) {
+        sysbus_init_irq(sbd, &s->irqs[i]);
+    }
+
+    QTAILQ_INIT(&s->inbox);
+    QTAILQ_INIT(&s->outbox);
+    qemu_cond_init(&s->iop_halt);
+
+    child = get_dtb_child_node_by_name(node, "iop-ans-nub");
+    assert(child);
+
+    data = 1;
+    add_dtb_prop(child, "pre-loaded", 4, (uint8_t *)&data);
+    add_dtb_prop(child, "running", 4, (uint8_t *)&data);
+
+    prop = get_dtb_prop(child, "region-base");
+    *(uint64_t *)prop->value = 0x8fc400000;
+
+    prop = get_dtb_prop(child, "region-size");
+    *(uint64_t *)prop->value = 0x3c00000;
+
+    add_dtb_prop(child, "segment-names", 14, (uint8_t *)"__TEXT;__DATA");
+
+    segrange[0].phys = 0x800024000;
+    segrange[0].virt = 0x0;
+    segrange[0].remap = 0x800024000;
+    segrange[0].size = 0x124000;
+    segrange[0].flag = 0x1;
+
+    segrange[1].phys = 0x8fc400000;
+    segrange[1].virt = 0x124000;
+    segrange[1].remap = 0x8fc400000;
+    segrange[1].size = 0x3c00000;
+    segrange[1].flag = 0x0;
+    add_dtb_prop(child, "segment-ranges", 64, (uint8_t *)segrange);
+
+    prop = get_dtb_prop(node, "nvme-interrupt-idx");
+    assert(prop);
+
+    s->nvme_interrupt_idx = *(uint32_t *)prop->value;
+    object_initialize_child(OBJECT(dev), "nvme", &s->nvme, TYPE_NVME);
+
+    object_property_set_str(OBJECT(&s->nvme), "serial",
+                            "QEMUT8030ANS", &error_fatal);
+    object_property_set_bool(OBJECT(&s->nvme), "is-apple-ans",
+                             true, &error_fatal);
+    object_property_set_uint(OBJECT(&s->nvme), "max_ioqpairs", 8, &error_fatal);
+    object_property_set_uint(OBJECT(&s->nvme), "mdts", 8, &error_fatal);
+
+    pcie_host_mmcfg_init(pex, PCIE_MMCFG_SIZE_MAX);
+    memory_region_init(&s->io_mmio, OBJECT(s), "ans_pci_mmio", UINT64_MAX);
+    memory_region_init(&s->io_ioport, OBJECT(s), "ans_pci_ioport", 64 * 1024);
+
+    pci->bus = pci_register_root_bus(dev, "anspcie.0", apple_ans_set_irq,
+                                     pci_swizzle_map_irq_fn, s, &s->io_mmio,
+                                     &s->io_ioport, 0, 4, TYPE_PCIE_BUS);
+
+    s->iomems[3] = g_new(MemoryRegion, 1);
+    memory_region_init_alias(s->iomems[3], OBJECT(dev), TYPE_APPLE_ANS ".nvme",
+                             &s->nvme.iomem, 0, reg[7]);
+    sysbus_init_mmio(sbd, s->iomems[3]);
+
+    return sbd;
+}
+
+static void apple_ans_realize(DeviceState *dev, Error **errp)
+{
+    AppleANSState *s = APPLE_ANS(dev);
+    PCIHostState *pci = PCI_HOST_BRIDGE(dev);
+
+    pci_realize_and_unref(PCI_DEVICE(&s->nvme), pci->bus, &error_fatal);
+
+    if (iop_inbox_empty(s)) {
+        qemu_irq_raise(s->irqs[IRQ_IOP_INBOX]);
+    }
+
+    qemu_thread_create(&s->iop_thread, "ans-iop", iop_thread_fn,
+                       (void *)s, QEMU_THREAD_JOINABLE);
+}
+
+static void apple_ans_unrealize(DeviceState *dev)
+{
+    AppleANSState *s = APPLE_ANS(dev);
+
+    WITH_QEMU_LOCK_GUARD(&s->mutex) {
+        s->stopping = true;
+    }
+    qemu_cond_broadcast(&s->iop_halt);
+}
+
+static void apple_ans_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = apple_ans_realize;
+    dc->unrealize = apple_ans_unrealize;
+    /* dc->reset = apple_ans_reset; */
+    dc->desc = "Apple ANS NVMe";
+    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
+    dc->fw_name = "pci";
+}
+
+static const TypeInfo apple_ans_info = {
+    .name = TYPE_APPLE_ANS,
+    .parent = TYPE_PCIE_HOST_BRIDGE,
+    .instance_size = sizeof(AppleANSState),
+    .class_init = apple_ans_class_init,
+};
+
+static void apple_ans_register_types(void)
+{
+    type_register_static(&apple_ans_info);
+}
+
+type_init(apple_ans_register_types);
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/block/meson.build qemu-t8030-private/hw/block/meson.build
--- qemu-6.0.0/hw/block/meson.build	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/hw/block/meson.build	2021-05-05 23:07:27.965974100 +0800
@@ -3,6 +3,7 @@ softmmu_ss.add(files(
   'cdrom.c',
   'hd-geometry.c'
 ))
+specific_ss.add(when: ['CONFIG_SOFTMMU', 'TARGET_AARCH64'], if_true: files('apple_ans.c'))
 softmmu_ss.add(when: 'CONFIG_ECC', if_true: files('ecc.c'))
 softmmu_ss.add(when: 'CONFIG_FDC', if_true: files('fdc.c'))
 softmmu_ss.add(when: 'CONFIG_NAND', if_true: files('nand.c'))
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/block/nvme-ns.c qemu-t8030-private/hw/block/nvme-ns.c
--- qemu-6.0.0/hw/block/nvme-ns.c	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/hw/block/nvme-ns.c	2021-05-05 10:12:53.415883700 +0800
@@ -45,6 +45,7 @@ void nvme_ns_init_format(NvmeNamespace *
     /* no thin provisioning */
     id_ns->ncap = id_ns->nsze;
     id_ns->nuse = id_ns->ncap;
+    id_ns->nstype = ns->params.nstype;
 
     ns->mdata_offset = nvme_l2b(ns, nlbas);
 
@@ -531,6 +532,7 @@ static Property nvme_ns_props[] = {
     DEFINE_PROP_BOOL("detached", NvmeNamespace, params.detached, false),
     DEFINE_PROP_BOOL("shared", NvmeNamespace, params.shared, false),
     DEFINE_PROP_UINT32("nsid", NvmeNamespace, params.nsid, 0),
+    DEFINE_PROP_UINT32("nstype", NvmeNamespace, params.nstype, 0),
     DEFINE_PROP_UUID("uuid", NvmeNamespace, params.uuid),
     DEFINE_PROP_UINT16("ms", NvmeNamespace, params.ms, 0),
     DEFINE_PROP_UINT8("mset", NvmeNamespace, params.mset, 0),
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/block/nvme-ns.h qemu-t8030-private/hw/block/nvme-ns.h
--- qemu-6.0.0/hw/block/nvme-ns.h	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/hw/block/nvme-ns.h	2021-05-05 10:12:53.415883700 +0800
@@ -31,6 +31,7 @@ typedef struct NvmeNamespaceParams {
     bool     detached;
     bool     shared;
     uint32_t nsid;
+    uint32_t nstype;
     QemuUUID uuid;
 
     uint16_t ms;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/block/nvme-subsys.h qemu-t8030-private/hw/block/nvme-subsys.h
--- qemu-6.0.0/hw/block/nvme-subsys.h	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/hw/block/nvme-subsys.h	2021-05-05 10:12:53.416854100 +0800
@@ -14,7 +14,7 @@
     OBJECT_CHECK(NvmeSubsystem, (obj), TYPE_NVME_SUBSYS)
 
 #define NVME_SUBSYS_MAX_CTRLS   32
-#define NVME_MAX_NAMESPACES     256
+#define NVME_MAX_NAMESPACES     16
 
 typedef struct NvmeCtrl NvmeCtrl;
 typedef struct NvmeNamespace NvmeNamespace;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/block/nvme.c qemu-t8030-private/hw/block/nvme.c
--- qemu-6.0.0/hw/block/nvme.c	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/hw/block/nvme.c	2021-05-05 10:12:53.418874700 +0800
@@ -209,6 +209,7 @@ static const uint32_t nvme_cse_acs[256]
     [NVME_ADM_CMD_ASYNC_EV_REQ]     = NVME_CMD_EFF_CSUPP,
     [NVME_ADM_CMD_NS_ATTACHMENT]    = NVME_CMD_EFF_CSUPP | NVME_CMD_EFF_NIC,
     [NVME_ADM_CMD_FORMAT_NVM]       = NVME_CMD_EFF_CSUPP | NVME_CMD_EFF_LBCC,
+    [NVME_ADM_CMD_TUNNEL]           = NVME_CMD_EFF_CSUPP,
 };
 
 static const uint32_t nvme_cse_iocs_none[256];
@@ -3738,7 +3739,7 @@ static uint16_t nvme_del_sq(NvmeCtrl *n,
 }
 
 static void nvme_init_sq(NvmeSQueue *sq, NvmeCtrl *n, uint64_t dma_addr,
-                         uint16_t sqid, uint16_t cqid, uint16_t size)
+                         uint16_t sqid, uint16_t cqid, uint16_t size, uint32_t entry_size)
 {
     int i;
     NvmeCQueue *cq;
@@ -3747,6 +3748,7 @@ static void nvme_init_sq(NvmeSQueue *sq,
     sq->dma_addr = dma_addr;
     sq->sqid = sqid;
     sq->size = size;
+    sq->entry_size = entry_size;
     sq->cqid = cqid;
     sq->head = sq->tail = 0;
     sq->io_req = g_new0(NvmeRequest, sq->size);
@@ -3800,7 +3802,7 @@ static uint16_t nvme_create_sq(NvmeCtrl
         return NVME_INVALID_FIELD | NVME_DNR;
     }
     sq = g_malloc0(sizeof(*sq));
-    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);
+    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1, 1 << NVME_CC_IOSQES(n->bar.cc));
     return NVME_SUCCESS;
 }
 
@@ -5123,6 +5125,10 @@ static uint16_t nvme_format(NvmeCtrl *n,
     return req->status;
 }
 
+static uint16_t nvme_tunnel(NvmeCtrl *n, NvmeRequest *req) {
+    return NVME_SUCCESS;
+}
+
 static uint16_t nvme_admin_cmd(NvmeCtrl *n, NvmeRequest *req)
 {
     trace_pci_nvme_admin_cmd(nvme_cid(req), nvme_sqid(req), req->cmd.opcode,
@@ -5159,6 +5165,8 @@ static uint16_t nvme_admin_cmd(NvmeCtrl
         return nvme_get_feature(n, req);
     case NVME_ADM_CMD_ASYNC_EV_REQ:
         return nvme_aer(n, req);
+    case NVME_ADM_CMD_TUNNEL:
+        return nvme_tunnel(n, req);
     case NVME_ADM_CMD_NS_ATTACHMENT:
         return nvme_ns_attachment(n, req);
     case NVME_ADM_CMD_FORMAT_NVM:
@@ -5182,7 +5190,7 @@ static void nvme_process_sq(void *opaque
     NvmeRequest *req;
 
     while (!(nvme_sq_empty(sq) || QTAILQ_EMPTY(&sq->req_list))) {
-        addr = sq->dma_addr + sq->head * n->sqe_size;
+        addr = sq->dma_addr + sq->head * sq->entry_size;
         if (nvme_addr_read(n, addr, (void *)&cmd, sizeof(cmd))) {
             trace_pci_nvme_err_addr_read(addr);
             trace_pci_nvme_err_cfs();
@@ -5386,11 +5394,11 @@ static int nvme_start_ctrl(NvmeCtrl *n)
     n->page_size = page_size;
     n->max_prp_ents = n->page_size / sizeof(uint64_t);
     n->cqe_size = 1 << NVME_CC_IOCQES(n->bar.cc);
-    n->sqe_size = 1 << NVME_CC_IOSQES(n->bar.cc);
+    //TODO: entry_size
     nvme_init_cq(&n->admin_cq, n, n->bar.acq, 0, 0,
                  NVME_AQA_ACQS(n->bar.aqa) + 1, 1);
     nvme_init_sq(&n->admin_sq, n, n->bar.asq, 0, 0,
-                 NVME_AQA_ASQS(n->bar.aqa) + 1);
+                 NVME_AQA_ASQS(n->bar.aqa) + 1, 1 << 6);
 
     nvme_set_timestamp(n, 0ULL);
 
@@ -5669,6 +5677,21 @@ static uint64_t nvme_mmio_read(void *opa
             memory_region_msync(&n->pmr.dev->mr, 0, n->pmr.dev->size);
         }
         memcpy(&val, ptr + addr, size);
+    } else if (n->params.is_apple_ans) {
+        switch (addr){
+            case NVME_APPLE_MAX_PEND_CMDS:
+                val = NVME_APPLE_MAX_PEND_CMDS_VAL;
+                break;
+            case NVME_APPLE_BOOT_STATUS:
+                val = NVME_APPLE_BOOT_STATUS_OK;
+                break;
+            case NVME_APPLE_BASE_CMD_ID:
+                val = 0x6000;
+                break;
+            default:
+                fprintf(stderr, "ANS2: MMIO read beyond last register,"
+                                " offset=0x%"PRIx64", returning 0\n", addr);
+        }
     } else {
         NVME_GUEST_ERR(pci_nvme_ub_mmiord_invalid_ofs,
                        "MMIO read beyond last register,"
@@ -5812,8 +5835,11 @@ static void nvme_mmio_write(void *opaque
 
     if (addr < sizeof(n->bar)) {
         nvme_write_bar(n, addr, data, size);
-    } else {
+    } else if (addr < sizeof(n->bar) + 2 * (n->params.max_ioqpairs + 1) * NVME_DB_SIZE){
         nvme_process_db(n, addr, data);
+    } else if (n->params.is_apple_ans) {
+        fprintf(stderr, "ANS2: MMIO write to unknown vendor register,"
+                        " offset=0x%"PRIx64" value=0x%"PRIx64", returning\n", addr, data);
     }
 }
 
@@ -5917,8 +5943,12 @@ static void nvme_init_state(NvmeCtrl *n)
 {
     n->num_namespaces = NVME_MAX_NAMESPACES;
     /* add one to max_ioqpairs to account for the admin queue pair */
-    n->reg_size = pow2ceil(sizeof(NvmeBar) +
-                           2 * (n->params.max_ioqpairs + 1) * NVME_DB_SIZE);
+    if (n->params.is_apple_ans) {
+        n->reg_size = 0x40000;
+    } else {
+        n->reg_size = pow2ceil(sizeof(NvmeBar) +
+                            2 * (n->params.max_ioqpairs + 1) * NVME_DB_SIZE);
+    }
     n->sq = g_new0(NvmeSQueue *, n->params.max_ioqpairs + 1);
     n->cq = g_new0(NvmeCQueue *, n->params.max_ioqpairs + 1);
     n->temperature = NVME_TEMPERATURE;
@@ -6094,7 +6124,8 @@ static void nvme_init_ctrl(NvmeCtrl *n,
     id->wctemp = cpu_to_le16(NVME_TEMPERATURE_WARNING);
     id->cctemp = cpu_to_le16(NVME_TEMPERATURE_CRITICAL);
 
-    id->sqes = (0x6 << 4) | 0x6;
+    //TODO: ANS2: IOSQES = 7 on non-admin queues
+    id->sqes = (0x7 << 4) | 0x6;
     id->cqes = (0x4 << 4) | 0x4;
     id->nn = cpu_to_le32(n->num_namespaces);
     id->oncs = cpu_to_le16(NVME_ONCS_WRITE_ZEROES | NVME_ONCS_TIMESTAMP |
@@ -6120,6 +6151,13 @@ static void nvme_init_ctrl(NvmeCtrl *n,
     id->psd[0].enlat = cpu_to_le32(0x10);
     id->psd[0].exlat = cpu_to_le32(0x4);
 
+    // id->capacity = 0;
+    // for (int i = 0; i < n->num_namespaces; i++)
+    // if(n->namespaces[i]){
+    //     id->capacity += n->namespaces[i]->size;
+    // }
+    id->capacity = 128;
+    n->bar.cap = 0;
     if (n->subsys) {
         id->cmic |= NVME_CMIC_MULTI_CTRL;
     }
@@ -6255,6 +6293,7 @@ static Property nvme_props[] = {
     DEFINE_PROP_UINT8("mdts", NvmeCtrl, params.mdts, 7),
     DEFINE_PROP_UINT8("vsl", NvmeCtrl, params.vsl, 7),
     DEFINE_PROP_BOOL("use-intel-id", NvmeCtrl, params.use_intel_id, false),
+    DEFINE_PROP_BOOL("is-apple-ans", NvmeCtrl, params.is_apple_ans, false),
     DEFINE_PROP_BOOL("legacy-cmb", NvmeCtrl, params.legacy_cmb, false),
     DEFINE_PROP_UINT8("zoned.zasl", NvmeCtrl, params.zasl, 0),
     DEFINE_PROP_END_OF_LIST(),
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/block/nvme.h qemu-t8030-private/hw/block/nvme.h
--- qemu-6.0.0/hw/block/nvme.h	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/hw/block/nvme.h	2021-05-05 10:12:53.418874700 +0800
@@ -20,6 +20,7 @@ typedef struct NvmeParams {
     uint8_t  mdts;
     uint8_t  vsl;
     bool     use_intel_id;
+    bool     is_apple_ans;
     uint8_t  zasl;
     bool     legacy_cmb;
 } NvmeParams;
@@ -106,6 +107,7 @@ typedef struct NvmeSQueue {
     struct NvmeCtrl *ctrl;
     uint16_t    sqid;
     uint16_t    cqid;
+    uint32_t    entry_size;
     uint32_t    head;
     uint32_t    tail;
     uint32_t    size;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/display/meson.build qemu-t8030-private/hw/display/meson.build
--- qemu-6.0.0/hw/display/meson.build	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/hw/display/meson.build	2021-05-05 10:12:53.510629700 +0800
@@ -1,5 +1,6 @@
 hw_display_modules = {}
 
+softmmu_ss.add(files('xnu_ramfb.c'))
 softmmu_ss.add(when: 'CONFIG_DDC', if_true: files('i2c-ddc.c'))
 softmmu_ss.add(when: 'CONFIG_EDID', if_true: files('edid-generate.c', 'edid-region.c'))
 
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/display/xnu_ramfb.c qemu-t8030-private/hw/display/xnu_ramfb.c
--- qemu-6.0.0/hw/display/xnu_ramfb.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/display/xnu_ramfb.c	2021-05-05 10:12:53.542243900 +0800
@@ -0,0 +1,141 @@
+#include "qemu/osdep.h"
+#include "hw/loader.h"
+#include "hw/qdev-properties.h"
+#include "hw/display/xnu_ramfb.h"
+#include "ui/console.h"
+
+#define XNU_RAMFB(obj) \
+    OBJECT_CHECK(xnu_ramfb_state, (obj), TYPE_XNU_RAMFB_DEVICE)
+
+typedef struct display_cfg{
+    uint32_t format;
+    uint32_t width;
+    uint32_t height;
+    uint32_t linesize;
+} xnu_display_cfg;
+
+typedef struct xnu_ramfb_state {
+    SysBusDevice parent_obj;
+    xnu_display_cfg display_cfg;
+    QemuConsole* con;
+    uint8_t* qemu_fb_ptr; //Pointer that will sent to display callbacks 
+    hwaddr fb_pa;
+    uint32_t fb_size;
+    hwaddr as;
+} xnu_ramfb_state;
+
+void xnu_ramfb_display_update(void *opaque)
+{
+    DisplaySurface *ds = NULL;
+    xnu_ramfb_state *xnu_ramfb = XNU_RAMFB(opaque);
+    uint32_t format = xnu_ramfb->display_cfg.format;
+    uint32_t width = xnu_ramfb->display_cfg.width;
+    uint32_t height = xnu_ramfb->display_cfg.height;
+    uint32_t linesize = xnu_ramfb->display_cfg.linesize;
+    QemuConsole *con = xnu_ramfb->con;
+    hwaddr as = xnu_ramfb->as;
+    hwaddr fb_pa = xnu_ramfb->fb_pa;
+    uint32_t fb_size = xnu_ramfb->fb_size;
+    uint8_t*  qemu_fb_ptr = xnu_ramfb->qemu_fb_ptr;
+
+    assert(qemu_fb_ptr != 0);
+    assert(fb_pa != 0);
+
+    address_space_rw((AddressSpace*) as, fb_pa, MEMTXATTRS_UNSPECIFIED,
+                qemu_fb_ptr, fb_size, FALSE);
+    ds = qemu_create_displaysurface_from(
+        width, height, format, linesize, qemu_fb_ptr);
+    if (ds) {
+        dpy_gfx_replace_surface(con, ds);
+    }
+    dpy_gfx_update_full(con);
+}
+
+void xnu_display_prolog(xnu_ramfb_state* xnu_fb_state)
+{
+    //currently empty
+    return;
+}
+
+void xnu_ramfb_setup(xnu_ramfb_state* xnu_fb_state)
+{
+    uint8_t* fb_ptr;
+    xnu_fb_state->display_cfg.format = PIXMAN_LE_r8g8b8;
+
+    if (xnu_fb_state->fb_size == 0){
+        fprintf(stderr,
+            "xnu_ram_fb: size for the framebuffer is zero, aborting...\n");
+        abort();
+    }
+    fb_ptr = g_malloc0(xnu_fb_state->fb_size);
+    if (fb_ptr == NULL){
+        fprintf(stderr,
+            "xnu_ram_fb: failed to allocate memory for the framebuffer.\n");
+        abort();
+    }
+    xnu_fb_state->qemu_fb_ptr = fb_ptr;
+
+    xnu_display_prolog(xnu_fb_state);
+}
+
+void xnu_ramfb_free(uint8_t* qemu_fb_ptr)
+{
+    g_free(qemu_fb_ptr);
+}
+
+static const GraphicHwOps wrapper_ops = {
+    .gfx_update = xnu_ramfb_display_update,
+};
+
+static void xnu_ramfb_realizefn(DeviceState *dev, Error **errp)
+{
+    xnu_ramfb_state *xnu_ramfb = XNU_RAMFB(dev);
+    xnu_ramfb->con = graphic_console_init(dev, 0, &wrapper_ops, dev);
+    xnu_ramfb_setup(xnu_ramfb);
+}
+
+static void xnu_ramfb_unrealizefn(DeviceState *dev)
+{
+    xnu_ramfb_state *xnu_ramfb = XNU_RAMFB(dev);
+    graphic_console_close(xnu_ramfb->con);
+    xnu_ramfb_free(xnu_ramfb->qemu_fb_ptr);
+}
+
+static Property xnu_ramfb_properties[] = {
+    DEFINE_PROP_UINT64("as", xnu_ramfb_state, as, 0),
+    DEFINE_PROP_UINT64("fb_pa", xnu_ramfb_state, fb_pa, 0),
+    DEFINE_PROP_UINT32("fb_size", xnu_ramfb_state, fb_size, 0),
+    DEFINE_PROP_UINT32("display_cfg.width", xnu_ramfb_state, 
+                display_cfg.width, 0),
+    DEFINE_PROP_UINT32("display_cfg.height", xnu_ramfb_state, 
+                display_cfg.height, 0),
+    DEFINE_PROP_UINT32("display_cfg.linesize", xnu_ramfb_state, 
+                display_cfg.linesize, 0),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void xnu_ramfb_class_initfn(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
+    dc->realize = xnu_ramfb_realizefn;
+    dc->unrealize = xnu_ramfb_unrealizefn;
+    device_class_set_props(dc, xnu_ramfb_properties);
+    dc->desc = "xnu ram framebuffer";
+    dc->user_creatable = true;
+}
+
+static const TypeInfo xnu_ramfb_info = {
+    .name          = TYPE_XNU_RAMFB_DEVICE,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(xnu_ramfb_state),
+    .class_init    = xnu_ramfb_class_initfn,
+};
+
+static void xnu_ramfb_register_types(void)
+{
+    type_register_static(&xnu_ramfb_info);
+}
+
+type_init(xnu_ramfb_register_types)
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/gpio/apple_gpio.c qemu-t8030-private/hw/gpio/apple_gpio.c
--- qemu-6.0.0/hw/gpio/apple_gpio.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/gpio/apple_gpio.c	2021-05-05 23:38:33.394739300 +0800
@@ -0,0 +1,394 @@
+#include "qemu/osdep.h"
+#include "hw/gpio/apple_gpio.h"
+#include "hw/irq.h"
+#include "migration/vmstate.h"
+#include "qemu/bitops.h"
+#include "qemu/lockable.h"
+#include "qemu/log.h"
+#include "qemu/module.h"
+#include "qemu/timer.h"
+#include "hw/arm/xnu_dtb.h"
+
+#define GPIO_MAX_PIN_NR             (512)
+#define GPIO_MAX_INT_GRP_NR         (0x7)
+
+#define rGPIOCFG(_n)                (0x000 + (_n) * 4)
+#define rGPIOINT(_g, _n)            (0x800 + (_g) * 0x40 + (((_n) + 31) >> 5) * 4)
+
+#define rGPIO_NPL_IN_EN             (0xC48)
+
+/* Base Pin Defines for Apple GPIOs */
+
+#define GPIOPADPINS             (8)
+
+#define GPIO2PIN(gpio)          ((gpio) & (GPIOPADPINS - 1))
+#define GPIO2PAD(gpio)          (((gpio) >> 8) & 0xFF)
+#define GPIO2CONTROLLER(gpio)   (((gpio) >> 24) & 0xFF)
+
+#define DATA_0          (0 << 0)
+#define DATA_1          (1 << 0)
+
+#define CFG_GP_IN       (0 << 1)
+#define CFG_GP_OUT      (1 << 1)
+#define CFG_INT_LVL_HI  (2 << 1)
+#define CFG_INT_LVL_LO  (3 << 1)
+#define CFG_INT_EDG_RIS (4 << 1)
+#define CFG_INT_EDG_FAL (5 << 1)
+#define CFG_INT_EDG_ANY (6 << 1)
+#define CFG_DISABLE     (7 << 1)
+#define CFG_MASK        (7 << 1)
+
+#define FUNC_SHIFT      (5)
+#define FUNC_GPIO       (0 << FUNC_SHIFT)
+#define FUNC_ALT0       (1 << FUNC_SHIFT)
+#define FUNC_ALT1       (2 << FUNC_SHIFT)
+#define FUNC_ALT2       (3 << FUNC_SHIFT)
+#define FUNC_MASK       (3 << FUNC_SHIFT)
+
+#define PULL_NONE       (0 << 7)
+#define PULL_UP         (3 << 7)
+#define PULL_UP_STRONG  (2 << 7)
+#define PULL_DOWN       (1 << 7)
+#define PULL_MASK       (3 << 7)
+
+#define INPUT_ENABLE    (1 << 9)
+
+#define INPUT_CMOS      (0 << 14)
+#define INPUT_SCHMITT   (1 << 14)
+
+#define INTR_GRP_SHIFT  (16)
+#define INTR_GRP_SEL0   (0 << INTR_GRP_SHIFT)
+#define INTR_GRP_SEL1   (1 << INTR_GRP_SHIFT)
+#define INTR_GRP_SEL2   (2 << INTR_GRP_SHIFT)
+#define INTR_GRP_SEL3   (3 << INTR_GRP_SHIFT)
+#define INTR_GRP_SEL4   (4 << INTR_GRP_SHIFT)
+#define INTR_GRP_SEL5   (5 << INTR_GRP_SHIFT)
+#define INTR_GRP_SEL6   (6 << INTR_GRP_SHIFT)
+#define INT_MASKED      (7 << INTR_GRP_SHIFT)
+
+#define CFG_DISABLED    (               FUNC_GPIO | CFG_DISABLE |          INT_MASKED)
+#define CFG_IN          (INPUT_ENABLE | FUNC_GPIO | CFG_GP_IN   |          INT_MASKED)
+#define CFG_OUT         (INPUT_ENABLE | FUNC_GPIO | CFG_GP_OUT  |          INT_MASKED)
+#define CFG_OUT_0       (INPUT_ENABLE | FUNC_GPIO | CFG_GP_OUT  | DATA_0 | INT_MASKED)
+#define CFG_OUT_1       (INPUT_ENABLE | FUNC_GPIO | CFG_GP_OUT  | DATA_1 | INT_MASKED)
+#define CFG_FUNC0       (INPUT_ENABLE | FUNC_ALT0 |                        INT_MASKED)
+#define CFG_FUNC1       (INPUT_ENABLE | FUNC_ALT1 |                        INT_MASKED)
+#define CFG_FUNC2       (INPUT_ENABLE | FUNC_ALT2 |                        INT_MASKED)
+
+static void apple_gpio_update_pincfg(AppleGPIOState *s, int pin, uint32_t value)
+{
+    s->gpio_cfg[pin] = value;
+    if (value & FUNC_MASK) {
+        // TODO: Is this how FUNC_ALT0 supposed to behave?
+        switch (value & FUNC_MASK) {
+        case FUNC_ALT0:
+            qemu_set_irq(s->out[pin], 1);
+            break;
+
+        default:
+            qemu_log_mask(LOG_UNIMP, "%s: set pin %u to unknown func %u", __func__, pin, value & FUNC_MASK);
+            break;
+        }
+    } else {
+        if ((value & CFG_MASK) == CFG_GP_OUT) {
+            qemu_set_irq(s->out[pin], value & DATA_1);
+        } else {
+            qemu_set_irq(s->out[pin], 1);
+        }
+    }
+}
+
+
+static void apple_gpio_set(void *opaque, int pin, int level)
+{
+    AppleGPIOState *s = APPLE_GPIO(opaque);
+    int grp;
+
+    if (pin >= s->npins) {
+        return;
+    }
+
+    level = level != 0;
+    if (level) {
+        set_bit(pin, (unsigned long *)s->in);
+    } else {
+        clear_bit(pin, (unsigned long *)s->in);
+    }
+
+    grp = pin >> 5;
+    if ((s->gpio_cfg[pin] & INT_MASKED) != INT_MASKED) {
+        int irqgrp = (s->gpio_cfg[pin] & INT_MASKED) >> INTR_GRP_SHIFT;
+        switch (s->gpio_cfg[pin] & CFG_MASK) {
+        case CFG_GP_IN:
+        case CFG_GP_OUT:
+            break;
+
+        case CFG_INT_LVL_HI:
+            if (level) {
+                set_bit(pin, (unsigned long *)s->int_cfg[irqgrp]);
+            }
+            break;
+
+        case CFG_INT_LVL_LO:
+            if (!level) {
+                set_bit(pin, (unsigned long *)s->int_cfg[irqgrp]);
+            }
+            break;
+
+        case CFG_INT_EDG_RIS:
+            if (test_bit(pin, (unsigned long *)s->old_in) == 0 && level) {
+                set_bit(pin, (unsigned long *)s->int_cfg[irqgrp]);
+            }
+            break;
+
+        case CFG_INT_EDG_FAL:
+            if (test_bit(pin, (unsigned long *)s->old_in) && !level) {
+                set_bit(pin, (unsigned long *)s->int_cfg[irqgrp]);
+            }
+            break;
+
+        case CFG_INT_EDG_ANY:
+            if (test_bit(pin, (unsigned long *)s->old_in) != level) {
+                set_bit(pin, (unsigned long *)s->int_cfg[irqgrp]);
+            }
+            break;
+
+        default:
+            break;
+        }
+
+        s->old_in[grp] = s->in[grp];
+        qemu_set_irq(s->irqs[irqgrp], find_first_bit((unsigned long *)s->int_cfg[irqgrp], s->npins) != s->npins);
+    }
+
+}
+
+static void apple_gpio_realize(DeviceState *dev, Error **errp)
+{
+    int i;
+    AppleGPIOState *s = APPLE_GPIO(dev);
+
+    s->gpio_cfg = g_new0(uint32_t, s->npins);
+    s->int_cfg = g_new0(uint32_t *, s->nirqgrps);
+
+    for(i = 0; i < s->nirqgrps; i++) {
+        s->int_cfg[i] = g_new0(uint32_t, s->npins);
+    }
+
+    s->old_in = g_new0(uint32_t, (s->npins + 31) >> 5);
+    s->in = g_new0(uint32_t, (s->npins + 31) >> 5);
+}
+
+static void apple_gpio_reset(DeviceState *dev)
+{
+    int i;
+    AppleGPIOState *s = APPLE_GPIO(dev);
+
+    for (i = 0; i < s->npins; i++) {
+        s->gpio_cfg[i] = CFG_DISABLED;
+    }
+
+    for (i = 0; i < s->nirqgrps; i++) {
+        memset(s->int_cfg[i], 0, 4 * s->npins);
+    }
+
+    memset(s->old_in, 0, 4 * ((s->npins + 31) >> 5));
+    memset(s->in, 0, 4 * ((s->npins + 31) >> 5));
+}
+
+static void apple_gpio_cfg_write(AppleGPIOState *s, unsigned int pin,
+                                 hwaddr addr, uint32_t value)
+{
+    if (pin >= s->npins) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: Bad offset 0x%" HWADDR_PRIx "\n", __func__, addr);
+        return;
+    }
+
+    apple_gpio_update_pincfg(s, pin, value);
+}
+
+static uint32_t apple_gpio_cfg_read(AppleGPIOState *s, unsigned int pin, hwaddr addr)
+{
+    uint32_t val;
+
+    if (pin >= s->npins) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: Bad offset 0x%" HWADDR_PRIx "\n", __func__, addr);
+        return 0;
+    }
+
+    val = s->gpio_cfg[pin];
+
+    if (((val & FUNC_MASK) == FUNC_GPIO) && ((val & CFG_MASK) == CFG_GP_IN)) {
+        val &= ~DATA_1;
+        val |= test_bit(pin, (unsigned long *)s->in);
+    }
+
+    return val;
+}
+
+static void apple_gpio_int_write(AppleGPIOState *s, unsigned int group,
+                                 hwaddr addr, uint32_t value)
+{
+    int offset;
+
+    if (group >= s->nirqgrps) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: Bad offset 0x%" HWADDR_PRIx "\n", __func__, addr);
+        return;
+    }
+
+    offset = addr - rGPIOINT(group, 0);
+    s->int_cfg[group][offset >> 2] = value;
+
+    if (find_first_bit((unsigned long *)s->int_cfg[group], s->npins) == s->npins) {
+        qemu_irq_lower(s->irqs[group]);
+    }
+}
+
+static uint32_t apple_gpio_int_read(AppleGPIOState *s,
+                                    unsigned int group, hwaddr addr)
+{
+    int offset;
+
+    if (group >= s->nirqgrps) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: Bad offset 0x%" HWADDR_PRIx "\n", __func__, addr);
+        return 0;
+    }
+
+    offset = addr - rGPIOINT(group, 0);
+    return s->int_cfg[group][offset >> 2];
+}
+
+static void apple_gpio_reg_write(void *opaque,
+                  hwaddr addr,
+                  uint64_t data,
+                  unsigned size)
+{
+    AppleGPIOState *s = APPLE_GPIO(opaque);
+
+    switch (addr) {
+    case rGPIOCFG(0) ... rGPIOCFG(GPIO_MAX_PIN_NR - 1):
+        if ((data & FUNC_MASK) > FUNC_ALT0) {
+            qemu_log_mask(LOG_UNIMP,
+                            "%s: alternate function " TARGET_FMT_plx " is not supported\n",
+                            __func__, ((data & FUNC_MASK) >> FUNC_SHIFT) - 1);
+        }
+        return apple_gpio_cfg_write(s, (addr - rGPIOCFG(0)) >> 2, addr, data);
+        break;
+
+    case rGPIOINT(0, 0) ... rGPIOINT(GPIO_MAX_INT_GRP_NR, GPIO_MAX_PIN_NR - 1):
+        return apple_gpio_int_write(s, (addr - rGPIOINT(0, 0)) >> 6, addr, data);
+        break;
+
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                    "%s: Bad offset 0x%" HWADDR_PRIx
+                    ": " TARGET_FMT_plx "\n", __func__, addr, data);
+        break;
+    }
+}
+
+static uint64_t apple_gpio_reg_read(void *opaque,
+                     hwaddr addr,
+                     unsigned size)
+{
+    AppleGPIOState *s = APPLE_GPIO(opaque);
+
+    switch (addr) {
+    case rGPIOCFG(0) ... rGPIOCFG(GPIO_MAX_PIN_NR - 1):
+        return apple_gpio_cfg_read(s, (addr - rGPIOCFG(0)) >> 2, addr);
+        break;
+
+    case rGPIOINT(0, 0) ... rGPIOINT(GPIO_MAX_INT_GRP_NR, GPIO_MAX_PIN_NR - 1):
+        return apple_gpio_int_read(s, (addr - rGPIOINT(0, 0)) >> 6, addr);
+        break;
+
+    case rGPIO_NPL_IN_EN:
+        return s->npl;
+        break;
+
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                    "%s: Bad offset 0x%" HWADDR_PRIx "\n", __func__, addr);
+    }
+
+    return 0;
+}
+
+static const MemoryRegionOps gpio_reg_ops = {
+    .write = apple_gpio_reg_write,
+    .read = apple_gpio_reg_read,
+    .valid.max_access_size = 4,
+    .valid.min_access_size = 4,
+    .valid.unaligned = false,
+};
+
+DeviceState *apple_gpio_create(DTBNode *node)
+{
+    int i;
+    uint64_t mmio_size;
+    DeviceState *dev;
+    SysBusDevice *sbd;
+    AppleGPIOState *s;
+
+    dev = qdev_new(TYPE_APPLE_GPIO);
+    sbd = SYS_BUS_DEVICE(dev);
+    s = APPLE_GPIO(dev);
+
+    s->iomem = g_new(MemoryRegion, 1);
+    DTBProp *prop = get_dtb_prop(node, "reg");
+    mmio_size = ((hwaddr *)prop->value)[1];
+    prop = get_dtb_prop(node, "name");
+    dev->id = g_strdup((const char *)prop->value);
+    memory_region_init_io(s->iomem, OBJECT(dev), &gpio_reg_ops, s,
+                          (const char *)prop->value, mmio_size);
+    sysbus_init_mmio(sbd, s->iomem);
+
+    prop = get_dtb_prop(node, "#gpio-pins");
+    s->npins = *(uint32_t *)prop->value;
+    assert(s->npins < GPIO_MAX_PIN_NR);
+    qdev_init_gpio_in(dev, apple_gpio_set, s->npins);
+
+    s->out = g_new(qemu_irq, s->npins);
+    qdev_init_gpio_out(dev, s->out, s->npins);
+
+    prop = get_dtb_prop(node, "#gpio-int-groups");
+    s->nirqgrps = *(uint32_t *)prop->value;
+    s->irqs = g_new(qemu_irq, s->nirqgrps);
+
+    for (i = 0; i < s->nirqgrps; i++) {
+        sysbus_init_irq(sbd, &s->irqs[i]);
+    }
+
+    prop = get_dtb_prop(node, "AAPL,phandle");
+    assert(prop);
+
+    s->phandle = *(uint32_t *)prop->value;
+
+    return dev;
+}
+
+static void apple_gpio_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    dc->realize = apple_gpio_realize;
+    dc->reset = apple_gpio_reset;
+    dc->desc = "Apple General Purpose Input/Output Controller";
+}
+
+static const TypeInfo apple_gpio_info = {
+    .name = TYPE_APPLE_GPIO,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(AppleGPIOState),
+    .class_init = apple_gpio_class_init,
+};
+
+static void apple_gpio_register_types(void)
+{
+    type_register_static(&apple_gpio_info);
+}
+
+type_init(apple_gpio_register_types);
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/gpio/meson.build qemu-t8030-private/hw/gpio/meson.build
--- qemu-6.0.0/hw/gpio/meson.build	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/hw/gpio/meson.build	2021-05-05 23:07:27.965974100 +0800
@@ -1,3 +1,5 @@
+specific_ss.add(when: ['CONFIG_SOFTMMU', 'TARGET_AARCH64'], if_true: files('apple_gpio.c'))
+
 softmmu_ss.add(when: 'CONFIG_E500', if_true: files('mpc8xxx.c'))
 softmmu_ss.add(when: 'CONFIG_GPIO_KEY', if_true: files('gpio_key.c'))
 softmmu_ss.add(when: 'CONFIG_GPIO_PWR', if_true: files('gpio_pwr.c'))
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/i2c/apple_i2c.c qemu-t8030-private/hw/i2c/apple_i2c.c
--- qemu-6.0.0/hw/i2c/apple_i2c.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/i2c/apple_i2c.c	2021-05-05 23:41:24.643100600 +0800
@@ -0,0 +1,103 @@
+#include "qemu/osdep.h"
+#include "hw/i2c/apple_i2c.h"
+#include "hw/i2c/i2c.h"
+#include "hw/i2c/bitbang_i2c.h"
+#include "hw/irq.h"
+#include "migration/vmstate.h"
+#include "qemu/bitops.h"
+#include "qemu/lockable.h"
+#include "qemu/log.h"
+#include "qemu/module.h"
+#include "qemu/timer.h"
+#include "hw/arm/xnu_dtb.h"
+
+static void apple_i2c_gpio_set(void *opaque, int line, int level)
+{
+    AppleI2CState *s = APPLE_I2C(opaque);
+
+    level = bitbang_i2c_set(&s->bitbang, line, level);
+    if (level != s->last_level) {
+        s->last_level = level;
+        qemu_set_irq(s->out, level);
+    }
+}
+
+static void i2c_reg_write(void *opaque,
+                  hwaddr addr,
+                  uint64_t data,
+                  unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "I2C: reg WRITE @ 0x" TARGET_FMT_plx
+                  " value: 0x" TARGET_FMT_plx "\n", addr, data);
+}
+
+static uint64_t i2c_reg_read(void *opaque,
+                     hwaddr addr,
+                     unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "I2C: reg READ @ 0x" TARGET_FMT_plx "\n", addr);
+
+    return 0;
+}
+
+static const MemoryRegionOps i2c_reg_ops = {
+    .write = i2c_reg_write,
+    .read = i2c_reg_read,
+    .valid.min_access_size = 4,
+    .valid.max_access_size = 4,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+DeviceState *apple_i2c_create(DTBNode *node)
+{
+    DeviceState *dev = qdev_new(TYPE_APPLE_I2C);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
+    AppleI2CState *s = APPLE_I2C(dev);
+    DTBProp *prop = get_dtb_prop(node, "reg");
+    uint64_t mmio_size = ((hwaddr *)prop->value)[1];
+    char bus_name[32] = { 0 };
+
+    prop = get_dtb_prop(node, "name");
+    dev->id = g_strdup((const char *)prop->value);
+    memory_region_init_io(&s->iomem, OBJECT(dev), &i2c_reg_ops, s,
+                          (const char *)prop->value, mmio_size);
+
+    snprintf(bus_name, sizeof(bus_name), "%s.bus", (const char *)prop->value);
+    s->bus = i2c_init_bus(dev, (const char *)bus_name);
+    sysbus_init_mmio(sbd, &s->iomem);
+
+    prop = get_dtb_prop(node, "compatible");
+    g_free(prop->value);
+    prop->value = (uint8_t *)g_strdup("iic,soft");
+    prop->length = 9;
+
+    qdev_init_gpio_in(dev, apple_i2c_gpio_set, 2);
+    qdev_init_gpio_out(dev, &s->out, 1);
+
+    sysbus_init_irq(sbd, &s->irq);
+
+    bitbang_i2c_init(&s->bitbang, s->bus);
+
+    return dev;
+}
+
+static void apple_i2c_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->desc = "Apple I2C Controller";
+}
+
+static const TypeInfo apple_i2c_type_info = {
+    .name = TYPE_APPLE_I2C,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(AppleI2CState),
+    .class_init = apple_i2c_class_init,
+};
+
+static void apple_i2c_register_types(void)
+{
+    type_register_static(&apple_i2c_type_info);
+}
+
+type_init(apple_i2c_register_types)
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/i2c/meson.build qemu-t8030-private/hw/i2c/meson.build
--- qemu-6.0.0/hw/i2c/meson.build	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/hw/i2c/meson.build	2021-05-05 10:12:53.587193100 +0800
@@ -1,3 +1,4 @@
+specific_ss.add(when: ['CONFIG_SOFTMMU', 'TARGET_AARCH64'], if_true: files('apple_i2c.c'))
 i2c_ss = ss.source_set()
 i2c_ss.add(when: 'CONFIG_I2C', if_true: files('core.c'))
 i2c_ss.add(when: 'CONFIG_SMBUS', if_true: files('smbus_slave.c', 'smbus_master.c'))
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/intc/apple_aic.c qemu-t8030-private/hw/intc/apple_aic.c
--- qemu-6.0.0/hw/intc/apple_aic.c	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/hw/intc/apple_aic.c	2021-05-05 23:30:21.451243600 +0800
@@ -0,0 +1,493 @@
+#include "qemu/osdep.h"
+#include "hw/intc/apple_aic.h"
+#include "trace.h"
+#include "hw/irq.h"
+#include "migration/vmstate.h"
+#include "qemu/bitops.h"
+#include "qemu/lockable.h"
+#include "qemu/log.h"
+#include "qemu/module.h"
+#include "qemu/timer.h"
+#include "hw/arm/xnu_dtb.h"
+#include "hw/pci/msi.h"
+
+/*
+ * Check state and interrupt cpus, call with mutex locked
+ */
+static void apple_aic_update(AppleAICState *s)
+{
+    uint32_t intr = 0;
+    int i;
+
+    for (i = 0; i < s->numCPU; i++) {
+        s->cpus[i].pendingIPI |= s->cpus[i].deferredIPI;
+        s->cpus[i].deferredIPI = 0;
+    }
+
+    for (i = 0; i < s->numCPU; i++) {
+        if (s->cpus[i].pendingIPI & (~s->cpus[i].ipi_mask)) {
+            intr |= (1 << i);
+        }
+    }
+
+    for (i = 0; i < s->numEIR; i++) {
+        if (unlikely(s->eir_state[i] & (~s->eir_mask[i]))) {
+            int j;
+            for (j = 0; j < 32; j++) {
+                if (((s->eir_mask[i] & (1 << j)) == 0)
+                    && (s->eir_state[i] & (1 << j))
+                    && (s->eir_dest[AIC_EIR_TO_SRC(i, j)])
+                    && ((intr & (s->eir_dest[AIC_EIR_TO_SRC(i, j)])) == 0)) {
+                    uint32_t cpu = find_first_bit((unsigned long *)&s->eir_dest[AIC_EIR_TO_SRC(i, j)],
+                                                    s->numCPU);
+                    intr |= (1 << cpu);
+                }
+            }
+        }
+    }
+
+    for (i = 0; i < s->numCPU; i++) {
+        if (intr & (1 << i)) {
+            qemu_irq_raise(s->cpus[i].irq);
+        }
+    }
+}
+
+static void apple_aic_set_irq(void *opaque, int irq, int level)
+{
+    AppleAICState *s = APPLE_AIC(opaque);
+
+    WITH_QEMU_LOCK_GUARD(&s->mutex) {
+        trace_aic_set_irq(irq, level);
+        if (level) {
+            set_bit(irq, (unsigned long *)s->eir_state);
+        } else {
+            clear_bit(irq, (unsigned long *)s->eir_state);
+        }
+    }
+}
+
+static void apple_aic_tick(void *opaque)
+{
+    AppleAICState *s = APPLE_AIC(opaque);
+
+    WITH_QEMU_LOCK_GUARD(&s->mutex) {
+        apple_aic_update(s);
+    }
+
+    timer_mod_ns(s->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + kAICWT);
+}
+
+static void apple_aic_reset(DeviceState *dev)
+{
+    int i;
+    AppleAICState *s = APPLE_AIC(dev);
+
+    /* mask all IRQs */
+    memset(s->eir_mask, 0xffff, sizeof(uint32_t) * s->numEIR);
+    /* dest default to 0 */
+    memset(s->eir_dest, 0, sizeof(uint32_t) * s->numIRQ);
+
+    for (i = 0; i < s->numCPU; i++) {
+        /* mask all IPI */
+        s->cpus[i].ipi_mask = AIC_IPI_NORMAL | AIC_IPI_SELF;
+        s->cpus[i].pendingIPI = 0;
+        s->cpus[i].deferredIPI = 0;
+    }
+}
+
+static void apple_aic_write(void *opaque,
+                  hwaddr addr,
+                  uint64_t data,
+                  unsigned size)
+{
+    AppleAICOpaque *o = (AppleAICOpaque *)opaque;
+    AppleAICState *s = APPLE_AIC(o->aic);
+    uint32_t val = (uint32_t)data;
+
+    WITH_QEMU_LOCK_GUARD(&s->mutex) {
+        switch (addr) {
+        case rAIC_RST:
+            apple_aic_reset(DEVICE(s));
+            break;
+
+        case rAIC_GLB_CFG:
+            s->global_cfg = data;
+            break;
+
+        case rAIC_IPI_SET:
+            {
+                int i;
+
+                for (i = 0; i < s->numCPU; i++) {
+                    if (val & (1 << i)) {
+                        set_bit(o->cpu_id, (unsigned long *)&s->cpus[i].pendingIPI);
+                        if (~s->cpus[i].ipi_mask & AIC_IPI_NORMAL) {
+                            qemu_irq_raise(s->cpus[i].irq);
+                        }
+                    }
+                }
+
+                if (val & AIC_IPI_SELF) {
+                    set_bit(AIC_IPI_SELF, (unsigned long *)&o->pendingIPI);
+                    if (~o->ipi_mask & AIC_IPI_SELF) {
+                        qemu_irq_raise(o->irq);
+                    }
+                }
+            }
+            break;
+
+        case rAIC_IPI_CLR:
+            {
+                int i;
+
+                for (i = 0; i < s->numCPU; i++) {
+                    if (val & (1 << i)) {
+                        clear_bit(o->cpu_id, (unsigned long *)&s->cpus[i].pendingIPI);
+                    }
+                }
+
+                if (val & AIC_IPI_SELF) {
+                    clear_bit(AIC_IPI_SELF, (unsigned long *)&o->pendingIPI);
+                }
+            }
+            break;
+
+        case rAIC_IPI_MASK_SET:
+            o->ipi_mask |= (val & (AIC_IPI_NORMAL | AIC_IPI_SELF));
+            break;
+
+        case rAIC_IPI_MASK_CLR:
+            o->ipi_mask &= ~(val & (AIC_IPI_NORMAL | AIC_IPI_SELF));
+            break;
+
+        case rAIC_IPI_DEFER_SET:
+            {
+                int i;
+
+                for (i = 0; i < s->numCPU; i++) {
+                    if (val & (1 << i)) {
+                        set_bit(o->cpu_id, (unsigned long *)&s->cpus[i].deferredIPI);
+                    }
+                }
+
+                if (val & AIC_IPI_SELF) {
+                    set_bit(AIC_IPI_SELF, (unsigned long *)&o->deferredIPI);
+                }
+            }
+            break;
+
+        case rAIC_IPI_DEFER_CLR:
+            {
+                int i;
+
+                for (i = 0; i < s->numCPU; i++) {
+                    if (val & (1 << i)) {
+                        clear_bit(o->cpu_id, (unsigned long *)&s->cpus[i].deferredIPI);
+                    }
+                }
+
+                if (val & AIC_IPI_SELF) {
+                    clear_bit(AIC_IPI_SELF, (unsigned long *)&o->deferredIPI);
+                }
+            }
+            break;
+
+        case rAIC_EIR_DEST(0) ... rAIC_EIR_DEST(AIC_INT_COUNT):
+            {
+                uint32_t vector = (addr - rAIC_EIR_DEST(0)) / 4;
+                if (unlikely(vector >= s->numIRQ)) {
+                    break;
+                }
+                s->eir_dest[vector] = val;
+            }
+            break;
+
+        case rAIC_EIR_SW_SET(0) ... rAIC_EIR_SW_SET(kAIC_NUM_EIRS):
+            {
+                uint32_t eir = (addr - rAIC_EIR_SW_SET(0)) / 4;
+                if (unlikely(eir >= s->numEIR)) {
+                    break;
+                }
+                s->eir_state[eir] |= val;
+            }
+            break;
+
+        case rAIC_EIR_SW_CLR(0) ... rAIC_EIR_SW_CLR(kAIC_NUM_EIRS):
+            {
+                uint32_t eir = (addr - rAIC_EIR_SW_CLR(0)) / 4;
+                if (unlikely(eir >= s->numEIR)) {
+                    break;
+                }
+                s->eir_state[eir] &= ~val;
+            }
+            break;
+
+        case rAIC_EIR_MASK_SET(0) ... rAIC_EIR_MASK_SET(kAIC_NUM_EIRS):
+            {
+                uint32_t eir = (addr - rAIC_EIR_MASK_SET(0)) / 4;
+                if (unlikely(eir >= s->numEIR)) {
+                    break;
+                }
+                s->eir_mask[eir] |= val;
+            }
+            break;
+
+        case rAIC_EIR_MASK_CLR(0) ... rAIC_EIR_MASK_CLR(kAIC_NUM_EIRS):
+            {
+                uint32_t eir = (addr - rAIC_EIR_MASK_CLR(0)) / 4;
+                if (unlikely(eir >= s->numEIR)) {
+                    break;
+                }
+                s->eir_mask[eir] &= ~val;
+            }
+            break;
+
+        case rAIC_WHOAMI_Pn(0) ... rAIC_WHOAMI_Pn(AIC_CPU_COUNT) - 4:
+            {
+                uint32_t cpu = (addr - 0x5000) / 0x80;
+                if (unlikely(cpu > s->numCPU)) {
+                    break;
+                }
+                addr = addr - 0x5000 + 0x2000;
+                qemu_mutex_unlock(&s->mutex);
+                apple_aic_write(&s->cpus[cpu], addr, data, size);
+                qemu_mutex_lock(&s->mutex);
+            }
+            break;
+
+        default:
+            qemu_log_mask(LOG_UNIMP, "AIC: Write to unspported reg 0x" TARGET_FMT_plx
+                        " cpu %u\n", addr, o->cpu_id);
+            break;
+        }
+    }
+}
+
+static uint64_t apple_aic_read(void *opaque,
+                     hwaddr addr,
+                     unsigned size)
+{
+    AppleAICOpaque *o = (AppleAICOpaque *)opaque;
+    AppleAICState *s = APPLE_AIC(o->aic);
+
+    WITH_QEMU_LOCK_GUARD(&s->mutex) {
+        switch (addr) {
+        case rAIC_REV:
+            return 2;
+
+        case rAIC_CAP0:
+            return (((uint64_t)s->numCPU - 1) << 16) | (s->numIRQ);
+
+        case rAIC_GLB_CFG:
+            return s->global_cfg;
+
+        case rAIC_WHOAMI:
+            return o->cpu_id;
+
+        case rAIC_IACK:
+            {
+                int i;
+
+                qemu_irq_lower(o->irq);
+                if (o->pendingIPI & AIC_IPI_SELF & ~o->ipi_mask) {
+                    o->ipi_mask |= kAIC_INT_IPI_SELF;
+                    return kAIC_INT_IPI | kAIC_INT_IPI_SELF;
+                }
+
+                if (~o->ipi_mask & AIC_IPI_NORMAL) {
+
+                    for (i = 0; i < s->numCPU; i++) {
+                        if (o->pendingIPI & (1 << i)) {
+                            o->ipi_mask |= kAIC_INT_IPI_NORM;
+                            return kAIC_INT_IPI | kAIC_INT_IPI_NORM;
+                        }
+                    }
+                }
+
+                for (i = 0; i < s->numEIR; i++) {
+                    if (unlikely(s->eir_state[i] & (~s->eir_mask[i]))) {
+                        int j;
+
+                        for (j = 0; j < 32; j++) {
+                            if (((s->eir_mask[i] & (1 << j)) == 0)
+                                && (s->eir_state[i] & (1 << j))
+                                && (s->eir_dest[AIC_EIR_TO_SRC(i, j)] & (1 << o->cpu_id))) {
+                                s->eir_mask[i] |= (1 << j);
+                                return kAIC_INT_EXT | AIC_EIR_TO_SRC(i, j);
+                            }
+                        }
+                    }
+                }
+                return kAIC_INT_SPURIOUS;
+            }
+
+        case rAIC_EIR_DEST(0) ... rAIC_EIR_DEST(AIC_INT_COUNT):
+            {
+                uint32_t vector = (addr - rAIC_EIR_DEST(0)) / 4;
+
+                if (unlikely(vector >= s->numIRQ)) {
+                    break;
+                }
+
+                return s->eir_dest[vector];
+            }
+
+        case rAIC_EIR_MASK_SET(0) ... rAIC_EIR_MASK_SET(kAIC_NUM_EIRS):
+            {
+                uint32_t eir = (addr - rAIC_EIR_MASK_SET(0)) / 4;
+
+                if (unlikely(eir >= s->numEIR)) {
+                    break;
+                }
+
+                return s->eir_mask[eir];
+            }
+
+        case rAIC_EIR_MASK_CLR(0) ... rAIC_EIR_MASK_CLR(kAIC_NUM_EIRS):
+            {
+                uint32_t eir = (addr - rAIC_EIR_MASK_CLR(0)) / 4;
+
+                if (unlikely(eir >= s->numEIR)) {
+                    break;
+                }
+
+                return s->eir_mask[eir];
+            }
+
+        case rAIC_EIR_INT_RO(0) ... rAIC_EIR_INT_RO(kAIC_NUM_EIRS):
+            {
+                uint32_t eir = (addr - rAIC_EIR_INT_RO(0)) / 4;
+
+                if (unlikely(eir >= s->numEIR)) {
+                    break;
+                }
+                return s->eir_state[eir];
+            }
+
+        case rAIC_WHOAMI_Pn(0) ... rAIC_WHOAMI_Pn(AIC_CPU_COUNT) - 4:
+            {
+                uint32_t cpu = (addr - 0x5000) / 0x80;
+                uint64_t val;
+
+                if (unlikely(cpu > s->numCPU)) {
+                    break;
+                }
+
+                addr = addr - 0x5000 + 0x2000;
+                qemu_mutex_unlock(&s->mutex);
+
+                val = apple_aic_read(&s->cpus[cpu], addr, size);
+                qemu_mutex_lock(&s->mutex);
+                return val;
+            }
+        default:
+            qemu_log_mask(LOG_UNIMP,
+                          "AIC: Read from unspported reg 0x" TARGET_FMT_plx
+                          " cpu: %u\n", addr, o->cpu_id);
+        }
+    }
+    return -1;
+}
+
+static const MemoryRegionOps apple_aic_ops = {
+    .read = apple_aic_read,
+    .write = apple_aic_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl.min_access_size = 4,
+    .impl.max_access_size = 4,
+    .valid.min_access_size = 4,
+    .valid.max_access_size = 4,
+    .valid.unaligned = false,
+};
+
+static void apple_aic_init(Object *obj)
+{
+    AppleAICState *s = APPLE_AIC(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    int i;
+
+    qemu_mutex_init(&s->mutex);
+    s->cpus = g_new0(AppleAICOpaque, s->numCPU);
+
+    for (i = 0; i < s->numCPU; i++) {
+        AppleAICOpaque *opaque = &s->cpus[i];
+
+        opaque->aic = s;
+        opaque->cpu_id = i;
+        memory_region_init_io(&opaque->iomem, obj, &apple_aic_ops, opaque,
+                                TYPE_APPLE_AIC, s->base_size);
+        sysbus_init_mmio(sbd, &opaque->iomem);
+        sysbus_init_irq(sbd, &opaque->irq);
+    }
+
+    qdev_init_gpio_in(DEVICE(obj), apple_aic_set_irq, s->numIRQ);
+    assert(s->numCPU > 0);
+
+    s->eir_mask = g_malloc0(sizeof(uint32_t) * s->numEIR);
+    s->eir_dest = g_malloc0(sizeof(uint32_t) * s->numIRQ);
+    s->eir_state = g_malloc0(sizeof(bool) * s->numIRQ);
+}
+
+static void apple_aic_realize(DeviceState *dev, Error **errp)
+{
+    AppleAICState *s = APPLE_AIC(dev);
+
+    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, apple_aic_tick, dev);
+    timer_mod_ns(s->timer, kAICWT);
+    apple_aic_reset(dev);
+    msi_nonbroken = true;
+}
+
+SysBusDevice *apple_aic_create(uint32_t numCPU, DTBNode *node)
+{
+    DeviceState  *dev;
+    AppleAICState *s;
+    DTBProp *prop;
+    hwaddr *reg;
+
+    dev = qdev_new(TYPE_APPLE_AIC);
+    s = APPLE_AIC(dev);
+    prop = get_dtb_prop(node, "reg");
+    assert(prop != NULL);
+    reg = (hwaddr *)prop->value;
+    s->base_size = reg[1];
+    prop = get_dtb_prop(node, "ipid-mask");
+    s->numEIR = prop->length / 4;
+    s->numIRQ = s->numEIR * 32;
+
+    s->numCPU = numCPU;
+    overwrite_dtb_prop(node, "#main-cpus", 4, (uint8_t *)&s->numCPU);
+
+    prop = get_dtb_prop(node, "#shared-timestamps");
+    assert(prop);
+    assert(prop->length == 4);
+
+    *(uint32_t *)prop->value = 0;
+    apple_aic_init(OBJECT(dev));
+
+    return SYS_BUS_DEVICE(dev);
+}
+
+static void apple_aic_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = apple_aic_realize;
+    dc->reset = apple_aic_reset;
+    dc->desc = "Apple Interrupt Controller";
+}
+
+static const TypeInfo apple_aic_info = {
+    .name = TYPE_APPLE_AIC,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(AppleAICState),
+    .class_init = apple_aic_class_init,
+};
+
+static void apple_aic_register_types(void)
+{
+    type_register_static(&apple_aic_info);
+}
+
+type_init(apple_aic_register_types);
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/intc/meson.build qemu-t8030-private/hw/intc/meson.build
--- qemu-6.0.0/hw/intc/meson.build	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/hw/intc/meson.build	2021-05-05 10:17:23.546001200 +0800
@@ -24,6 +24,7 @@ softmmu_ss.add(when: 'CONFIG_XILINX', if
 softmmu_ss.add(when: 'CONFIG_XLNX_ZYNQMP', if_true: files('xlnx-zynqmp-ipi.c'))
 softmmu_ss.add(when: 'CONFIG_XLNX_ZYNQMP_PMU', if_true: files('xlnx-pmu-iomod-intc.c'))
 
+specific_ss.add(when: ['CONFIG_SOFTMMU', 'TARGET_AARCH64'], if_true: files('apple_aic.c'))
 specific_ss.add(when: 'CONFIG_ALLWINNER_A10_PIC', if_true: files('allwinner-a10-pic.c'))
 specific_ss.add(when: 'CONFIG_APIC', if_true: files('apic.c', 'apic_common.c'))
 specific_ss.add(when: 'CONFIG_ARM_GIC', if_true: files('arm_gicv3_cpuif.c'))
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/hw/intc/trace-events qemu-t8030-private/hw/intc/trace-events
--- qemu-6.0.0/hw/intc/trace-events	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/hw/intc/trace-events	2021-05-05 10:17:32.251535400 +0800
@@ -204,6 +204,11 @@ heathrow_set_irq(int num, int level) "se
 bcm2835_ic_set_gpu_irq(int irq, int level) "GPU irq #%d level %d"
 bcm2835_ic_set_cpu_irq(int irq, int level) "CPU irq #%d level %d"
 
+# apple_aic.c
+aic_enable_irq(int irq) "AIC: Enabling IRQ %d"
+aic_disable_irq(int irq) "AIC: Disabling IRQ %d"
+aic_set_irq(int irq, int level) "AIC: External IRQ %d level set to %d"
+
 # spapr_xive.c
 spapr_xive_claim_irq(uint32_t lisn, bool lsi) "lisn=0x%x lsi=%d"
 spapr_xive_free_irq(uint32_t lisn) "lisn=0x%x"
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/block/nvme.h qemu-t8030-private/include/block/nvme.h
--- qemu-6.0.0/include/block/nvme.h	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/include/block/nvme.h	2021-05-05 10:12:54.380847200 +0800
@@ -566,6 +566,7 @@ enum NvmeAdminCommands {
     NVME_ADM_CMD_ASYNC_EV_REQ   = 0x0c,
     NVME_ADM_CMD_ACTIVATE_FW    = 0x10,
     NVME_ADM_CMD_DOWNLOAD_FW    = 0x11,
+    NVME_ADM_CMD_TUNNEL         = 0xd8,
     NVME_ADM_CMD_NS_ATTACHMENT  = 0x15,
     NVME_ADM_CMD_FORMAT_NVM     = 0x80,
     NVME_ADM_CMD_SECURITY_SEND  = 0x81,
@@ -1050,7 +1051,9 @@ typedef struct QEMU_PACKED NvmeIdCtrl {
     uint8_t     subnqn[256];
     uint8_t     rsvd1024[1024];
     NvmePSD     psd[32];
-    uint8_t     vs[1024];
+    uint8_t     rsvd3072[518];
+	uint16_t	capacity;
+	uint8_t		vs[504];
 } NvmeIdCtrl;
 
 typedef struct NvmeIdCtrlZoned {
@@ -1262,7 +1265,8 @@ typedef struct QEMU_PACKED NvmeIdNs {
     uint64_t    eui64;
     NvmeLBAF    lbaf[16];
     uint8_t     rsvd192[192];
-    uint8_t     vs[3712];
+    uint32_t    nstype;
+    uint8_t     vs[3708];
 } NvmeIdNs;
 
 typedef struct QEMU_PACKED NvmeIdNsDescr {
@@ -1447,4 +1451,14 @@ static inline void _nvme_check_size(void
     QEMU_BUILD_BUG_ON(sizeof(NvmeZoneDescr) != 64);
     QEMU_BUILD_BUG_ON(sizeof(NvmeDifTuple) != 8);
 }
+
+#define NVME_APPLE_MAX_PEND_CMDS		0x1210
+#define   NVME_APPLE_MAX_PEND_CMDS_VAL	((64 << 16) | 64)
+#define NVME_APPLE_BOOT_STATUS		    0x1300
+#define   NVME_APPLE_BOOT_STATUS_OK		0xde71ce55
+#define NVME_APPLE_BASE_CMD_ID		    0x1308
+#define   NVME_APPLE_BASE_CMD_ID_MASK	0xffff
+#define NVME_APPLE_LINEAR_SQ_CTRL		0x24908
+#define   NVME_APPLE_LINEAR_SQ_CTRL_EN	(1 << 0)
+#define NVME_APPLE_MODESEL              0x1304
 #endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/exec/exec-all.h qemu-t8030-private/include/exec/exec-all.h
--- qemu-6.0.0/include/exec/exec-all.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/include/exec/exec-all.h	2021-05-05 10:12:54.413999100 +0800
@@ -447,7 +447,7 @@ struct tb_tc {
 struct TranslationBlock {
     target_ulong pc;   /* simulated PC corresponding to this block (EIP + CS base) */
     target_ulong cs_base; /* CS base for this block */
-    uint32_t flags; /* flags defining in which context the code was generated */
+    uint64_t flags; /* flags defining in which context the code was generated */
     uint32_t cflags;    /* compile flags */
 #define CF_COUNT_MASK  0x00007fff
 #define CF_LAST_IO     0x00008000 /* Last insn may be an IO access.  */
@@ -535,7 +535,7 @@ void tb_invalidate_phys_addr(AddressSpac
 void tb_flush(CPUState *cpu);
 void tb_phys_invalidate(TranslationBlock *tb, tb_page_addr_t page_addr);
 TranslationBlock *tb_htable_lookup(CPUState *cpu, target_ulong pc,
-                                   target_ulong cs_base, uint32_t flags,
+                                   target_ulong cs_base, uint64_t flags,
                                    uint32_t cflags);
 void tb_set_jmp_target(TranslationBlock *tb, int n, uintptr_t addr);
 
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/exec/tb-hash.h qemu-t8030-private/include/exec/tb-hash.h
--- qemu-6.0.0/include/exec/tb-hash.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/include/exec/tb-hash.h	2021-05-05 10:12:54.431713100 +0800
@@ -60,10 +60,10 @@ static inline unsigned int tb_jmp_cache_
 #endif /* CONFIG_SOFTMMU */
 
 static inline
-uint32_t tb_hash_func(tb_page_addr_t phys_pc, target_ulong pc, uint32_t flags,
+uint32_t tb_hash_func(tb_page_addr_t phys_pc, target_ulong pc, uint64_t flags,
                       uint32_t cf_mask, uint32_t trace_vcpu_dstate)
 {
-    return qemu_xxhash7(phys_pc, pc, flags, cf_mask, trace_vcpu_dstate);
+    return qemu_xxhash8(phys_pc, pc, flags, cf_mask, trace_vcpu_dstate);
 }
 
 #endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/exec/tb-lookup.h qemu-t8030-private/include/exec/tb-lookup.h
--- qemu-6.0.0/include/exec/tb-lookup.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/include/exec/tb-lookup.h	2021-05-05 10:12:54.431713100 +0800
@@ -19,7 +19,7 @@
 /* Might cause an exception, so have a longjmp destination ready */
 static inline TranslationBlock *tb_lookup(CPUState *cpu, target_ulong pc,
                                           target_ulong cs_base,
-                                          uint32_t flags, uint32_t cflags)
+                                          uint64_t flags, uint32_t cflags)
 {
     TranslationBlock *tb;
     uint32_t hash;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/arm/t8030.h qemu-t8030-private/include/hw/arm/t8030.h
--- qemu-6.0.0/include/hw/arm/t8030.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/arm/t8030.h	2021-05-05 10:12:54.476858300 +0800
@@ -0,0 +1,221 @@
+/*
+ * iPhone 11 - t8030
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ * Copyright (c) 2021 Nguyen Hoang Trung (TrungNguyen1909)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef HW_ARM_T8030_H
+#define HW_ARM_T8030_H
+
+#include "qemu-common.h"
+#include "exec/hwaddr.h"
+#include "hw/boards.h"
+#include "hw/arm/boot.h"
+#include "hw/arm/xnu.h"
+#include "exec/memory.h"
+#include "cpu.h"
+#include "sysemu/kvm.h"
+
+#define TYPE_T8030 "t8030"
+
+#define TYPE_T8030_MACHINE MACHINE_TYPE_NAME(TYPE_T8030)
+
+#define T8030_MACHINE(obj) \
+    OBJECT_CHECK(T8030MachineState, (obj), TYPE_T8030_MACHINE)
+
+#define T8030_CPREG_VAR_NAME(name) cpreg_##name
+#define T8030_CPREG_VAR_DEF(name) uint64_t T8030_CPREG_VAR_NAME(name)
+
+#define MAX_CPU 6
+#define MAX_CLUSTER 2
+#define NUM_ECORE 2
+#define NUM_PCORE 4
+typedef struct
+{
+    MachineClass parent;
+} T8030MachineClass;
+
+typedef struct T8030CPUState{
+    ARMCPU* cpu;
+    AddressSpace* nsas;
+    MemoryRegion* impl_reg;
+    MemoryRegion* coresight_reg;
+    MemoryRegion* memory;
+    MemoryRegion* sysmem;
+    MachineState* machine;
+    uint32_t cpu_id;
+    uint32_t phys_id;
+    uint32_t cluster_id;
+    uint64_t mpidr;
+    uint64_t ipi_sr;
+    qemu_irq fast_ipi;
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID11);
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID13);
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID14);
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID3);
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID5);
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID4);
+    T8030_CPREG_VAR_DEF(ARM64_REG_EHID4);
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID8);
+    T8030_CPREG_VAR_DEF(ARM64_REG_HID7);
+    T8030_CPREG_VAR_DEF(ARM64_REG_LSU_ERR_STS);
+    T8030_CPREG_VAR_DEF(PMC0);
+    T8030_CPREG_VAR_DEF(PMC1);
+    T8030_CPREG_VAR_DEF(PMCR1);
+    T8030_CPREG_VAR_DEF(PMSR);
+    T8030_CPREG_VAR_DEF(ARM64_REG_APCTL_EL1);
+    T8030_CPREG_VAR_DEF(ARM64_REG_KERNELKEYLO_EL1);
+    T8030_CPREG_VAR_DEF(ARM64_REG_KERNELKEYHI_EL1);
+    T8030_CPREG_VAR_DEF(S3_4_c15_c0_5);
+    T8030_CPREG_VAR_DEF(S3_4_c15_c1_3);
+    T8030_CPREG_VAR_DEF(S3_4_c15_c1_4);
+    T8030_CPREG_VAR_DEF(ARM64_REG_CYC_OVRD);
+    T8030_CPREG_VAR_DEF(ARM64_REG_ACC_CFG);
+    //SPRR
+    T8030_CPREG_VAR_DEF(S3_6_c15_c1_0);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c1_1);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c1_2);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c1_5);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c1_6);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c1_7);
+    T8030_CPREG_VAR_DEF(APRR_EL1);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c3_1);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c8_0);
+    T8030_CPREG_VAR_DEF(GXF_ENTRY_EL1);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c8_2);
+    T8030_CPREG_VAR_DEF(S3_6_c15_c8_3);
+    //uncore
+    T8030_CPREG_VAR_DEF(UPMPCM);
+    T8030_CPREG_VAR_DEF(UPMCR0);
+    T8030_CPREG_VAR_DEF(UPMSR);
+    //ktrr
+    T8030_CPREG_VAR_DEF(ARM64_REG_CTRR_A_LWR_EL1);
+    T8030_CPREG_VAR_DEF(ARM64_REG_CTRR_A_UPR_EL1);
+    T8030_CPREG_VAR_DEF(ARM64_REG_CTRR_CTL_EL1);
+    T8030_CPREG_VAR_DEF(ARM64_REG_CTRR_LOCK_EL1);
+} T8030CPUState;
+
+#define MPIDR_AFF0_SHIFT 0
+#define MPIDR_AFF0_WIDTH 8
+#define MPIDR_AFF0_MASK  (((1 << MPIDR_AFF0_WIDTH) - 1) << MPIDR_AFF0_SHIFT)
+#define MPIDR_AFF1_SHIFT 8
+#define MPIDR_AFF1_WIDTH 8
+#define MPIDR_AFF1_MASK  (((1 << MPIDR_AFF1_WIDTH) - 1) << MPIDR_AFF1_SHIFT)
+#define MPIDR_AFF2_SHIFT 16
+#define MPIDR_AFF2_WIDTH 8
+#define MPIDR_AFF2_MASK  (((1 << MPIDR_AFF2_WIDTH) - 1) << MPIDR_AFF2_SHIFT)
+
+#define MPIDR_CPU_ID(mpidr_el1_val)             (((mpidr_el1_val) & MPIDR_AFF0_MASK) >> MPIDR_AFF0_SHIFT)
+#define MPIDR_CLUSTER_ID(mpidr_el1_val)         (((mpidr_el1_val) & MPIDR_AFF1_MASK) >> MPIDR_AFF1_SHIFT)
+
+#define IPI_SR_SRC_CPU_SHIFT 8
+#define IPI_SR_SRC_CPU_WIDTH 8
+#define IPI_SR_SRC_CPU_MASK  (((1 << IPI_SR_SRC_CPU_WIDTH) - 1) << IPI_SR_SRC_CPU_SHIFT)
+#define IPI_SR_SRC_CPU(ipi_sr_val)         (((ipi_sr_val) & IPI_SR_SRC_CPU_MASK) >> IPI_SR_SRC_CPU_SHIFT)
+
+#define IPI_RR_TARGET_CLUSTER_SHIFT 16
+#define ARM64_REG_IPI_RR_TYPE_IMMEDIATE (0 << 28)
+#define ARM64_REG_IPI_RR_TYPE_RETRACT   (1 << 28)
+#define ARM64_REG_IPI_RR_TYPE_DEFERRED  (2 << 28)
+#define ARM64_REG_IPI_RR_TYPE_NOWAKE    (3 << 28)
+
+typedef struct {
+    QemuMutex mutex;
+    hwaddr base;
+    uint8_t id;
+    uint8_t type;
+    MemoryRegion* mr;
+    MachineState* machine;
+    T8030CPUState* cpus[MAX_CPU];
+    int deferredIPI[MAX_CPU][MAX_CPU];
+    int noWakeIPI[MAX_CPU][MAX_CPU];
+    uint64_t tick;
+} cluster;
+
+#define kDeferredIPITimerDefault 64000
+
+typedef struct
+{
+    MachineState parent;
+    hwaddr extra_data_pa;
+    hwaddr kpc_pa;
+    hwaddr kbootargs_pa;
+    hwaddr soc_base_pa;
+    hwaddr soc_size;
+    hwaddr dram_base;
+    unsigned long dram_size;
+    T8030CPUState* cpus[MAX_CPU];
+    cluster* clusters[MAX_CLUSTER];
+    QEMUTimer* ipicr_timer;
+    uint64_t ipi_cr;
+    //store the pending IPI_SR value
+    uint64_t pendingIPI[MAX_CPU];
+    bool pendingWakeup[MAX_CPU];
+    SysBusDevice* aic;
+    SysBusDevice* ans;
+    MemoryRegion* sysmem;
+    struct arm_boot_info bootinfo;
+    char ramdisk_filename[1024];
+    char kernel_filename[1024];
+    char dtb_filename[1024];
+    char driver_filename[1024];
+    char trustcache_filename[1024];
+    char kern_args[1024];
+    FileMmioDev ramdisk_file_dev;
+    DTBNode *device_tree;
+    bool use_ramfb;
+    QemuMutex mutex;
+} T8030MachineState;
+
+typedef struct
+{
+    uint8_t ramfb[RAMFB_SIZE];
+} __attribute__((packed)) AllocatedData;
+
+#define NSEC_PER_USEC   1000ull         /* nanoseconds per microsecond */
+#define USEC_PER_SEC    1000000ull      /* microseconds per second */
+#define NSEC_PER_SEC    1000000000ull   /* nanoseconds per second */
+#define NSEC_PER_MSEC   1000000ull      /* nanoseconds per millisecond */
+#define RTCLOCK_SEC_DIVISOR     24000000ull
+
+static void
+absolutetime_to_nanoseconds(uint64_t   abstime,
+    uint64_t * result)
+{
+	uint64_t        t64;
+
+	*result = (t64 = abstime / RTCLOCK_SEC_DIVISOR) * NSEC_PER_SEC;
+	abstime -= (t64 * RTCLOCK_SEC_DIVISOR);
+	*result += (abstime * NSEC_PER_SEC) / RTCLOCK_SEC_DIVISOR;
+}
+
+static void
+nanoseconds_to_absolutetime(uint64_t   nanosecs,
+    uint64_t * result)
+{
+	uint64_t        t64;
+
+	*result = (t64 = nanosecs / NSEC_PER_SEC) * RTCLOCK_SEC_DIVISOR;
+	nanosecs -= (t64 * NSEC_PER_SEC);
+	*result += (nanosecs * RTCLOCK_SEC_DIVISOR) / NSEC_PER_SEC;
+}
+#endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/arm/xnu.h qemu-t8030-private/include/hw/arm/xnu.h
--- qemu-6.0.0/include/hw/arm/xnu.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/arm/xnu.h	2021-05-05 10:12:54.479823800 +0800
@@ -0,0 +1,151 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef HW_ARM_XNU_H
+#define HW_ARM_XNU_H
+
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "hw/arm/xnu_mem.h"
+#include "hw/arm/xnu_dtb.h"
+#include "hw/arm/xnu_file_mmio_dev.h"
+#include "hw/arm/xnu_fb_cfg.h"
+
+// pexpert/pexpert/arm64/boot.h
+#define xnu_arm64_kBootArgsRevision2 2 /* added boot_args.bootFlags */
+#define xnu_arm64_kBootArgsVersion2 2
+#define xnu_arm64_BOOT_LINE_LENGTH 608
+
+#define LC_SEGMENT_64   0x19
+#define LC_UNIXTHREAD   0x5
+
+struct segment_command_64
+{
+    uint32_t cmd;
+    uint32_t cmdsize;
+    char segname[16];
+    uint64_t vmaddr;
+    uint64_t vmsize;
+    uint64_t fileoff;
+    uint64_t filesize;
+    uint32_t /*vm_prot_t*/ maxprot;
+    uint32_t /*vm_prot_t*/ initprot;
+    uint32_t nsects;
+    uint32_t flags;
+};
+
+#define MACH_MAGIC_64   0xFEEDFACFu
+
+struct mach_header_64 {
+    uint32_t    magic;      /* mach magic number identifier */
+    uint32_t /*cpu_type_t*/  cputype;    /* cpu specifier */
+    uint32_t /*cpu_subtype_t*/   cpusubtype; /* machine specifier */
+    uint32_t    filetype;   /* type of file */
+    uint32_t    ncmds;      /* number of load commands */
+    uint32_t    sizeofcmds; /* the size of all the load commands */
+    uint32_t    flags;      /* flags */
+    uint32_t    reserved;   /* reserved */
+};
+
+struct load_command {
+    uint32_t cmd;       /* type of load command */
+    uint32_t cmdsize;   /* total size of command in bytes */
+};
+
+typedef struct xnu_arm64_video_boot_args {
+    unsigned long v_baseAddr; /* Base address of video memory */
+    unsigned long v_display;  /* Display Code (if Applicable */
+    unsigned long v_rowBytes; /* Number of bytes per pixel row */
+    unsigned long v_width;    /* Width */
+    unsigned long v_height;   /* Height */
+    unsigned long v_depth;    /* Pixel Depth and other parameters */
+} video_boot_args;
+
+typedef struct xnu_arm64_monitor_boot_args {
+	uint64_t	version;                        /* structure version - this is version 2 */
+	uint64_t	virtBase;                       /* virtual base of memory assigned to the monitor */
+	uint64_t	physBase;                       /* physical address corresponding to the virtual base */
+	uint64_t	memSize;                        /* size of memory assigned to the monitor */
+	uint64_t	kernArgs;                       /* physical address of the kernel boot_args structure */
+	uint64_t	kernEntry;                      /* kernel entrypoint */
+	uint64_t	kernPhysBase;                   /* physical base of the kernel's address space */
+	uint64_t	kernPhysSlide;                  /* offset from kernPhysBase to kernel load address */
+	uint64_t	kernVirtSlide;                  /* virtual slide applied to kernel at load time */
+} monitor_boot_args;
+
+struct xnu_arm64_boot_args {
+    uint16_t           Revision;                                   /* Revision of boot_args structure */
+    uint16_t           Version;                                    /* Version of boot_args structure */
+    uint64_t           virtBase;                                   /* Virtual base of memory */
+    uint64_t           physBase;                                   /* Physical base of memory */
+    uint64_t           memSize;                                    /* Size of memory */
+    uint64_t           topOfKernelData;                            /* Highest physical address used in kernel data area */
+    video_boot_args    Video;                                      /* Video Information */
+    uint32_t           machineType;                                /* Machine Type */
+    uint64_t           deviceTreeP;                                /* Base of flattened device tree */
+    uint32_t           deviceTreeLength;                           /* Length of flattened tree */
+    char               CommandLine[xnu_arm64_BOOT_LINE_LENGTH];    /* Passed in command line */
+    uint64_t           bootFlags;                                  /* Additional flags specified by the bootloader */
+    uint64_t           memSizeActual;                              /* Actual size of memory */
+};
+
+void macho_file_highest_lowest(const char *filename, hwaddr *lowest,
+                                    hwaddr *highest);
+
+void macho_tz_setup_bootargs(const char *name, AddressSpace *as,
+                             MemoryRegion *mem, hwaddr bootargs_addr,
+                             hwaddr virt_base, hwaddr phys_base,
+                             hwaddr mem_size, hwaddr kern_args,
+                             hwaddr kern_entry, hwaddr kern_phys_base);
+
+void macho_setup_bootargs(const char *name, AddressSpace *as,
+                          MemoryRegion *mem, hwaddr bootargs_pa,
+                          hwaddr virt_base, hwaddr phys_base, hwaddr mem_size,
+                          hwaddr top_of_kernel_data_pa, hwaddr dtb_va,
+                          hwaddr dtb_size, video_boot_args v_bootargs,
+                          char *kern_args);
+
+void arm_load_macho(char *filename, AddressSpace *as, MemoryRegion *mem,
+                    const char *name, hwaddr phys_base, hwaddr virt_base, hwaddr *pc);
+
+void macho_map_raw_file(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                         const char *name, hwaddr file_pa, uint64_t *size);
+
+void macho_load_raw_file(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                         const char *name, hwaddr file_pa, uint64_t *size);
+                         
+DTBNode* load_dtb_from_file(char *filename);
+
+void macho_load_dtb(DTBNode *root, AddressSpace *as, MemoryRegion *mem,
+                    const char *name, hwaddr dtb_pa, uint64_t *size,
+                    hwaddr ramdisk_addr, hwaddr ramdisk_size,
+                    hwaddr trustcache_addr, hwaddr trustcache_size,
+                    hwaddr bootargs_addr,
+                    hwaddr dram_base, unsigned long dram_size,
+                    void* nvram_data, unsigned long nvram_size);
+
+void macho_load_trustcache(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                            hwaddr pa, uint64_t *size);
+void macho_load_ramdisk(const char *filename, AddressSpace *as, MemoryRegion *mem,
+                            hwaddr pa, uint64_t *size);
+#endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/arm/xnu_dtb.h qemu-t8030-private/include/hw/arm/xnu_dtb.h
--- qemu-6.0.0/include/hw/arm/xnu_dtb.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/arm/xnu_dtb.h	2021-05-05 10:12:54.479823800 +0800
@@ -0,0 +1,60 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef HW_ARM_XNU_DTB_H
+#define HW_ARM_XNU_DTB_H
+
+#include "qemu-common.h"
+
+#define DT_PROP_FLAG_PLACEHOLDER (0x80000000)
+
+#define DTB_PROP_NAME_LEN (32)
+
+typedef struct {
+    uint8_t name[DTB_PROP_NAME_LEN];
+    uint32_t length;
+    uint8_t *value;
+} DTBProp;
+
+typedef struct {
+    uint32_t prop_count;
+    uint32_t child_node_count;
+    GList *props;
+    GList *child_nodes;
+} DTBNode;
+
+DTBNode *load_dtb(uint8_t *dtb_blob);
+void delete_dtb_node(DTBNode *node);
+void save_dtb(uint8_t *buf, DTBNode *root);
+void remove_dtb_node(DTBNode *node, DTBNode *child);
+void remove_dtb_prop(DTBNode *node, DTBProp *prop);
+DTBProp *add_dtb_prop(DTBNode *n, const char *name, uint32_t size, uint8_t *val);
+DTBNode *add_dtb_node(DTBNode *n, const char *name);
+uint64_t get_dtb_node_buffer_size(DTBNode *node);
+DTBProp *get_dtb_prop(DTBNode *node, const char *name);
+DTBNode *get_dtb_child_node_by_name(DTBNode *node, const char *name);
+void overwrite_dtb_prop_val(DTBProp *prop, uint8_t chr);
+void overwrite_dtb_prop_name(DTBProp *prop, uint8_t chr);
+void overwrite_dtb_prop(DTBNode *n, const char *name, uint32_t size, uint8_t *val);
+
+#endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/arm/xnu_fb_cfg.h qemu-t8030-private/include/hw/arm/xnu_fb_cfg.h
--- qemu-6.0.0/include/hw/arm/xnu_fb_cfg.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/arm/xnu_fb_cfg.h	2021-05-05 10:12:54.480845900 +0800
@@ -0,0 +1,17 @@
+#ifndef HW_ARM_XNU_RAMFB_CFG_H
+#define HW_ARM_XNU_RAMFB_CFG_H
+
+#include "qemu/osdep.h"
+
+#define V_DEPTH     (16|(1<<16))
+#define V_HEIGHT    800
+#define V_WIDTH     600
+#define V_DISPLAY   1
+#define V_LINESIZE  (V_WIDTH * 3)
+
+#define RAMFB_SIZE (V_LINESIZE * V_HEIGHT)
+
+void xnu_define_ramfb_device(AddressSpace* as, hwaddr ramfb_pa);
+void xnu_get_video_bootargs(void *opaque, hwaddr ramfb_pa);
+
+#endif
\ No newline at end of file
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/arm/xnu_file_mmio_dev.h qemu-t8030-private/include/hw/arm/xnu_file_mmio_dev.h
--- qemu-6.0.0/include/hw/arm/xnu_file_mmio_dev.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/arm/xnu_file_mmio_dev.h	2021-05-05 10:12:54.481818500 +0800
@@ -0,0 +1,39 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef HW_ARM_FILE_MMIO_DEV_H
+#define HW_ARM_FILE_MMIO_DEV_H
+
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+
+typedef struct {
+    hwaddr pa;
+    hwaddr size;
+    int fd;
+} FileMmioDev;
+
+void xnu_file_mmio_dev_create(MemoryRegion *sysmem, FileMmioDev *file_dev,
+                              const char *name, const char *filename);
+
+#endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/arm/xnu_mem.h qemu-t8030-private/include/hw/arm/xnu_mem.h
--- qemu-6.0.0/include/hw/arm/xnu_mem.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/arm/xnu_mem.h	2021-05-05 10:12:54.481818500 +0800
@@ -0,0 +1,50 @@
+/*
+ *
+ * Copyright (c) 2019 Jonathan Afek <jonyafek@me.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef HW_ARM_XNU_MEM_H
+#define HW_ARM_XNU_MEM_H
+
+#include "qemu-common.h"
+#include "hw/arm/boot.h"
+#include "target/arm/cpu.h"
+
+extern hwaddr g_virt_base;
+extern hwaddr g_phys_base;
+
+hwaddr vtop_static(hwaddr va);
+hwaddr ptov_static(hwaddr pa);
+hwaddr vtop_mmu(hwaddr va, CPUState *cs);
+
+hwaddr align_64k_low(hwaddr addr);
+hwaddr align_64k_high(hwaddr addr);
+
+hwaddr vtop_bases(hwaddr va, hwaddr phys_base, hwaddr virt_base);
+hwaddr ptov_bases(hwaddr pa, hwaddr phys_base, hwaddr virt_base);
+
+uint8_t get_highest_different_bit_index(hwaddr addr1, hwaddr addr2);
+uint8_t get_lowest_non_zero_bit_index(hwaddr addr);
+hwaddr get_low_bits_mask_for_bit_index(uint8_t bit_index);
+
+void allocate_ram(MemoryRegion *top, const char *name, hwaddr addr,
+                  hwaddr size);
+#endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/block/apple_ans.h qemu-t8030-private/include/hw/block/apple_ans.h
--- qemu-6.0.0/include/hw/block/apple_ans.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/block/apple_ans.h	2021-05-05 23:07:27.997249800 +0800
@@ -0,0 +1,153 @@
+#ifndef APPLE_ANS_H
+#define APPLE_ANS_H
+
+#include "qemu/queue.h"
+#include "hw/sysbus.h"
+#include "qom/object.h"
+#include "hw/arm/xnu_dtb.h"
+#include "hw/block/block.h"
+#include "hw/pci/pci.h"
+#include "hw/pci/pcie_host.h"
+#include "hw/pci/msi.h"
+#include "hw/pci/msix.h"
+#include "sysemu/dma.h"
+#include "hw/block/nvme.h"
+
+#define TYPE_APPLE_ANS "apple.ans"
+OBJECT_DECLARE_SIMPLE_TYPE(AppleANSState, APPLE_ANS)
+
+#define IRQ_IOP_INBOX 1
+#define IRQ_IOP_OUTBOX 2
+
+#define REG_AKF_CONFIG                  0x2043
+
+/*
+ * AP -> IOP: A2I; IOP -> AP: I2A
+ * Inbox: A2I
+ * Outbox: I2A
+ */
+#define REG_A7V4_CPU_CTRL                   0x0044
+#define     REG_A7V4_CPU_CTRL_RUN           0x10
+#define REG_A7V4_NMI0                       0xc04
+#define REG_A7V4_NMI1                       0xc14
+#define REG_A7V4_INBOX_CTRL                 0x8108
+#define     REG_A7V4_INBOX_CTRL_ENABLE      (1 << 0)
+#define     REG_A7V4_INBOX_CTRL_FULL        (1 << 16)
+#define     REG_A7V4_INBOX_CTRL_EMPTY       (1 << 17)
+#define REG_A7V4_OUTBOX_CTRL                0x810C
+#define     REG_A7V4_OUTBOX_CTRL_ENABLE     (1 << 0)
+#define     REG_A7V4_OUTBOX_CTRL_FULL       (1 << 16)
+#define     REG_A7V4_OUTBOX_CTRL_EMPTY      (1 << 17)
+#define     REG_A7V4_OUTBOX_CTRL_HAS_MSG    (1 << 21)
+#define REG_A7V4_A2I_MSG0                   0x8800
+#define REG_A7V4_A2I_MSG1                   0x8808
+#define REG_A7V4_I2A_MSG0                   0x8830
+#define REG_A7V4_I2A_MSG1                   0x8838
+
+#define A7V4_MSG_FLAG_LAST                  (1 << 20)
+#define A7V4_MSG_FLAG_NOTLAST               REG_A7V4_OUTBOX_CTRL_HAS_MSG
+#define IOP_INBOX_SIZE                      16
+
+#define MSG_SEND_HELLO                      1
+#define MSG_RECV_HELLO                      2
+#define MSG_TYPE_PING                       4
+#define MSG_TYPE_EPSTART                    5
+#define MSG_TYPE_POWER                      7
+#define MSG_TYPE_ROLLCALL                   8
+#define MSG_TYPE_POWERACK                   11
+
+enum apple_iop_mailbox_ep0_state {
+    EP0_IDLE,
+    EP0_WAIT_HELLO,
+    EP0_WAIT_ROLLCALL,
+    EP0_WAIT_EPSTART,
+    EP0_WAIT_POWERACK,
+    EP0_DONE,
+};
+
+struct iop_message {
+    union QEMU_PACKED {
+        uint64_t data[2];
+        struct QEMU_PACKED {
+            union {
+                uint64_t msg;
+                struct QEMU_PACKED {
+                    union {
+                        struct QEMU_PACKED {
+                            uint16_t major;
+                            uint16_t minor;
+                        } hello;
+                        struct QEMU_PACKED {
+                            uint32_t seg;
+                            uint16_t timestamp;
+                        } ping;
+                        struct QEMU_PACKED {
+                            uint32_t state;
+                            uint32_t ep;
+                        } epstart;
+                        struct QEMU_PACKED {
+                            uint32_t state;
+                        } power;
+                        struct QEMU_PACKED {
+                            uint32_t epMask;
+                            /* bit x -> endpoint ((epBlock * 32) + x) */
+                            uint8_t epBlock:6;
+                            uint16_t unk38:13;
+                            uint8_t epEnded:1;
+                        } rollcall;
+                    };
+                };
+                struct QEMU_PACKED {
+                    uint32_t field_0;
+                    uint16_t field_32;
+                    uint8_t field_48:4;
+                    uint8_t type:4;
+                };
+            };
+            uint32_t endpoint;
+            uint32_t flags;
+        };
+    };
+    QTAILQ_ENTRY(iop_message) entry;
+};
+
+typedef struct iop_message *iop_message_t;
+
+#define APPLE_BOOT_STATUS       0x1300
+#define   APPLE_BOOT_STATUS_OK  0xde71ce55
+
+typedef struct QEMU_PACKED {
+    uint32_t unk0;
+    uint32_t unk4;
+    uint32_t numBlocks;
+} NVMeCreateNamespacesEntryStruct;
+struct AppleANSState {
+    PCIExpressHost parent_obj;
+    MemoryRegion *iomems[4];
+    MemoryRegion io_mmio;
+    MemoryRegion io_ioport;
+    MemoryRegion msix;
+    QemuMutex mutex;
+    QemuThread iop_thread;
+    QemuCond iop_halt;
+    uint32_t ep0_status;
+    bool stopping;
+    uint32_t config;
+    uint32_t cpu_ctrl;
+    qemu_irq irqs[5];
+
+    uint64_t inboxBuffer[2];
+    QTAILQ_HEAD(, iop_message) inbox;
+    uint64_t inboxSize;
+    QemuMutex *inboxLock;
+
+    bool outboxEnable;
+    QTAILQ_HEAD(, iop_message) outbox;
+    QemuMutex *outboxLock;
+    uint64_t outboxSize;
+    NvmeCtrl nvme;
+    uint32_t nvme_interrupt_idx;
+};
+SysBusDevice *apple_ans_create(DTBNode* node);
+
+#endif /* APPLE_ANS_H */
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/display/xnu_ramfb.h qemu-t8030-private/include/hw/display/xnu_ramfb.h
--- qemu-6.0.0/include/hw/display/xnu_ramfb.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/display/xnu_ramfb.h	2021-05-05 10:12:54.529484800 +0800
@@ -0,0 +1,12 @@
+#ifndef XNU_RAMFB_H
+#define XNU_RAMFB_H
+
+typedef struct xnu_ramfb_state xnu_ramfb_state;
+void xnu_ramfb_display_update(void *opaque);
+void xnu_ramfb_setup(xnu_ramfb_state* xnu_fb_state);
+void xnu_ramfb_free(uint8_t* qemu_fb_ptr);
+void xnu_display_prolog(xnu_ramfb_state* xnu_fb_state);
+
+#define TYPE_XNU_RAMFB_DEVICE "xnu_ramfb"
+
+#endif /* XNU_RAMFB_H */
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/gpio/apple_gpio.h qemu-t8030-private/include/hw/gpio/apple_gpio.h
--- qemu-6.0.0/include/hw/gpio/apple_gpio.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/gpio/apple_gpio.h	2021-05-05 23:07:27.997249800 +0800
@@ -0,0 +1,32 @@
+#ifndef APPLE_GPIO_H
+#define APPLE_GPIO_H
+
+#include "hw/sysbus.h"
+#include "qom/object.h"
+#include "hw/arm/xnu_dtb.h"
+
+#define TYPE_APPLE_GPIO "apple.gpio"
+OBJECT_DECLARE_SIMPLE_TYPE(AppleGPIOState, APPLE_GPIO)
+
+typedef struct {
+    uint32_t value;
+    bool interrupted;
+} AppleGPIOPinState;
+
+struct AppleGPIOState {
+    SysBusDevice parent_obj;
+    MemoryRegion *iomem;
+    uint64_t npins, nirqgrps;
+    qemu_irq *irqs;
+    qemu_irq *out;
+
+    uint32_t *gpio_cfg;
+    uint32_t **int_cfg;
+    uint32_t *in;
+    uint32_t *old_in;
+    uint32_t npl;
+    uint32_t phandle;
+};
+
+DeviceState *apple_gpio_create(DTBNode* node);
+#endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/i2c/apple_i2c.h qemu-t8030-private/include/hw/i2c/apple_i2c.h
--- qemu-6.0.0/include/hw/i2c/apple_i2c.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/i2c/apple_i2c.h	2021-05-05 10:12:54.546567000 +0800
@@ -0,0 +1,26 @@
+#ifndef APPLE_I2C_H
+#define APPLE_I2C_H
+
+#include "hw/sysbus.h"
+#include "qom/object.h"
+#include "hw/arm/xnu_dtb.h"
+#include "hw/i2c/bitbang_i2c.h"
+
+#define TYPE_APPLE_I2C "apple.i2c"
+OBJECT_DECLARE_SIMPLE_TYPE(AppleI2CState, APPLE_I2C)
+
+struct AppleI2CState {
+    /*< private >*/
+    SysBusDevice parent_obj;
+    bitbang_i2c_interface bitbang;
+    int last_level;
+
+    /*< public >*/
+    MemoryRegion iomem;
+    I2CBus *bus;
+    qemu_irq irq;
+    qemu_irq out;
+};
+
+DeviceState *apple_i2c_create(DTBNode *node);
+#endif /* APPLE_I2C_H */
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/hw/intc/apple_aic.h qemu-t8030-private/include/hw/intc/apple_aic.h
--- qemu-6.0.0/include/hw/intc/apple_aic.h	1970-01-01 07:30:00.000000000 +0730
+++ qemu-t8030-private/include/hw/intc/apple_aic.h	2021-05-05 23:07:27.997249800 +0800
@@ -0,0 +1,130 @@
+#ifndef APPLE_AIC_H
+#define APPLE_AIC_H
+
+#include "hw/sysbus.h"
+#include "qom/object.h"
+#include "hw/arm/xnu_dtb.h"
+
+#define TYPE_APPLE_AIC "apple.aic"
+OBJECT_DECLARE_SIMPLE_TYPE(AppleAICState, APPLE_AIC)
+
+/*
+ * AIC splits IRQs into domains (ipid)
+ * In T8030 device tree, we have aic->ipid_length = 72
+ * => IRQ(extInts) max nr = ((len(ipid_mask)>>2)<<5) = 0x240 (interrupts)
+ * -> num domains = (0x240 + 31)>>5 = 18 (domains)
+ * 0x240/18 = 32 (bits) of an uint32_t
+ *
+ * Commands such as rAIC_EIR_MASK_SET/CLR assign each domain to a 32bit register.
+ * When masking/unmasking-ing IRQ n,
+ * write to (aic_base + command_reg_base + (n / 32) * 4)
+ *          a uint32_t which has (n % 32)-th bit set,
+ * command_reg_base is 0x4100 for rAIC_EIR_MASK_SET, 0x4180 for rAIC_EIR_MASK_CLR.
+ *
+ * T8030 uses both fast IPI, and AIC IPIs.
+ * AIC IPIs' vectors are right after IRQs' vectors.
+ * num IRQ + (X * 2) -> self_ipi (cpuX->cpuX)
+ * num IRQ + (Y * 2) + 1 -> other_ipi (cpuX->cpuY)
+ */
+
+//TODO: this is hardcoded for T8030
+#define AIC_INT_COUNT   (576)
+#define AIC_CPU_COUNT   (6)
+#define AIC_VERSION     (2)
+
+#define rAIC_REV                    (0x0000)
+#define rAIC_CAP0                   (0x0004)
+#define rAIC_CAP1                   (0x0008)
+#define rAIC_RST                    (0x000C)
+
+#define rAIC_GLB_CFG                (0x0010)
+#define     AIC_GLBCFG_IEN          (1 << 0)
+#define     AIC_GLBCFG_AEWT(_t)     ((_t) << 4)
+#define     AIC_GLBCFG_SEWT(_t)     ((_t) << 8)
+#define     AIC_GLBCFG_AIWT(_t)     ((_t) << 12)
+#define     AIC_GLBCFG_SIWT(_t)     ((_t) << 16)
+#define     AIC_GLBCFG_SYNC_ACG     (1 << 29)
+#define     AIC_GLBCFG_EIR_ACG      (1 << 30)
+#define     AIC_GLBCFG_REG_ACG      (1 << 31)
+#define     AIC_GLBCFG_WT_MASK      (15)
+#define     AIC_GLBCFG_WT_64MICRO   (7)
+
+#define rAIC_WHOAMI                 (0x2000)
+#define rAIC_IACK                   (0x2004)
+#define rAIC_IPI_SET                (0x2008)
+#define rAIC_IPI_CLR                (0x200C)
+#define     AIC_IPI_NORMAL          (1 << 0)
+#define     AIC_IPI_SELF            (1 << 31)
+#define rAIC_IPI_MASK_SET           (0x2024)
+#define rAIC_IPI_MASK_CLR           (0x2028)
+#define rAIC_IPI_DEFER_SET          (0x202C)
+#define rAIC_IPI_DEFER_CLR          (0x2030)
+
+#define rAIC_EIR_DEST(_n)           (0x3000 + ((_n) * 4))
+#define rAIC_EIR_SW_SET(_n)         (0x4000 + ((_n) * 4))
+#define rAIC_EIR_SW_CLR(_n)         (0x4080 + ((_n) * 4))
+#define rAIC_EIR_MASK_SET(_n)       (0x4100 + ((_n) * 4))
+#define rAIC_EIR_MASK_CLR(_n)       (0x4180 + ((_n) * 4))
+#define rAIC_EIR_INT_RO(_n)         (0x4200 + ((_n) * 4))
+
+#define rAIC_WHOAMI_Pn(_n)          (0x5000 + ((_n) * 0x80))
+#define rAIC_IACK_Pn(_n)            (0x5004 + ((_n) * 0x80))
+#define rAIC_IPI_SET_Pn(_n)         (0x5008 + ((_n) * 0x80))
+#define rAIC_IPI_CLR_Pn(_n)         (0x500C + ((_n) * 0x80))
+#define rAIC_IPI_MASK_SET_Pn(_n)    (0x5024 + ((_n) * 0x80))
+#define rAIC_IPI_MASK_CLR_Pn(_n)    (0x5028 + ((_n) * 0x80))
+#define rAIC_IPI_DEFER_SET_Pn(_n)   (0x502C + ((_n) * 0x80))
+#define rAIC_IPI_DEFER_CLR_Pn(_n)   (0x5030 + ((_n) * 0x80))
+
+#define kAIC_INT_SPURIOUS       (0x00000)
+#define kAIC_INT_EXT            (0x10000)
+#define kAIC_INT_IPI            (0x40000)
+#define kAIC_INT_IPI_NORM       (0x40001)
+#define kAIC_INT_IPI_SELF       (0x40002)
+
+#define AIC_INT_EXT(_v)         (((_v) & 0x70000) == kAIC_INT_EXT)
+#define AIC_INT_IPI(_v)         (((_v) & 0x70000) == kAIC_INT_IPI)
+
+#define AIC_INT_EXTID(_v)       ((_v) & 0x3FF)
+
+#define AIC_SRC_TO_EIR(_s)      ((_s) >> 5)
+#define AIC_SRC_TO_MASK(_s)     (1 << ((_s) & 0x1F))
+#define AIC_EIR_TO_SRC(_s, _v)  (((_s) << 5) + ((_v) & 0x1F))
+
+#define kAIC_MAX_EXTID          (AIC_INT_COUNT)
+#define kAIC_VEC_IPI            (kAIC_MAX_EXTID)
+#define kAIC_NUM_INTS           (kAIC_VEC_IPI + 1)
+
+#define kAIC_NUM_EIRS           AIC_SRC_TO_EIR(kAIC_MAX_EXTID)
+
+#define kAICWT 64000
+
+typedef struct  {
+    void *aic;
+    qemu_irq irq;
+    MemoryRegion iomem;
+    unsigned int cpu_id;
+    uint32_t pendingIPI;
+    uint32_t deferredIPI;
+    uint32_t ipi_mask;
+} AppleAICOpaque;
+
+struct AppleAICState {
+    SysBusDevice parent_obj;
+    QEMUTimer *timer;
+    QemuMutex mutex;
+    uint32_t base_size;
+    size_t numEIR;
+    size_t numIRQ;
+    size_t numCPU;
+    uint32_t *eir_mask;
+    uint32_t *eir_dest;
+    AppleAICOpaque *cpus;
+    uint32_t *eir_state;
+    uint32_t global_cfg;
+};
+
+
+SysBusDevice *apple_aic_create(unsigned int numCPU, DTBNode *node);
+
+#endif /* APPLE_AIC_H */
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/include/qemu/xxhash.h qemu-t8030-private/include/qemu/xxhash.h
--- qemu-6.0.0/include/qemu/xxhash.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/include/qemu/xxhash.h	2021-05-05 10:12:54.981520900 +0800
@@ -49,6 +49,64 @@
  * contiguous in memory.
  */
 static inline uint32_t
+qemu_xxhash8(uint64_t ab, uint64_t cd, uint64_t ef, uint32_t g, uint32_t h)
+{
+    uint32_t v1 = QEMU_XXHASH_SEED + PRIME32_1 + PRIME32_2;
+    uint32_t v2 = QEMU_XXHASH_SEED + PRIME32_2;
+    uint32_t v3 = QEMU_XXHASH_SEED + 0;
+    uint32_t v4 = QEMU_XXHASH_SEED - PRIME32_1;
+    uint32_t a = ab;
+    uint32_t b = ab >> 32;
+    uint32_t c = cd;
+    uint32_t d = cd >> 32;
+    uint32_t e = ef;
+    uint32_t f = ef >> 32;
+    uint32_t h32;
+
+    v1 += a * PRIME32_2;
+    v1 = rol32(v1, 13);
+    v1 *= PRIME32_1;
+
+    v2 += b * PRIME32_2;
+    v2 = rol32(v2, 13);
+    v2 *= PRIME32_1;
+
+    v3 += c * PRIME32_2;
+    v3 = rol32(v3, 13);
+    v3 *= PRIME32_1;
+
+    v4 += d * PRIME32_2;
+    v4 = rol32(v4, 13);
+    v4 *= PRIME32_1;
+
+    v1 += e * PRIME32_2;
+    v1 = rol32(v1, 13);
+    v1 *= PRIME32_1;
+
+    v2 += f * PRIME32_2;
+    v2 = rol32(v2, 13);
+    v2 *= PRIME32_1;
+
+    v3 += g * PRIME32_2;
+    v3 = rol32(v3, 13);
+    v3 *= PRIME32_1;
+
+    v4 += h * PRIME32_2;
+    v4 = rol32(v4, 13);
+    v4 *= PRIME32_1;
+
+    h32 = rol32(v1, 1) + rol32(v2, 7) + rol32(v3, 12) + rol32(v4, 18);
+    h32 += 32;
+
+    h32 ^= h32 >> 15;
+    h32 *= PRIME32_2;
+    h32 ^= h32 >> 13;
+    h32 *= PRIME32_3;
+    h32 ^= h32 >> 16;
+
+    return h32;
+}
+static inline uint32_t
 qemu_xxhash7(uint64_t ab, uint64_t cd, uint32_t e, uint32_t f, uint32_t g)
 {
     uint32_t v1 = QEMU_XXHASH_SEED + PRIME32_1 + PRIME32_2;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/alpha/cpu.h qemu-t8030-private/target/alpha/cpu.h
--- qemu-6.0.0/target/alpha/cpu.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/alpha/cpu.h	2021-05-05 10:12:55.974232100 +0800
@@ -464,7 +464,7 @@ void alpha_cpu_do_transaction_failed(CPU
 #endif
 
 static inline void cpu_get_tb_cpu_state(CPUAlphaState *env, target_ulong *pc,
-                                        target_ulong *cs_base, uint32_t *pflags)
+                                        target_ulong *cs_base, uint64_t *pflags)
 {
     *pc = env->pc;
     *cs_base = 0;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/cpu.c qemu-t8030-private/target/arm/cpu.c
--- qemu-6.0.0/target/arm/cpu.c	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/cpu.c	2021-05-05 10:12:55.990930600 +0800
@@ -821,13 +821,14 @@ static void aarch64_cpu_dump_state(CPUSt
     } else {
         ns_status = "";
     }
-    qemu_fprintf(f, "PSTATE=%08x %c%c%c%c %sEL%d%c",
+    qemu_fprintf(f, "PSTATE=%08x %c%c%c%c %s%cL%d%c",
                  psr,
                  psr & PSTATE_N ? 'N' : '-',
                  psr & PSTATE_Z ? 'Z' : '-',
                  psr & PSTATE_C ? 'C' : '-',
                  psr & PSTATE_V ? 'V' : '-',
                  ns_status,
+                 env->gxf.guarded ? 'G' : 'E',
                  el,
                  psr & PSTATE_SP ? 'h' : 't');
 
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/cpu.h qemu-t8030-private/target/arm/cpu.h
--- qemu-6.0.0/target/arm/cpu.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/cpu.h	2021-05-05 10:12:55.992133300 +0800
@@ -54,6 +54,7 @@
 #define EXCP_LAZYFP         20   /* v7M fault during lazy FP stacking */
 #define EXCP_LSERR          21   /* v8M LSERR SecureFault */
 #define EXCP_UNALIGNED      22   /* v7M UNALIGNED UsageFault */
+#define EXCP_GENTER         23
 /* NB: add new EXCP_ defines to the array in arm_log_exception() too */
 
 #define ARMV7M_EXCP_RESET   1
@@ -253,7 +254,7 @@ typedef struct CPUARMState {
     uint32_t aarch64; /* 1 if CPU is in aarch64 state; inverse of PSTATE.nRW */
 
     /* Cached TBFLAGS state.  See below for which bits are included.  */
-    uint32_t hflags;
+    uint64_t hflags;
 
     /* Frequently accessed CPSR bits are stored separately for efficiency.
        This contains all the other bits.  Use cpsr_{read,write} to access
@@ -515,9 +516,24 @@ typedef struct CPUARMState {
         uint64_t tfsr_el[4]; /* tfsre0_el1 is index 0.  */
         uint64_t gcr_el1;
         uint64_t rgsr_el1;
+        uint64_t vmsa_lock_el1;
     } cp15;
 
     struct {
+        uint64_t gxf_entry_el[3];
+        uint64_t gxf_config_el[3];
+        uint64_t gxf_pabentry_el[3];
+        uint64_t sp_gl[3];
+        uint64_t tpidr_gl[3];
+        uint64_t vbar_gl[3];
+        uint64_t elr_gl[3];
+        uint64_t esr_gl[3];
+        uint64_t far_gl[3];
+        uint64_t spsr_gl[3];
+        bool guarded;
+    } gxf;
+
+    struct {
         /* M profile has up to 4 stack pointers:
          * a Main Stack Pointer and a Process Stack Pointer for each
          * of the Secure and Non-Secure states. (If the CPU doesn't support
@@ -721,6 +737,7 @@ typedef struct CPUARMState {
     const struct arm_boot_info *boot_info;
     /* Store GICv3CPUState to access from this struct */
     void *gicv3state;
+    void *t8030state;
 
 #ifdef TARGET_TAGGED_ADDRESSES
     /* Linux syscall tagged address support */
@@ -1336,6 +1353,13 @@ void pmu_init(ARMCPU *cpu);
 #define PSTATE_MODE_EL1h 5
 #define PSTATE_MODE_EL1t 4
 #define PSTATE_MODE_EL0t 0
+/* VMSA_LOCK_EL1 */
+#define VMSA_LOCK_VBAR_EL1      (1ULL << 0)
+#define VMSA_LOCK_SCTLR_EL1     (1ULL << 1)
+#define VMSA_LOCK_TCR_EL1       (1ULL << 2)
+#define VMSA_LOCK_TTBR0_EL1     (1ULL << 3)
+#define VMSA_LOCK_TTBR1_EL1     (1ULL << 4)
+#define VMSA_LOCK_SCTLR_M_BIT   (1ULL << 63)
 
 /* Write a new value to v7m.exception, thus transitioning into or out
  * of Handler mode; this may result in a change of active stack pointer.
@@ -3382,7 +3406,7 @@ typedef ARMCPU ArchCPU;
  * We put flags which are shared between 32 and 64 bit mode at the top
  * of the word, and flags which apply to only one mode at the bottom.
  *
- *  31          20    18    14          9              0
+ *  63          32    18    14          9              0
  * +--------------+-----+-----+----------+--------------+
  * |              |     |   TBFLAG_A32   |              |
  * |              |     +-----+----------+  TBFLAG_AM32 |
@@ -3390,19 +3414,19 @@ typedef ARMCPU ArchCPU;
  * |              +-----------+----------+--------------|
  * |              |            TBFLAG_A64               |
  * +--------------+-------------------------------------+
- *  31          20                                     0
+ *  63          32                                     0
  *
  * Unless otherwise noted, these bits are cached in env->hflags.
  */
-FIELD(TBFLAG_ANY, AARCH64_STATE, 31, 1)
-FIELD(TBFLAG_ANY, SS_ACTIVE, 30, 1)
-FIELD(TBFLAG_ANY, PSTATE_SS, 29, 1)     /* Not cached. */
-FIELD(TBFLAG_ANY, BE_DATA, 28, 1)
-FIELD(TBFLAG_ANY, MMUIDX, 24, 4)
+FIELD(TBFLAG_ANY, AARCH64_STATE, 63, 1)
+FIELD(TBFLAG_ANY, SS_ACTIVE, 62, 1)
+FIELD(TBFLAG_ANY, PSTATE_SS, 61, 1)     /* Not cached. */
+FIELD(TBFLAG_ANY, BE_DATA, 60, 1)
+FIELD(TBFLAG_ANY, MMUIDX, 56, 4)
 /* Target EL if we take a floating-point-disabled exception */
-FIELD(TBFLAG_ANY, FPEXC_EL, 22, 2)
+FIELD(TBFLAG_ANY, FPEXC_EL, 54, 2)
 /* For A-profile only, target EL for debug exceptions.  */
-FIELD(TBFLAG_ANY, DEBUG_TARGET_EL, 20, 2)
+FIELD(TBFLAG_ANY, DEBUG_TARGET_EL, 52, 2)
 
 /*
  * Bit usage when in AArch32 state, both A- and M-profile.
@@ -3461,6 +3485,7 @@ FIELD(TBFLAG_A64, ATA, 15, 1)
 FIELD(TBFLAG_A64, TCMA, 16, 2)
 FIELD(TBFLAG_A64, MTE_ACTIVE, 18, 1)
 FIELD(TBFLAG_A64, MTE0_ACTIVE, 19, 1)
+FIELD(TBFLAG_A64, GUARDED, 20, 1)
 
 /**
  * cpu_mmu_index:
@@ -3472,7 +3497,7 @@ FIELD(TBFLAG_A64, MTE0_ACTIVE, 19, 1)
  */
 static inline int cpu_mmu_index(CPUARMState *env, bool ifetch)
 {
-    return FIELD_EX32(env->hflags, TBFLAG_ANY, MMUIDX);
+    return FIELD_EX64(env->hflags, TBFLAG_ANY, MMUIDX);
 }
 
 static inline bool bswap_code(bool sctlr_b)
@@ -3507,7 +3532,7 @@ static inline bool arm_cpu_bswap_data(CP
 #endif
 
 void cpu_get_tb_cpu_state(CPUARMState *env, target_ulong *pc,
-                          target_ulong *cs_base, uint32_t *flags);
+                          target_ulong *cs_base, uint64_t *flags);
 
 enum {
     QEMU_PSCI_CONDUIT_DISABLED = 0,
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/helper-a64.c qemu-t8030-private/target/arm/helper-a64.c
--- qemu-6.0.0/target/arm/helper-a64.c	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/helper-a64.c	2021-05-06 00:10:18.012371700 +0800
@@ -937,9 +937,17 @@ void HELPER(exception_return)(CPUARMStat
 {
     int cur_el = arm_current_el(env);
     unsigned int spsr_idx = aarch64_banked_spsr_index(cur_el);
-    uint32_t spsr = env->banked_spsr[spsr_idx];
+    uint32_t spsr = 0;
     int new_el;
-    bool return_to_aa64 = (spsr & PSTATE_nRW) == 0;
+    bool return_to_aa64;
+
+    if (env->gxf.guarded) { 
+        spsr = env->gxf.spsr_gl[cur_el];
+    } else {
+        spsr = env->banked_spsr[spsr_idx];
+    }
+
+    return_to_aa64 = (spsr & PSTATE_nRW) == 0;
 
     aarch64_save_sp(env, cur_el);
 
@@ -1020,7 +1028,7 @@ void HELPER(exception_return)(CPUARMStat
          * the hflags rebuild, since we can pull the composite TBII field
          * from there.
          */
-        tbii = FIELD_EX32(env->hflags, TBFLAG_A64, TBII);
+        tbii = FIELD_EX64(env->hflags, TBFLAG_A64, TBII);
         if ((tbii >> extract64(new_pc, 55, 1)) & 1) {
             /* TBI is enabled. */
             int core_mmu_idx = cpu_mmu_index(env, false);
@@ -1069,6 +1077,35 @@ illegal_return:
                   "resuming execution at 0x%" PRIx64 "\n", cur_el, env->pc);
 }
 
+void HELPER(gexit)(CPUARMState *env)
+{
+    int cur_el = arm_current_el(env);
+    uint32_t spsr = env->gxf.spsr_gl[cur_el];
+    //TODO: Illegal gexit?
+
+    aarch64_save_sp(env, cur_el);
+
+    if (arm_generate_debug_exceptions(env)) {
+        spsr &= ~PSTATE_SS;
+    }
+
+    spsr &= aarch64_pstate_valid_mask(&env_archcpu(env)->isar);
+    pstate_write(env, spsr);
+
+    if (!arm_singlestep_active(env)) {
+        env->pstate &= ~PSTATE_SS;
+    }
+
+    env->gxf.guarded = false;
+    aarch64_restore_sp(env, cur_el);
+    env->pc = env->gxf.elr_gl[cur_el];
+    helper_rebuild_hflags_a64(env, cur_el);
+    qemu_log_mask(CPU_LOG_INT, "Guarded execution exit from AArch64 GL%d to "
+                      "AArch64 EL%d PC 0x%" PRIx64 "\n",
+                      cur_el, cur_el, env->pc);
+    return;
+}
+
 /*
  * Square Root and Reciprocal square root
  */
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/helper-a64.h qemu-t8030-private/target/arm/helper-a64.h
--- qemu-6.0.0/target/arm/helper-a64.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/helper-a64.h	2021-05-05 10:12:55.997683400 +0800
@@ -90,6 +90,7 @@ DEF_HELPER_2(advsimd_f16touinth, i32, f1
 DEF_HELPER_2(sqrt_f16, f16, f16, ptr)
 
 DEF_HELPER_2(exception_return, void, env, i64)
+DEF_HELPER_1(gexit, void, env)
 DEF_HELPER_FLAGS_2(dc_zva, TCG_CALL_NO_WG, void, env, i64)
 
 DEF_HELPER_FLAGS_3(pacia, TCG_CALL_NO_WG, i64, env, i64, i64)
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/helper.c qemu-t8030-private/target/arm/helper.c
--- qemu-6.0.0/target/arm/helper.c	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/helper.c	2021-05-06 00:17:02.221425800 +0800
@@ -2006,6 +2006,15 @@ static void pmintenclr_write(CPUARMState
     pmu_update_irq(env);
 }
 
+static uint64_t vbar_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    if (env->gxf.guarded) {
+        return env->gxf.vbar_gl[1];
+    } else {
+        return raw_read(env, ri);
+    }
+}
+
 static void vbar_write(CPUARMState *env, const ARMCPRegInfo *ri,
                        uint64_t value)
 {
@@ -2018,6 +2027,20 @@ static void vbar_write(CPUARMState *env,
     raw_write(env, ri, value & ~0x1FULL);
 }
 
+static void vbar_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                           uint64_t value)
+{
+    if (env->gxf.guarded) {
+        env->gxf.vbar_gl[1] = value & ~0x1FULL;
+    } else {
+        if (!env->gxf.guarded && env->cp15.vmsa_lock_el1 & VMSA_LOCK_VBAR_EL1) {
+            return;
+        }
+
+        raw_write(env, ri, value & ~0x1FULL);
+    }
+}
+
 static void scr_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
 {
     /* Begin with base v8.0 state.  */
@@ -2466,6 +2489,24 @@ static const ARMCPRegInfo t2ee_cp_reginf
     REGINFO_SENTINEL
 };
 
+static uint64_t tpidr_el1_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    if (env->gxf.guarded) {
+        return env->gxf.tpidr_gl[1];
+    } else {
+        return env->cp15.tpidr_el[1];
+    }
+}
+
+static void tpidr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    if (env->gxf.guarded) {
+        env->gxf.tpidr_gl[1] = value;
+    } else {
+        env->cp15.tpidr_el[1] = value;
+    }
+}
+
 static const ARMCPRegInfo v6k_cp_reginfo[] = {
     { .name = "TPIDR_EL0", .state = ARM_CP_STATE_AA64,
       .opc0 = 3, .opc1 = 3, .opc2 = 2, .crn = 13, .crm = 0,
@@ -2489,7 +2530,8 @@ static const ARMCPRegInfo v6k_cp_reginfo
     { .name = "TPIDR_EL1", .state = ARM_CP_STATE_AA64,
       .opc0 = 3, .opc1 = 0, .opc2 = 4, .crn = 13, .crm = 0,
       .access = PL1_RW,
-      .fieldoffset = offsetof(CPUARMState, cp15.tpidr_el[1]), .resetvalue = 0 },
+      .readfn = tpidr_el1_read, .writefn = tpidr_el1_write,
+      .resetvalue = 0 },
     { .name = "TPIDRPRW", .opc1 = 0, .cp = 15, .crn = 13, .crm = 0, .opc2 = 4,
       .access = PL1_RW,
       .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.tpidrprw_s),
@@ -3997,6 +4039,14 @@ static void vmsa_tcr_el12_write(CPUARMSt
     tlb_flush(CPU(cpu));
     tcr->raw_tcr = value;
 }
+static void vmsa_tcr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                               uint64_t value)
+{
+    if (!env->gxf.guarded && env->cp15.vmsa_lock_el1 & VMSA_LOCK_TCR_EL1) {
+        return;
+    }
+    vmsa_tcr_el12_write(env, ri, value);
+}
 
 static void vmsa_ttbr_write(CPUARMState *env, const ARMCPRegInfo *ri,
                             uint64_t value)
@@ -4009,6 +4059,24 @@ static void vmsa_ttbr_write(CPUARMState
     }
     raw_write(env, ri, value);
 }
+static void vmsa_ttbr0_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                            uint64_t value)
+{
+    if (!env->gxf.guarded && env->cp15.vmsa_lock_el1 & VMSA_LOCK_TTBR0_EL1) {
+        return;
+    }
+
+    vmsa_ttbr_write(env, ri, value);
+}
+static void vmsa_ttbr1_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                            uint64_t value)
+{
+    if (!env->gxf.guarded && env->cp15.vmsa_lock_el1 & VMSA_LOCK_TTBR1_EL1) {
+        return;
+    }
+
+    vmsa_ttbr_write(env, ri, value);
+}
 
 static void vmsa_tcr_ttbr_el2_write(CPUARMState *env, const ARMCPRegInfo *ri,
                                     uint64_t value)
@@ -4058,6 +4126,24 @@ static void vttbr_write(CPUARMState *env
     }
 }
 
+static uint64_t far_el1_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    if (env->gxf.guarded) {
+        return env->gxf.far_gl[1];
+    } else {
+        return env->cp15.far_el[1];
+    }
+}
+
+static void far_el1_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    if (env->gxf.guarded) {
+        env->gxf.far_gl[1] = value;
+    } else {
+        env->cp15.far_el[1] = value;
+    }
+}
+
 static const ARMCPRegInfo vmsa_pmsa_cp_reginfo[] = {
     { .name = "DFSR", .cp = 15, .crn = 5, .crm = 0, .opc1 = 0, .opc2 = 0,
       .access = PL1_RW, .accessfn = access_tvm_trvm, .type = ARM_CP_ALIAS,
@@ -4074,32 +4160,51 @@ static const ARMCPRegInfo vmsa_pmsa_cp_r
     { .name = "FAR_EL1", .state = ARM_CP_STATE_AA64,
       .opc0 = 3, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 0,
       .access = PL1_RW, .accessfn = access_tvm_trvm,
-      .fieldoffset = offsetof(CPUARMState, cp15.far_el[1]),
+      .readfn = far_el1_read, .writefn = far_el1_write,
       .resetvalue = 0, },
     REGINFO_SENTINEL
 };
 
+static uint64_t esr_el1_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    if (env->gxf.guarded) {
+        return env->gxf.esr_gl[1];
+    } else {
+        return env->cp15.esr_el[1];
+    }
+}
+
+static void esr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    if (env->gxf.guarded) {
+        env->gxf.esr_gl[1] = value;
+    } else {
+        env->cp15.esr_el[1] = value;
+    }
+}
+
 static const ARMCPRegInfo vmsa_cp_reginfo[] = {
     { .name = "ESR_EL1", .state = ARM_CP_STATE_AA64,
       .opc0 = 3, .crn = 5, .crm = 2, .opc1 = 0, .opc2 = 0,
       .access = PL1_RW, .accessfn = access_tvm_trvm,
-      .fieldoffset = offsetof(CPUARMState, cp15.esr_el[1]), .resetvalue = 0, },
+      .readfn = esr_el1_read, .writefn = esr_el1_write,
+      .resetvalue = 0, },
     { .name = "TTBR0_EL1", .state = ARM_CP_STATE_BOTH,
       .opc0 = 3, .opc1 = 0, .crn = 2, .crm = 0, .opc2 = 0,
       .access = PL1_RW, .accessfn = access_tvm_trvm,
-      .writefn = vmsa_ttbr_write, .resetvalue = 0,
+      .writefn = vmsa_ttbr0_el1_write, .resetvalue = 0,
       .bank_fieldoffsets = { offsetof(CPUARMState, cp15.ttbr0_s),
                              offsetof(CPUARMState, cp15.ttbr0_ns) } },
     { .name = "TTBR1_EL1", .state = ARM_CP_STATE_BOTH,
       .opc0 = 3, .opc1 = 0, .crn = 2, .crm = 0, .opc2 = 1,
       .access = PL1_RW, .accessfn = access_tvm_trvm,
-      .writefn = vmsa_ttbr_write, .resetvalue = 0,
+      .writefn = vmsa_ttbr1_el1_write, .resetvalue = 0,
       .bank_fieldoffsets = { offsetof(CPUARMState, cp15.ttbr1_s),
                              offsetof(CPUARMState, cp15.ttbr1_ns) } },
     { .name = "TCR_EL1", .state = ARM_CP_STATE_AA64,
       .opc0 = 3, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 2,
       .access = PL1_RW, .accessfn = access_tvm_trvm,
-      .writefn = vmsa_tcr_el12_write,
+      .writefn = vmsa_tcr_el1_write,
       .resetfn = vmsa_ttbcr_reset, .raw_writefn = raw_write,
       .fieldoffset = offsetof(CPUARMState, cp15.tcr_el[1]) },
     { .name = "TTBCR", .cp = 15, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 2,
@@ -4714,6 +4819,22 @@ static void tlbi_aa64_vae1is_write(CPUAR
 
     tlb_flush_page_bits_by_mmuidx_all_cpus_synced(cs, pageaddr, mask, bits);
 }
+static void tlbi_aa64_rvae1is_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                                   uint64_t value)
+{
+    CPUState *cs = env_cpu(env);
+    int mask = vae1_tlbmask(env);
+    uint64_t shift = ((extract64(value, 46, 2) - 1) << 1) + 12;
+    uint64_t tg = 1 << shift;
+    uint64_t scale = extract64(value, 44, 2);
+    uint64_t num = extract64(value, 39, 5);
+    uint64_t baseaddr = extract64(value, 0, 37) << shift;
+    uint64_t baseaddr_end = baseaddr+((num+1)*(1ULL<<(5*scale+1)) * tg);
+    for(uint64_t pageaddr = baseaddr; pageaddr < baseaddr_end; pageaddr += tg) {
+        int bits = vae1_tlbbits(env, pageaddr);
+        tlb_flush_page_bits_by_mmuidx_all_cpus_synced(cs, pageaddr, mask, bits);
+    }
+}
 
 static void tlbi_aa64_vae1_write(CPUARMState *env, const ARMCPRegInfo *ri,
                                  uint64_t value)
@@ -4734,6 +4855,32 @@ static void tlbi_aa64_vae1_write(CPUARMS
         tlb_flush_page_bits_by_mmuidx(cs, pageaddr, mask, bits);
     }
 }
+static void tlbi_aa64_rvae1_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                                 uint64_t value)
+{
+    /* Invalidate by VA, EL1&0 (AArch64 version).
+     * Currently handles all of VAE1, VAAE1, VAALE1 and VALE1,
+     * since we don't support flush-for-specific-ASID-only or
+     * flush-last-level-only.
+     */
+    CPUState *cs = env_cpu(env);
+    int mask = vae1_tlbmask(env);
+    uint64_t shift = ((extract64(value, 46, 2) - 1) << 1) + 12;
+    uint64_t tg = 1 << shift;
+    uint64_t scale = extract64(value, 44, 2);
+    uint64_t num = extract64(value, 39, 5);
+    uint64_t baseaddr = extract64(value, 0, 37) << shift;
+    uint64_t baseaddr_end = baseaddr+((num+1)*(1ULL<<(5*scale+1)) * tg);
+    for(uint64_t pageaddr = baseaddr; pageaddr < baseaddr_end; pageaddr += tg) {
+        int bits = vae1_tlbbits(env, pageaddr);
+
+        if (tlb_force_broadcast(env)) {
+            tlb_flush_page_bits_by_mmuidx_all_cpus_synced(cs, pageaddr, mask, bits);
+        } else {
+            tlb_flush_page_bits_by_mmuidx(cs, pageaddr, mask, bits);
+        }
+    }
+}
 
 static void tlbi_aa64_vae2is_write(CPUARMState *env, const ARMCPRegInfo *ri,
                                    uint64_t value)
@@ -4864,6 +5011,26 @@ static void sctlr_write(CPUARMState *env
         arm_rebuild_hflags(env);
     }
 }
+static void sctlr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                        uint64_t value)
+{
+    if (!env->gxf.guarded && env->cp15.vmsa_lock_el1 & VMSA_LOCK_SCTLR_EL1) {
+        return;
+    }
+
+    if (!env->gxf.guarded && env->cp15.vmsa_lock_el1 & VMSA_LOCK_SCTLR_M_BIT) {
+        value = (value & ~(SCTLR_M)) | (raw_read(env, ri) & SCTLR_M);
+    }
+
+    sctlr_write(env, ri, value);
+}
+
+static void vmsa_lock_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,
+                        uint64_t value)
+{
+    //don't unlock any after locked
+    raw_write(env, ri, raw_read(env, ri) | value);
+}
 
 static CPAccessResult fpexc32_access(CPUARMState *env, const ARMCPRegInfo *ri,
                                      bool isread)
@@ -4883,6 +5050,60 @@ static void sdcr_write(CPUARMState *env,
     env->cp15.mdcr_el3 = value & SDCR_VALID_MASK;
 }
 
+static uint64_t elr_el1_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    if (env->gxf.guarded) {
+        return env->gxf.elr_gl[1];
+    } else {
+        return env->elr_el[1];
+    }
+}
+
+static void elr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    if (env->gxf.guarded) {
+        env->gxf.elr_gl[1] = value;
+    } else {
+        env->elr_el[1] = value;
+    }
+}
+
+static uint64_t spsr_el1_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    if (env->gxf.guarded) {
+        return env->gxf.spsr_gl[1];
+    } else {
+        return env->banked_spsr[BANK_SVC];
+    }
+}
+
+static void spsr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    if (env->gxf.guarded) {
+        env->gxf.spsr_gl[1] = value;
+    } else {
+        env->banked_spsr[BANK_SVC] = value;
+    }
+}
+
+static uint64_t sp_el1_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    if (env->gxf.guarded) {
+        return env->gxf.sp_gl[1];
+    } else {
+        return env->sp_el[1];
+    }
+}
+
+static void sp_el1_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)
+{
+    if (env->gxf.guarded) {
+        env->gxf.sp_gl[1] = value;
+    } else {
+        env->sp_el[1] = value;
+    }
+}
+
 static const ARMCPRegInfo v8_cp_reginfo[] = {
     /* Minimal set of EL0-visible registers. This will need to be expanded
      * significantly for system emulation of AArch64 CPUs.
@@ -4966,6 +5187,10 @@ static const ARMCPRegInfo v8_cp_reginfo[
       .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 1,
       .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
       .writefn = tlbi_aa64_vae1is_write },
+    { .name = "TLBI_RVAE1IS", .state = ARM_CP_STATE_AA64,
+      .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 2, .opc2 = 1,
+      .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
+      .writefn = tlbi_aa64_rvae1is_write },
     { .name = "TLBI_ASIDE1IS", .state = ARM_CP_STATE_AA64,
       .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 2,
       .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
@@ -4974,6 +5199,10 @@ static const ARMCPRegInfo v8_cp_reginfo[
       .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 3,
       .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
       .writefn = tlbi_aa64_vae1is_write },
+    { .name = "TLBI_RVAAE1IS", .state = ARM_CP_STATE_AA64,
+      .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 2, .opc2 = 3,
+      .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
+      .writefn = tlbi_aa64_rvae1is_write },
     { .name = "TLBI_VALE1IS", .state = ARM_CP_STATE_AA64,
       .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 5,
       .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
@@ -4998,6 +5227,10 @@ static const ARMCPRegInfo v8_cp_reginfo[
       .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 3,
       .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
       .writefn = tlbi_aa64_vae1_write },
+    { .name = "TLBI_RVAAE1", .state = ARM_CP_STATE_AA64,
+      .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 6, .opc2 = 3,
+      .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
+      .writefn = tlbi_aa64_rvae1_write },
     { .name = "TLBI_VALE1", .state = ARM_CP_STATE_AA64,
       .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 5,
       .access = PL1_W, .accessfn = access_ttlb, .type = ARM_CP_NO_RAW,
@@ -5153,12 +5386,12 @@ static const ARMCPRegInfo v8_cp_reginfo[
       .type = ARM_CP_ALIAS,
       .opc0 = 3, .opc1 = 0, .crn = 4, .crm = 0, .opc2 = 1,
       .access = PL1_RW,
-      .fieldoffset = offsetof(CPUARMState, elr_el[1]) },
+      .readfn = elr_el1_read, .writefn = elr_el1_write },
     { .name = "SPSR_EL1", .state = ARM_CP_STATE_AA64,
       .type = ARM_CP_ALIAS,
       .opc0 = 3, .opc1 = 0, .crn = 4, .crm = 0, .opc2 = 0,
       .access = PL1_RW,
-      .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_SVC]) },
+      .readfn = spsr_el1_read, .writefn = spsr_el1_write },
     /* We rely on the access checks not allowing the guest to write to the
      * state field when SPSel indicates that it's being used as the stack
      * pointer.
@@ -5171,7 +5404,7 @@ static const ARMCPRegInfo v8_cp_reginfo[
     { .name = "SP_EL1", .state = ARM_CP_STATE_AA64,
       .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 1, .opc2 = 0,
       .access = PL2_RW, .type = ARM_CP_ALIAS,
-      .fieldoffset = offsetof(CPUARMState, sp_el[1]) },
+      .readfn = sp_el1_read, .writefn = sp_el1_write },
     { .name = "SPSel", .state = ARM_CP_STATE_AA64,
       .opc0 = 3, .opc1 = 0, .crn = 4, .crm = 2, .opc2 = 0,
       .type = ARM_CP_NO_RAW,
@@ -8211,7 +8444,8 @@ void register_cp_regs_for_features(ARMCP
         ARMCPRegInfo vbar_cp_reginfo[] = {
             { .name = "VBAR", .state = ARM_CP_STATE_BOTH,
               .opc0 = 3, .crn = 12, .crm = 0, .opc1 = 0, .opc2 = 0,
-              .access = PL1_RW, .writefn = vbar_write,
+              .access = PL1_RW,
+              .readfn = vbar_read, .writefn = vbar_el1_write,
               .bank_fieldoffsets = { offsetof(CPUARMState, cp15.vbar_s),
                                      offsetof(CPUARMState, cp15.vbar_ns) },
               .resetvalue = 0 },
@@ -8228,7 +8462,7 @@ void register_cp_regs_for_features(ARMCP
             .access = PL1_RW, .accessfn = access_tvm_trvm,
             .bank_fieldoffsets = { offsetof(CPUARMState, cp15.sctlr_s),
                                    offsetof(CPUARMState, cp15.sctlr_ns) },
-            .writefn = sctlr_write, .resetvalue = cpu->reset_sctlr,
+            .writefn = sctlr_el1_write, .resetvalue = cpu->reset_sctlr,
             .raw_writefn = raw_write,
         };
         if (arm_feature(env, ARM_FEATURE_XSCALE)) {
@@ -8240,6 +8474,16 @@ void register_cp_regs_for_features(ARMCP
         }
         define_one_arm_cp_reg(cpu, &sctlr);
     }
+    if (arm_feature(env, ARM_FEATURE_AARCH64)) {
+        ARMCPRegInfo vmsa_lock_el1 = {
+            .name = "VMSA_LOCK_EL1", .state = ARM_CP_STATE_AA64,
+            .opc0 = 3, .opc1 = 4, .crn = 15, .crm = 1, .opc2 = 2,
+            .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.vmsa_lock_el1),
+            .writefn = vmsa_lock_el1_write, .resetvalue = 0,
+            .raw_writefn = raw_write,
+        };
+        define_one_arm_cp_reg(cpu, &vmsa_lock_el1);
+    }
 
     if (cpu_isar_feature(aa64_lor, cpu)) {
         define_arm_cp_regs(cpu, lor_reginfo);
@@ -8667,11 +8911,11 @@ void define_one_arm_cp_reg_with_opaque(A
         case 4:
         case 5:
             /* min_EL EL2 */
-            mask = PL2_RW;
+            mask = PL1_RW;
             break;
         case 6:
             /* min_EL EL3 */
-            mask = PL3_RW;
+            mask = PL1_RW;
             break;
         case 7:
             /* min_EL EL1, secure mode only (we don't check the latter) */
@@ -9226,6 +9470,7 @@ void arm_log_exception(int idx)
             [EXCP_LAZYFP] = "v7M exception during lazy FP stacking",
             [EXCP_LSERR] = "v8M LSERR UsageFault",
             [EXCP_UNALIGNED] = "v7M UNALIGNED UsageFault",
+            [EXCP_GENTER] = "Guarded execution enter",
         };
 
         if (idx >= 0 && idx < ARRAY_SIZE(excnames)) {
@@ -9850,12 +10095,21 @@ static void arm_cpu_do_interrupt_aarch64
     ARMCPU *cpu = ARM_CPU(cs);
     CPUARMState *env = &cpu->env;
     unsigned int new_el = env->exception.target_el;
-    target_ulong addr = env->cp15.vbar_el[new_el];
-    unsigned int new_mode = aarch64_pstate_mode(new_el, true);
-    unsigned int old_mode;
-    unsigned int cur_el = arm_current_el(env);
+    target_ulong addr = 0;
+    bool genter = false;
+    unsigned int new_mode, old_mode, cur_el;
     int rt;
 
+    if (env->gxf.guarded) {
+        addr = env->gxf.vbar_gl[new_el];
+    } else {
+        addr = env->cp15.vbar_el[new_el];
+    }
+
+    new_mode = aarch64_pstate_mode(new_el, true);
+    old_mode;
+    cur_el = arm_current_el(env);
+
     /*
      * Note that new_el can never be 0.  If cur_el is 0, then
      * el0_a64 is is_a64(), else el0_a64 is ignored.
@@ -9899,9 +10153,15 @@ static void arm_cpu_do_interrupt_aarch64
     switch (cs->exception_index) {
     case EXCP_PREFETCH_ABORT:
     case EXCP_DATA_ABORT:
-        env->cp15.far_el[new_el] = env->exception.vaddress;
-        qemu_log_mask(CPU_LOG_INT, "...with FAR 0x%" PRIx64 "\n",
-                      env->cp15.far_el[new_el]);
+        if (env->gxf.guarded) {
+            env->gxf.far_gl[new_el] = env->exception.vaddress;
+            qemu_log_mask(CPU_LOG_INT, "...with FAR 0x%" PRIx64 "\n",
+                        env->gxf.far_gl[new_el]);
+        } else {
+            env->cp15.far_el[new_el] = env->exception.vaddress;
+            qemu_log_mask(CPU_LOG_INT, "...with FAR 0x%" PRIx64 "\n",
+                        env->cp15.far_el[new_el]);
+        }
         /* fall through */
     case EXCP_BKPT:
     case EXCP_UDEF:
@@ -9947,7 +10207,12 @@ static void arm_cpu_do_interrupt_aarch64
                                                 10, 5, rt);
             break;
         }
-        env->cp15.esr_el[new_el] = env->exception.syndrome;
+
+        if (env->gxf.guarded) {
+            env->gxf.esr_gl[new_el] = env->exception.syndrome;
+        } else {
+            env->cp15.esr_el[new_el] = env->exception.syndrome;
+        }
         break;
     case EXCP_IRQ:
     case EXCP_VIRQ:
@@ -9957,6 +10222,10 @@ static void arm_cpu_do_interrupt_aarch64
     case EXCP_VFIQ:
         addr += 0x100;
         break;
+    case EXCP_GENTER:
+        addr = env->gxf.gxf_entry_el[new_el];
+        genter = true;
+        break;
     default:
         cpu_abort(cs, "Unhandled exception 0x%x\n", cs->exception_index);
     }
@@ -9964,7 +10233,12 @@ static void arm_cpu_do_interrupt_aarch64
     if (is_a64(env)) {
         old_mode = pstate_read(env);
         aarch64_save_sp(env, arm_current_el(env));
-        env->elr_el[new_el] = env->pc;
+
+        if (genter || env->gxf.guarded) {
+            env->gxf.elr_gl[new_el] = env->pc;
+        } else {
+            env->elr_el[new_el] = env->pc;
+        }
     } else {
         old_mode = cpsr_read_for_spsr_elx(env);
         env->elr_el[new_el] = env->regs[15];
@@ -9973,10 +10247,20 @@ static void arm_cpu_do_interrupt_aarch64
 
         env->condexec_bits = 0;
     }
-    env->banked_spsr[aarch64_banked_spsr_index(new_el)] = old_mode;
 
-    qemu_log_mask(CPU_LOG_INT, "...with ELR 0x%" PRIx64 "\n",
-                  env->elr_el[new_el]);
+    if (genter || env->gxf.guarded) {
+        env->gxf.spsr_gl[new_el] = old_mode;
+    } else {
+        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = old_mode;
+    }
+
+    if (genter || env->gxf.guarded) {
+        qemu_log_mask(CPU_LOG_INT, "...with ELR 0x%" PRIx64 "\n",
+                    env->gxf.elr_gl[new_el]);
+    } else {
+        qemu_log_mask(CPU_LOG_INT, "...with ELR 0x%" PRIx64 "\n",
+                    env->elr_el[new_el]);
+    }
 
     if (cpu_isar_feature(aa64_pan, cpu)) {
         /* The value of PSTATE.PAN is normally preserved, except when ... */
@@ -10011,8 +10295,11 @@ static void arm_cpu_do_interrupt_aarch64
     }
 
     pstate_write(env, PSTATE_DAIF | new_mode);
+    env->gxf.guarded |= genter;
     env->aarch64 = 1;
     aarch64_restore_sp(env, new_el);
+    //TODO: MMU in GXF?
+
     helper_rebuild_hflags_a64(env, new_el);
 
     env->pc = addr;
@@ -12984,42 +13271,42 @@ ARMMMUIdx arm_stage1_mmu_idx(CPUARMState
 }
 #endif
 
-static uint32_t rebuild_hflags_common(CPUARMState *env, int fp_el,
-                                      ARMMMUIdx mmu_idx, uint32_t flags)
+static uint64_t rebuild_hflags_common(CPUARMState *env, int fp_el,
+                                      ARMMMUIdx mmu_idx, uint64_t flags)
 {
-    flags = FIELD_DP32(flags, TBFLAG_ANY, FPEXC_EL, fp_el);
-    flags = FIELD_DP32(flags, TBFLAG_ANY, MMUIDX,
+    flags = FIELD_DP64(flags, TBFLAG_ANY, FPEXC_EL, fp_el);
+    flags = FIELD_DP64(flags, TBFLAG_ANY, MMUIDX,
                        arm_to_core_mmu_idx(mmu_idx));
 
     if (arm_singlestep_active(env)) {
-        flags = FIELD_DP32(flags, TBFLAG_ANY, SS_ACTIVE, 1);
+        flags = FIELD_DP64(flags, TBFLAG_ANY, SS_ACTIVE, 1);
     }
     return flags;
 }
 
-static uint32_t rebuild_hflags_common_32(CPUARMState *env, int fp_el,
-                                         ARMMMUIdx mmu_idx, uint32_t flags)
+static uint64_t rebuild_hflags_common_32(CPUARMState *env, int fp_el,
+                                         ARMMMUIdx mmu_idx, uint64_t flags)
 {
     bool sctlr_b = arm_sctlr_b(env);
 
     if (sctlr_b) {
-        flags = FIELD_DP32(flags, TBFLAG_A32, SCTLR_B, 1);
+        flags = FIELD_DP64(flags, TBFLAG_A32, SCTLR_B, 1);
     }
     if (arm_cpu_data_is_big_endian_a32(env, sctlr_b)) {
-        flags = FIELD_DP32(flags, TBFLAG_ANY, BE_DATA, 1);
+        flags = FIELD_DP64(flags, TBFLAG_ANY, BE_DATA, 1);
     }
-    flags = FIELD_DP32(flags, TBFLAG_A32, NS, !access_secure_reg(env));
+    flags = FIELD_DP64(flags, TBFLAG_A32, NS, !access_secure_reg(env));
 
     return rebuild_hflags_common(env, fp_el, mmu_idx, flags);
 }
 
-static uint32_t rebuild_hflags_m32(CPUARMState *env, int fp_el,
+static uint64_t rebuild_hflags_m32(CPUARMState *env, int fp_el,
                                    ARMMMUIdx mmu_idx)
 {
-    uint32_t flags = 0;
+    uint64_t flags = 0;
 
     if (arm_v7m_is_handler_mode(env)) {
-        flags = FIELD_DP32(flags, TBFLAG_M32, HANDLER, 1);
+        flags = FIELD_DP64(flags, TBFLAG_M32, HANDLER, 1);
     }
 
     /*
@@ -13030,55 +13317,55 @@ static uint32_t rebuild_hflags_m32(CPUAR
     if (arm_feature(env, ARM_FEATURE_V8) &&
         !((mmu_idx & ARM_MMU_IDX_M_NEGPRI) &&
           (env->v7m.ccr[env->v7m.secure] & R_V7M_CCR_STKOFHFNMIGN_MASK))) {
-        flags = FIELD_DP32(flags, TBFLAG_M32, STACKCHECK, 1);
+        flags = FIELD_DP64(flags, TBFLAG_M32, STACKCHECK, 1);
     }
 
     return rebuild_hflags_common_32(env, fp_el, mmu_idx, flags);
 }
 
-static uint32_t rebuild_hflags_aprofile(CPUARMState *env)
+static uint64_t rebuild_hflags_aprofile(CPUARMState *env)
 {
-    int flags = 0;
+    uint64_t flags = 0;
 
-    flags = FIELD_DP32(flags, TBFLAG_ANY, DEBUG_TARGET_EL,
+    flags = FIELD_DP64(flags, TBFLAG_ANY, DEBUG_TARGET_EL,
                        arm_debug_target_el(env));
     return flags;
 }
 
-static uint32_t rebuild_hflags_a32(CPUARMState *env, int fp_el,
+static uint64_t rebuild_hflags_a32(CPUARMState *env, int fp_el,
                                    ARMMMUIdx mmu_idx)
 {
-    uint32_t flags = rebuild_hflags_aprofile(env);
+    uint64_t flags = rebuild_hflags_aprofile(env);
 
     if (arm_el_is_aa64(env, 1)) {
-        flags = FIELD_DP32(flags, TBFLAG_A32, VFPEN, 1);
+        flags = FIELD_DP64(flags, TBFLAG_A32, VFPEN, 1);
     }
 
     if (arm_current_el(env) < 2 && env->cp15.hstr_el2 &&
         (arm_hcr_el2_eff(env) & (HCR_E2H | HCR_TGE)) != (HCR_E2H | HCR_TGE)) {
-        flags = FIELD_DP32(flags, TBFLAG_A32, HSTR_ACTIVE, 1);
+        flags = FIELD_DP64(flags, TBFLAG_A32, HSTR_ACTIVE, 1);
     }
 
     return rebuild_hflags_common_32(env, fp_el, mmu_idx, flags);
 }
 
-static uint32_t rebuild_hflags_a64(CPUARMState *env, int el, int fp_el,
+static uint64_t rebuild_hflags_a64(CPUARMState *env, int el, int fp_el,
                                    ARMMMUIdx mmu_idx)
 {
-    uint32_t flags = rebuild_hflags_aprofile(env);
+    uint64_t flags = rebuild_hflags_aprofile(env);
     ARMMMUIdx stage1 = stage_1_mmu_idx(mmu_idx);
     uint64_t tcr = regime_tcr(env, mmu_idx)->raw_tcr;
     uint64_t sctlr;
     int tbii, tbid;
 
-    flags = FIELD_DP32(flags, TBFLAG_ANY, AARCH64_STATE, 1);
+    flags = FIELD_DP64(flags, TBFLAG_ANY, AARCH64_STATE, 1);
 
     /* Get control bits for tagged addresses.  */
     tbid = aa64_va_parameter_tbi(tcr, mmu_idx);
     tbii = tbid & ~aa64_va_parameter_tbid(tcr, mmu_idx);
 
-    flags = FIELD_DP32(flags, TBFLAG_A64, TBII, tbii);
-    flags = FIELD_DP32(flags, TBFLAG_A64, TBID, tbid);
+    flags = FIELD_DP64(flags, TBFLAG_A64, TBII, tbii);
+    flags = FIELD_DP64(flags, TBFLAG_A64, TBID, tbid);
 
     if (cpu_isar_feature(aa64_sve, env_archcpu(env))) {
         int sve_el = sve_exception_el(env, el);
@@ -13093,14 +13380,14 @@ static uint32_t rebuild_hflags_a64(CPUAR
         } else {
             zcr_len = sve_zcr_len_for_el(env, el);
         }
-        flags = FIELD_DP32(flags, TBFLAG_A64, SVEEXC_EL, sve_el);
-        flags = FIELD_DP32(flags, TBFLAG_A64, ZCR_LEN, zcr_len);
+        flags = FIELD_DP64(flags, TBFLAG_A64, SVEEXC_EL, sve_el);
+        flags = FIELD_DP64(flags, TBFLAG_A64, ZCR_LEN, zcr_len);
     }
 
     sctlr = regime_sctlr(env, stage1);
 
     if (arm_cpu_data_is_big_endian_a64(el, sctlr)) {
-        flags = FIELD_DP32(flags, TBFLAG_ANY, BE_DATA, 1);
+        flags = FIELD_DP64(flags, TBFLAG_ANY, BE_DATA, 1);
     }
 
     if (cpu_isar_feature(aa64_pauth, env_archcpu(env))) {
@@ -13111,14 +13398,18 @@ static uint32_t rebuild_hflags_a64(CPUAR
          * The decision of which action to take is left to a helper.
          */
         if (sctlr & (SCTLR_EnIA | SCTLR_EnIB | SCTLR_EnDA | SCTLR_EnDB)) {
-            flags = FIELD_DP32(flags, TBFLAG_A64, PAUTH_ACTIVE, 1);
+            flags = FIELD_DP64(flags, TBFLAG_A64, PAUTH_ACTIVE, 1);
         }
     }
 
+    if (env->gxf.guarded) {
+        flags = FIELD_DP64(flags, TBFLAG_A64, GUARDED, 1);
+    }
+
     if (cpu_isar_feature(aa64_bti, env_archcpu(env))) {
         /* Note that SCTLR_EL[23].BT == SCTLR_BT1.  */
         if (sctlr & (el == 0 ? SCTLR_BT0 : SCTLR_BT1)) {
-            flags = FIELD_DP32(flags, TBFLAG_A64, BT, 1);
+            flags = FIELD_DP64(flags, TBFLAG_A64, BT, 1);
         }
     }
 
@@ -13130,7 +13421,7 @@ static uint32_t rebuild_hflags_a64(CPUAR
         case ARMMMUIdx_SE10_1:
         case ARMMMUIdx_SE10_1_PAN:
             /* TODO: ARMv8.3-NV */
-            flags = FIELD_DP32(flags, TBFLAG_A64, UNPRIV, 1);
+            flags = FIELD_DP64(flags, TBFLAG_A64, UNPRIV, 1);
             break;
         case ARMMMUIdx_E20_2:
         case ARMMMUIdx_E20_2_PAN:
@@ -13141,7 +13432,7 @@ static uint32_t rebuild_hflags_a64(CPUAR
              * gated by HCR_EL2.<E2H,TGE> == '11', and so is LDTR.
              */
             if (env->cp15.hcr_el2 & HCR_TGE) {
-                flags = FIELD_DP32(flags, TBFLAG_A64, UNPRIV, 1);
+                flags = FIELD_DP64(flags, TBFLAG_A64, UNPRIV, 1);
             }
             break;
         default:
@@ -13159,30 +13450,30 @@ static uint32_t rebuild_hflags_a64(CPUAR
          * 4) If no Allocation Tag Access, then all accesses are Unchecked.
          */
         if (allocation_tag_access_enabled(env, el, sctlr)) {
-            flags = FIELD_DP32(flags, TBFLAG_A64, ATA, 1);
+            flags = FIELD_DP64(flags, TBFLAG_A64, ATA, 1);
             if (tbid
                 && !(env->pstate & PSTATE_TCO)
                 && (sctlr & (el == 0 ? SCTLR_TCF0 : SCTLR_TCF))) {
-                flags = FIELD_DP32(flags, TBFLAG_A64, MTE_ACTIVE, 1);
+                flags = FIELD_DP64(flags, TBFLAG_A64, MTE_ACTIVE, 1);
             }
         }
         /* And again for unprivileged accesses, if required.  */
-        if (FIELD_EX32(flags, TBFLAG_A64, UNPRIV)
+        if (FIELD_EX64(flags, TBFLAG_A64, UNPRIV)
             && tbid
             && !(env->pstate & PSTATE_TCO)
             && (sctlr & SCTLR_TCF0)
             && allocation_tag_access_enabled(env, 0, sctlr)) {
-            flags = FIELD_DP32(flags, TBFLAG_A64, MTE0_ACTIVE, 1);
+            flags = FIELD_DP64(flags, TBFLAG_A64, MTE0_ACTIVE, 1);
         }
         /* Cache TCMA as well as TBI. */
-        flags = FIELD_DP32(flags, TBFLAG_A64, TCMA,
+        flags = FIELD_DP64(flags, TBFLAG_A64, TCMA,
                            aa64_va_parameter_tcma(tcr, mmu_idx));
     }
 
     return rebuild_hflags_common(env, fp_el, mmu_idx, flags);
 }
 
-static uint32_t rebuild_hflags_internal(CPUARMState *env)
+static uint64_t rebuild_hflags_internal(CPUARMState *env)
 {
     int el = arm_current_el(env);
     int fp_el = fp_exception_el(env, el);
@@ -13253,11 +13544,11 @@ void HELPER(rebuild_hflags_a64)(CPUARMSt
 static inline void assert_hflags_rebuild_correctly(CPUARMState *env)
 {
 #ifdef CONFIG_DEBUG_TCG
-    uint32_t env_flags_current = env->hflags;
-    uint32_t env_flags_rebuilt = rebuild_hflags_internal(env);
+    uint64_t env_flags_current = env->hflags;
+    uint64_t env_flags_rebuilt = rebuild_hflags_internal(env);
 
     if (unlikely(env_flags_current != env_flags_rebuilt)) {
-        fprintf(stderr, "TCG hflags mismatch (current:0x%08x rebuilt:0x%08x)\n",
+        fprintf(stderr, "TCG hflags mismatch (current:0x" TARGET_FMT_plx " rebuilt:0x" TARGET_FMT_plx ")\n",
                 env_flags_current, env_flags_rebuilt);
         abort();
     }
@@ -13265,17 +13556,17 @@ static inline void assert_hflags_rebuild
 }
 
 void cpu_get_tb_cpu_state(CPUARMState *env, target_ulong *pc,
-                          target_ulong *cs_base, uint32_t *pflags)
+                          target_ulong *cs_base, uint64_t *pflags)
 {
-    uint32_t flags = env->hflags;
+    uint64_t flags = env->hflags;
 
     *cs_base = 0;
     assert_hflags_rebuild_correctly(env);
 
-    if (FIELD_EX32(flags, TBFLAG_ANY, AARCH64_STATE)) {
+    if (FIELD_EX64(flags, TBFLAG_ANY, AARCH64_STATE)) {
         *pc = env->pc;
         if (cpu_isar_feature(aa64_bti, env_archcpu(env))) {
-            flags = FIELD_DP32(flags, TBFLAG_A64, BTYPE, env->btype);
+            flags = FIELD_DP64(flags, TBFLAG_A64, BTYPE, env->btype);
         }
     } else {
         *pc = env->regs[15];
@@ -13284,7 +13575,7 @@ void cpu_get_tb_cpu_state(CPUARMState *e
             if (arm_feature(env, ARM_FEATURE_M_SECURITY) &&
                 FIELD_EX32(env->v7m.fpccr[M_REG_S], V7M_FPCCR, S)
                 != env->v7m.secure) {
-                flags = FIELD_DP32(flags, TBFLAG_M32, FPCCR_S_WRONG, 1);
+                flags = FIELD_DP64(flags, TBFLAG_M32, FPCCR_S_WRONG, 1);
             }
 
             if ((env->v7m.fpccr[env->v7m.secure] & R_V7M_FPCCR_ASPEN_MASK) &&
@@ -13296,12 +13587,12 @@ void cpu_get_tb_cpu_state(CPUARMState *e
                  * active FP context; we must create a new FP context before
                  * executing any FP insn.
                  */
-                flags = FIELD_DP32(flags, TBFLAG_M32, NEW_FP_CTXT_NEEDED, 1);
+                flags = FIELD_DP64(flags, TBFLAG_M32, NEW_FP_CTXT_NEEDED, 1);
             }
 
             bool is_secure = env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_S_MASK;
             if (env->v7m.fpccr[is_secure] & R_V7M_FPCCR_LSPACT_MASK) {
-                flags = FIELD_DP32(flags, TBFLAG_M32, LSPACT, 1);
+                flags = FIELD_DP64(flags, TBFLAG_M32, LSPACT, 1);
             }
         } else {
             /*
@@ -13309,21 +13600,21 @@ void cpu_get_tb_cpu_state(CPUARMState *e
              * Note that VECLEN+VECSTRIDE are RES0 for M-profile.
              */
             if (arm_feature(env, ARM_FEATURE_XSCALE)) {
-                flags = FIELD_DP32(flags, TBFLAG_A32,
+                flags = FIELD_DP64(flags, TBFLAG_A32,
                                    XSCALE_CPAR, env->cp15.c15_cpar);
             } else {
-                flags = FIELD_DP32(flags, TBFLAG_A32, VECLEN,
+                flags = FIELD_DP64(flags, TBFLAG_A32, VECLEN,
                                    env->vfp.vec_len);
-                flags = FIELD_DP32(flags, TBFLAG_A32, VECSTRIDE,
+                flags = FIELD_DP64(flags, TBFLAG_A32, VECSTRIDE,
                                    env->vfp.vec_stride);
             }
             if (env->vfp.xregs[ARM_VFP_FPEXC] & (1 << 30)) {
-                flags = FIELD_DP32(flags, TBFLAG_A32, VFPEN, 1);
+                flags = FIELD_DP64(flags, TBFLAG_A32, VFPEN, 1);
             }
         }
 
-        flags = FIELD_DP32(flags, TBFLAG_AM32, THUMB, env->thumb);
-        flags = FIELD_DP32(flags, TBFLAG_AM32, CONDEXEC, env->condexec_bits);
+        flags = FIELD_DP64(flags, TBFLAG_AM32, THUMB, env->thumb);
+        flags = FIELD_DP64(flags, TBFLAG_AM32, CONDEXEC, env->condexec_bits);
     }
 
     /*
@@ -13335,9 +13626,9 @@ void cpu_get_tb_cpu_state(CPUARMState *e
      *     1            1       Active-not-pending
      * SS_ACTIVE is set in hflags; PSTATE_SS is computed every TB.
      */
-    if (FIELD_EX32(flags, TBFLAG_ANY, SS_ACTIVE) &&
+    if (FIELD_EX64(flags, TBFLAG_ANY, SS_ACTIVE) &&
         (env->pstate & PSTATE_SS)) {
-        flags = FIELD_DP32(flags, TBFLAG_ANY, PSTATE_SS, 1);
+        flags = FIELD_DP64(flags, TBFLAG_ANY, PSTATE_SS, 1);
     }
 
     *pflags = flags;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/internals.h qemu-t8030-private/target/arm/internals.h
--- qemu-6.0.0/target/arm/internals.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/internals.h	2021-05-05 10:12:56.005664300 +0800
@@ -191,7 +191,11 @@ int arm_rmode_to_sf(int rmode);
 static inline void aarch64_save_sp(CPUARMState *env, int el)
 {
     if (env->pstate & PSTATE_SP) {
-        env->sp_el[el] = env->xregs[31];
+        if (env->gxf.guarded) {
+            env->gxf.sp_gl[el] = env->xregs[31];
+        } else {
+            env->sp_el[el] = env->xregs[31];
+        }
     } else {
         env->sp_el[0] = env->xregs[31];
     }
@@ -200,7 +204,11 @@ static inline void aarch64_save_sp(CPUAR
 static inline void aarch64_restore_sp(CPUARMState *env, int el)
 {
     if (env->pstate & PSTATE_SP) {
-        env->xregs[31] = env->sp_el[el];
+        if (env->gxf.guarded) {
+            env->xregs[31] = env->gxf.sp_gl[el];
+        } else {
+            env->xregs[31] = env->sp_el[el];
+        }
     } else {
         env->xregs[31] = env->sp_el[0];
     }
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/pauth_helper.c qemu-t8030-private/target/arm/pauth_helper.c
--- qemu-6.0.0/target/arm/pauth_helper.c	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/pauth_helper.c	2021-05-05 10:12:56.019519300 +0800
@@ -411,7 +411,9 @@ static void pauth_check_trap(CPUARMState
 
 static bool pauth_key_enabled(CPUARMState *env, int el, uint32_t bit)
 {
-    return (arm_sctlr(env, el) & bit) != 0;
+    //TODO: PAC?
+    return false;
+    //return (arm_sctlr(env, el) & bit) != 0;
 }
 
 uint64_t HELPER(pacia)(CPUARMState *env, uint64_t x, uint64_t y)
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/translate-a64.c qemu-t8030-private/target/arm/translate-a64.c
--- qemu-6.0.0/target/arm/translate-a64.c	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/translate-a64.c	2021-05-06 00:20:19.698128600 +0800
@@ -2274,8 +2274,14 @@ static void disas_uncond_b_reg(DisasCont
                 goto do_unallocated;
             }
             dst = tcg_temp_new_i64();
-            tcg_gen_ld_i64(dst, cpu_env,
-                           offsetof(CPUARMState, elr_el[s->current_el]));
+
+            if (s->guarded) {
+                tcg_gen_ld_i64(dst, cpu_env,
+                            offsetof(CPUARMState, gxf.elr_gl[s->current_el]));
+            } else {
+                tcg_gen_ld_i64(dst, cpu_env,
+                            offsetof(CPUARMState, elr_el[s->current_el]));
+            }
             break;
 
         case 2: /* ERETAA */
@@ -2287,8 +2293,14 @@ static void disas_uncond_b_reg(DisasCont
                 goto do_unallocated;
             }
             dst = tcg_temp_new_i64();
-            tcg_gen_ld_i64(dst, cpu_env,
-                           offsetof(CPUARMState, elr_el[s->current_el]));
+            if (s->guarded) {
+                tcg_gen_ld_i64(dst, cpu_env,
+                            offsetof(CPUARMState, gxf.elr_gl[s->current_el]));
+            } else {
+                tcg_gen_ld_i64(dst, cpu_env,
+                            offsetof(CPUARMState, elr_el[s->current_el]));
+            }
+
             if (s->pauth_active) {
                 modifier = cpu_X[31];
                 if (op3 == 2) {
@@ -14569,6 +14581,33 @@ static bool btype_destination_ok(uint32_
     return false;
 }
 
+static void disas_gxf_insn(DisasContext *s, uint32_t insn)
+{
+    switch (insn) {
+        case 0x00201420: /* GENTER */
+            if (s->current_el == 0 || s->guarded) {
+                unallocated_encoding(s);
+                break;
+            }
+            gen_a64_set_pc_im(s->pc_curr);
+            gen_ss_advance(s);
+            gen_exception_insn(s, s->base.pc_next, EXCP_GENTER, syn_uncategorized(), s->current_el);
+            break;
+
+        case 0x00201400: /* GEXIT */
+            if (s->current_el == 0 || !s->guarded) {
+                unallocated_encoding(s);
+                break;
+            }
+            gen_helper_gexit(cpu_env);
+            s->base.is_jmp = DISAS_EXIT;
+            break;
+
+        default:
+            unallocated_encoding(s);
+    }
+}
+
 /* C3.1 A64 instruction index by encoding */
 static void disas_a64_insn(CPUARMState *env, DisasContext *s)
 {
@@ -14621,7 +14660,10 @@ static void disas_a64_insn(CPUARMState *
     }
 
     switch (extract32(insn, 25, 4)) {
-    case 0x0: case 0x1: case 0x3: /* UNALLOCATED */
+    case 0x0:
+        disas_gxf_insn(s, insn);
+        break;
+    case 0x1: case 0x3: /* UNALLOCATED */
         unallocated_encoding(s);
         break;
     case 0x2:
@@ -14672,7 +14714,7 @@ static void aarch64_tr_init_disas_contex
     DisasContext *dc = container_of(dcbase, DisasContext, base);
     CPUARMState *env = cpu->env_ptr;
     ARMCPU *arm_cpu = env_archcpu(env);
-    uint32_t tb_flags = dc->base.tb->flags;
+    uint64_t tb_flags = dc->base.tb->flags;
     int bound, core_mmu_idx;
 
     dc->isar = &arm_cpu->isar;
@@ -14686,28 +14728,29 @@ static void aarch64_tr_init_disas_contex
                                !arm_el_is_aa64(env, 3);
     dc->thumb = 0;
     dc->sctlr_b = 0;
-    dc->be_data = FIELD_EX32(tb_flags, TBFLAG_ANY, BE_DATA) ? MO_BE : MO_LE;
+    dc->be_data = FIELD_EX64(tb_flags, TBFLAG_ANY, BE_DATA) ? MO_BE : MO_LE;
     dc->condexec_mask = 0;
     dc->condexec_cond = 0;
-    core_mmu_idx = FIELD_EX32(tb_flags, TBFLAG_ANY, MMUIDX);
+    core_mmu_idx = FIELD_EX64(tb_flags, TBFLAG_ANY, MMUIDX);
     dc->mmu_idx = core_to_aa64_mmu_idx(core_mmu_idx);
-    dc->tbii = FIELD_EX32(tb_flags, TBFLAG_A64, TBII);
-    dc->tbid = FIELD_EX32(tb_flags, TBFLAG_A64, TBID);
-    dc->tcma = FIELD_EX32(tb_flags, TBFLAG_A64, TCMA);
+    dc->tbii = FIELD_EX64(tb_flags, TBFLAG_A64, TBII);
+    dc->tbid = FIELD_EX64(tb_flags, TBFLAG_A64, TBID);
+    dc->tcma = FIELD_EX64(tb_flags, TBFLAG_A64, TCMA);
     dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);
 #if !defined(CONFIG_USER_ONLY)
     dc->user = (dc->current_el == 0);
 #endif
-    dc->fp_excp_el = FIELD_EX32(tb_flags, TBFLAG_ANY, FPEXC_EL);
-    dc->sve_excp_el = FIELD_EX32(tb_flags, TBFLAG_A64, SVEEXC_EL);
-    dc->sve_len = (FIELD_EX32(tb_flags, TBFLAG_A64, ZCR_LEN) + 1) * 16;
-    dc->pauth_active = FIELD_EX32(tb_flags, TBFLAG_A64, PAUTH_ACTIVE);
-    dc->bt = FIELD_EX32(tb_flags, TBFLAG_A64, BT);
-    dc->btype = FIELD_EX32(tb_flags, TBFLAG_A64, BTYPE);
-    dc->unpriv = FIELD_EX32(tb_flags, TBFLAG_A64, UNPRIV);
-    dc->ata = FIELD_EX32(tb_flags, TBFLAG_A64, ATA);
-    dc->mte_active[0] = FIELD_EX32(tb_flags, TBFLAG_A64, MTE_ACTIVE);
-    dc->mte_active[1] = FIELD_EX32(tb_flags, TBFLAG_A64, MTE0_ACTIVE);
+    dc->guarded = FIELD_EX64(tb_flags, TBFLAG_A64, GUARDED);
+    dc->fp_excp_el = FIELD_EX64(tb_flags, TBFLAG_ANY, FPEXC_EL);
+    dc->sve_excp_el = FIELD_EX64(tb_flags, TBFLAG_A64, SVEEXC_EL);
+    dc->sve_len = (FIELD_EX64(tb_flags, TBFLAG_A64, ZCR_LEN) + 1) * 16;
+    dc->pauth_active = FIELD_EX64(tb_flags, TBFLAG_A64, PAUTH_ACTIVE);
+    dc->bt = FIELD_EX64(tb_flags, TBFLAG_A64, BT);
+    dc->btype = FIELD_EX64(tb_flags, TBFLAG_A64, BTYPE);
+    dc->unpriv = FIELD_EX64(tb_flags, TBFLAG_A64, UNPRIV);
+    dc->ata = FIELD_EX64(tb_flags, TBFLAG_A64, ATA);
+    dc->mte_active[0] = FIELD_EX64(tb_flags, TBFLAG_A64, MTE_ACTIVE);
+    dc->mte_active[1] = FIELD_EX64(tb_flags, TBFLAG_A64, MTE0_ACTIVE);
     dc->vec_len = 0;
     dc->vec_stride = 0;
     dc->cp_regs = arm_cpu->cp_regs;
@@ -14734,10 +14777,10 @@ static void aarch64_tr_init_disas_contex
      *   emit code to generate a software step exception
      *   end the TB
      */
-    dc->ss_active = FIELD_EX32(tb_flags, TBFLAG_ANY, SS_ACTIVE);
-    dc->pstate_ss = FIELD_EX32(tb_flags, TBFLAG_ANY, PSTATE_SS);
+    dc->ss_active = FIELD_EX64(tb_flags, TBFLAG_ANY, SS_ACTIVE);
+    dc->pstate_ss = FIELD_EX64(tb_flags, TBFLAG_ANY, PSTATE_SS);
     dc->is_ldex = false;
-    dc->debug_target_el = FIELD_EX32(tb_flags, TBFLAG_ANY, DEBUG_TARGET_EL);
+    dc->debug_target_el = FIELD_EX64(tb_flags, TBFLAG_ANY, DEBUG_TARGET_EL);
 
     /* Bound the number of insns to execute to those left on the page.  */
     bound = -(dc->base.pc_first | TARGET_PAGE_MASK) / 4;
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/translate.c qemu-t8030-private/target/arm/translate.c
--- qemu-6.0.0/target/arm/translate.c	2021-04-30 01:18:59.000000000 +0800
+++ qemu-t8030-private/target/arm/translate.c	2021-05-05 10:12:56.038390500 +0800
@@ -8848,46 +8848,46 @@ static void arm_tr_init_disas_context(Di
      */
     dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&
                                !arm_el_is_aa64(env, 3);
-    dc->thumb = FIELD_EX32(tb_flags, TBFLAG_AM32, THUMB);
-    dc->be_data = FIELD_EX32(tb_flags, TBFLAG_ANY, BE_DATA) ? MO_BE : MO_LE;
-    condexec = FIELD_EX32(tb_flags, TBFLAG_AM32, CONDEXEC);
+    dc->thumb = FIELD_EX64(tb_flags, TBFLAG_AM32, THUMB);
+    dc->be_data = FIELD_EX64(tb_flags, TBFLAG_ANY, BE_DATA) ? MO_BE : MO_LE;
+    condexec = FIELD_EX64(tb_flags, TBFLAG_AM32, CONDEXEC);
     dc->condexec_mask = (condexec & 0xf) << 1;
     dc->condexec_cond = condexec >> 4;
 
-    core_mmu_idx = FIELD_EX32(tb_flags, TBFLAG_ANY, MMUIDX);
+    core_mmu_idx = FIELD_EX64(tb_flags, TBFLAG_ANY, MMUIDX);
     dc->mmu_idx = core_to_arm_mmu_idx(env, core_mmu_idx);
     dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);
 #if !defined(CONFIG_USER_ONLY)
     dc->user = (dc->current_el == 0);
 #endif
-    dc->fp_excp_el = FIELD_EX32(tb_flags, TBFLAG_ANY, FPEXC_EL);
+    dc->fp_excp_el = FIELD_EX64(tb_flags, TBFLAG_ANY, FPEXC_EL);
 
     if (arm_feature(env, ARM_FEATURE_M)) {
         dc->vfp_enabled = 1;
         dc->be_data = MO_TE;
-        dc->v7m_handler_mode = FIELD_EX32(tb_flags, TBFLAG_M32, HANDLER);
+        dc->v7m_handler_mode = FIELD_EX64(tb_flags, TBFLAG_M32, HANDLER);
         dc->v8m_secure = arm_feature(env, ARM_FEATURE_M_SECURITY) &&
             regime_is_secure(env, dc->mmu_idx);
-        dc->v8m_stackcheck = FIELD_EX32(tb_flags, TBFLAG_M32, STACKCHECK);
+        dc->v8m_stackcheck = FIELD_EX64(tb_flags, TBFLAG_M32, STACKCHECK);
         dc->v8m_fpccr_s_wrong =
-            FIELD_EX32(tb_flags, TBFLAG_M32, FPCCR_S_WRONG);
+            FIELD_EX64(tb_flags, TBFLAG_M32, FPCCR_S_WRONG);
         dc->v7m_new_fp_ctxt_needed =
-            FIELD_EX32(tb_flags, TBFLAG_M32, NEW_FP_CTXT_NEEDED);
-        dc->v7m_lspact = FIELD_EX32(tb_flags, TBFLAG_M32, LSPACT);
+            FIELD_EX64(tb_flags, TBFLAG_M32, NEW_FP_CTXT_NEEDED);
+        dc->v7m_lspact = FIELD_EX64(tb_flags, TBFLAG_M32, LSPACT);
     } else {
         dc->be_data =
-            FIELD_EX32(tb_flags, TBFLAG_ANY, BE_DATA) ? MO_BE : MO_LE;
+            FIELD_EX64(tb_flags, TBFLAG_ANY, BE_DATA) ? MO_BE : MO_LE;
         dc->debug_target_el =
-            FIELD_EX32(tb_flags, TBFLAG_ANY, DEBUG_TARGET_EL);
-        dc->sctlr_b = FIELD_EX32(tb_flags, TBFLAG_A32, SCTLR_B);
-        dc->hstr_active = FIELD_EX32(tb_flags, TBFLAG_A32, HSTR_ACTIVE);
-        dc->ns = FIELD_EX32(tb_flags, TBFLAG_A32, NS);
-        dc->vfp_enabled = FIELD_EX32(tb_flags, TBFLAG_A32, VFPEN);
+            FIELD_EX64(tb_flags, TBFLAG_ANY, DEBUG_TARGET_EL);
+        dc->sctlr_b = FIELD_EX64(tb_flags, TBFLAG_A32, SCTLR_B);
+        dc->hstr_active = FIELD_EX64(tb_flags, TBFLAG_A32, HSTR_ACTIVE);
+        dc->ns = FIELD_EX64(tb_flags, TBFLAG_A32, NS);
+        dc->vfp_enabled = FIELD_EX64(tb_flags, TBFLAG_A32, VFPEN);
         if (arm_feature(env, ARM_FEATURE_XSCALE)) {
-            dc->c15_cpar = FIELD_EX32(tb_flags, TBFLAG_A32, XSCALE_CPAR);
+            dc->c15_cpar = FIELD_EX64(tb_flags, TBFLAG_A32, XSCALE_CPAR);
         } else {
-            dc->vec_len = FIELD_EX32(tb_flags, TBFLAG_A32, VECLEN);
-            dc->vec_stride = FIELD_EX32(tb_flags, TBFLAG_A32, VECSTRIDE);
+            dc->vec_len = FIELD_EX64(tb_flags, TBFLAG_A32, VECLEN);
+            dc->vec_stride = FIELD_EX64(tb_flags, TBFLAG_A32, VECSTRIDE);
         }
     }
     dc->cp_regs = cpu->cp_regs;
@@ -8908,8 +8908,8 @@ static void arm_tr_init_disas_context(Di
      *   emit code to generate a software step exception
      *   end the TB
      */
-    dc->ss_active = FIELD_EX32(tb_flags, TBFLAG_ANY, SS_ACTIVE);
-    dc->pstate_ss = FIELD_EX32(tb_flags, TBFLAG_ANY, PSTATE_SS);
+    dc->ss_active = FIELD_EX64(tb_flags, TBFLAG_ANY, SS_ACTIVE);
+    dc->pstate_ss = FIELD_EX64(tb_flags, TBFLAG_ANY, PSTATE_SS);
     dc->is_ldex = false;
 
     dc->page_start = dc->base.pc_first & TARGET_PAGE_MASK;
@@ -9348,11 +9348,11 @@ void gen_intermediate_code(CPUState *cpu
     DisasContext dc = { };
     const TranslatorOps *ops = &arm_translator_ops;
 
-    if (FIELD_EX32(tb->flags, TBFLAG_AM32, THUMB)) {
+    if (FIELD_EX64(tb->flags, TBFLAG_AM32, THUMB)) {
         ops = &thumb_translator_ops;
     }
 #ifdef TARGET_AARCH64
-    if (FIELD_EX32(tb->flags, TBFLAG_ANY, AARCH64_STATE)) {
+    if (FIELD_EX64(tb->flags, TBFLAG_ANY, AARCH64_STATE)) {
         ops = &aarch64_translator_ops;
     }
 #endif
diff -x capstone -x meson -x roms -x scripts -x slirp -x .git -Nurp qemu-6.0.0/target/arm/translate.h qemu-t8030-private/target/arm/translate.h
--- qemu-6.0.0/target/arm/translate.h	2021-04-30 01:18:58.000000000 +0800
+++ qemu-t8030-private/target/arm/translate.h	2021-05-05 10:12:56.039389500 +0800
@@ -52,6 +52,8 @@ typedef struct DisasContext {
     uint32_t svc_imm;
     int aarch64;
     int current_el;
+    /* True if in GXF */
+    bool guarded;
     /* Debug target exception level for single-step exceptions */
     int debug_target_el;
     GHashTable *cp_regs;
